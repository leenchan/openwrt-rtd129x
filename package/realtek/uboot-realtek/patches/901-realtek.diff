From 16ffac503f551914138f1d16af2f6284978ee932 Mon Sep 17 00:00:00 2001
From: Liangbin Lian <jjm2473@gmail.com>
Date: Wed, 2 Jun 2021 11:44:20 +0800
Subject: [PATCH] rtk patch

Signed-off-by: Liangbin Lian <jjm2473@gmail.com>
---
 Makefile                          |   49 +-
 arch/arm/Kconfig                  |   17 +
 arch/arm/cpu/armv8/Kconfig        |   25 +
 arch/arm/cpu/armv8/Makefile       |    2 +
 arch/arm/cpu/armv8/cache_v8.c     |  122 +-
 arch/arm/cpu/armv8/cpu.c          |    8 +
 arch/arm/cpu/armv8/exceptions.S   |   26 +
 arch/arm/cpu/armv8/start.S        |  109 +-
 arch/arm/include/asm/armv8/mmu.h  |    8 +
 arch/arm/include/asm/io.h         |   29 +-
 arch/arm/include/asm/macro.h      |    2 +-
 arch/arm/lib/board.c              |  262 +-
 arch/arm/lib/bootm.c              |  152 +-
 arch/arm/lib/cache.c              |   21 +
 arch/arm/lib/gic_64.S             |  168 +-
 arch/arm/lib/interrupts_64.c      |   15 +
 arch/arm/lib/reset.c              |   13 +
 common/Kconfig                    |  118 +
 common/Makefile                   |   41 +-
 common/bootm.c                    |   10 +-
 common/cli.c                      |    6 +
 common/cli_hush.c                 |   33 +-
 common/cmd_bdinfo.c               |  353 ++-
 common/cmd_boot.c                 | 4709 ++++++++++++++++++++++++++++-
 common/cmd_bootm.c                |   60 +-
 common/cmd_date.c                 |   38 +-
 common/cmd_eeprom.c               |   83 +
 common/cmd_fastboot.c             |    8 +
 common/cmd_fdt.c                  |   18 +-
 common/cmd_gpt.c                  |   21 +-
 common/cmd_mmc.c                  |   13 +-
 common/cmd_net.c                  |   11 +
 common/cmd_nvedit.c               |    9 +
 common/cmd_pxe.c                  |    8 +-
 common/cmd_sata.c                 |   28 +-
 common/cmd_usb.c                  |   28 +
 common/cmd_version.c              |   11 +
 common/env_common.c               |   61 +
 common/fdt_support.c              |  153 +-
 common/image-fdt.c                |   12 +-
 common/main.c                     | 2005 +++++++++++-
 common/usb.c                      |  229 +-
 common/usb_hub.c                  |   64 +-
 common/usb_storage.c              |  146 +-
 disk/part.c                       |   30 +-
 drivers/Kconfig                   |    2 +
 drivers/Makefile                  |    2 +
 drivers/block/Makefile            |    1 +
 drivers/gpio/Makefile             |    8 +
 drivers/i2c/Makefile              |    5 +
 drivers/mmc/Kconfig               |   10 +
 drivers/mmc/Makefile              |   13 +-
 drivers/mmc/mmc.c                 | 1182 +++++++-
 drivers/mtd/nand/Makefile         |    2 +
 drivers/mtd/nand/nand.c           |    7 +
 drivers/mtd/nand/nand_util.c      |   86 +
 drivers/net/Makefile              |    2 +
 drivers/power/Kconfig             |    5 +
 drivers/power/Makefile            |    1 +
 drivers/pwm/Makefile              |    1 +
 drivers/rtc/Kconfig               |   12 +
 drivers/rtc/Makefile              |    1 +
 drivers/serial/ns16550.c          |   13 +
 drivers/serial/serial.c           |   14 +
 drivers/serial/serial_ns16550.c   |   29 +-
 drivers/usb/Kconfig               |   11 +
 drivers/usb/dwc3/Makefile         |    1 +
 drivers/usb/dwc3/core.c           |   31 +-
 drivers/usb/dwc3/core.h           |   10 +
 drivers/usb/dwc3/ep0.c            |    8 +-
 drivers/usb/dwc3/gadget.c         |    6 +-
 drivers/usb/gadget/Makefile       |    2 +-
 drivers/usb/gadget/f_fastboot.c   |   89 +
 drivers/usb/gadget/udc/Makefile   |    1 +
 drivers/usb/gadget/udc/udc-core.c |    2 +-
 drivers/usb/host/Kconfig          |   12 +
 drivers/usb/host/Makefile         |    4 +
 drivers/usb/host/ehci-hcd.c       |   18 +-
 drivers/usb/host/ehci.h           |    1 +
 drivers/usb/host/xhci-mem.c       |  158 +-
 drivers/usb/host/xhci-ring.c      |  148 +-
 drivers/usb/host/xhci.c           |  391 ++-
 drivers/usb/host/xhci.h           |   55 +-
 drivers/usb/phy/Makefile          |    2 +
 fs/fat/fat.c                      |   14 +-
 fs/fs.c                           |    5 +
 include/bootm.h                   |    2 +-
 include/command.h                 |    2 +
 include/common.h                  |  106 +-
 include/config_cmd_all.h          |    1 +
 include/config_defaults.h         |    2 +-
 include/dwc3-uboot.h              |   10 +
 include/env_default.h             |   51 +-
 include/environment.h             |    4 +
 include/fdt.h                     |   42 +-
 include/fdt_support.h             |    2 +-
 include/linux/compat.h            |    2 +-
 include/mmc.h                     |  118 +-
 include/nand.h                    |    4 +
 include/part.h                    |    4 +
 include/rtc.h                     |    3 +
 include/sata.h                    |    2 +
 include/search.h                  |   10 +
 include/serial.h                  |    2 +
 include/usb.h                     |   27 +-
 include/usb_defs.h                |    7 +
 include/watchdog.h                |    2 +
 lib/Kconfig                       |    5 +
 lib/Makefile                      |    4 +
 lib/fdtdec.c                      |    2 +-
 lib/hashtable.c                   |  155 +
 lib/lzma/LzmaTools.c              |    5 +-
 tools/Makefile                    |    1 +
 tools/env/fw_env.c                |    3 +
 114 files changed, 11804 insertions(+), 473 deletions(-)

diff --git a/Makefile b/Makefile
index a7dce06408..145c18b19c 100644
--- a/Makefile
+++ b/Makefile
@@ -524,6 +524,23 @@ endif
 endif
 endif
 
+#########################################################################
+# Build MIPS Image Related Setting
+
+MIPS_BOOTLOAD_IMAGE_ENABLE	= y
+ifdef CONFIG_RTD1295
+MIPS_BOOTLOAD_IMAGE_PATH	= image/rtd1295
+MIPS_BOOTLOAD_LIB_DIR		= image/rtd1295/src/app
+endif
+ifdef CONFIG_RTD1395
+MIPS_BOOTLOAD_IMAGE_PATH	= image/rtd1395
+MIPS_BOOTLOAD_LIB_DIR		= image/rtd1395/src/app
+endif
+MIPS_BOOTLOAD_LIB_NAME		= libbootload.o
+MIPS_BOOTLOAD_LIB_PATH		= $(MIPS_BOOTLOAD_LIB_DIR)/$(MIPS_BOOTLOAD_LIB_NAME)
+
+#########################################################################
+
 # If board code explicitly specified LDSCRIPT or CONFIG_SYS_LDSCRIPT, use
 # that (or fail if absent).  Otherwise, search for a linker script in a
 # standard location.
@@ -634,6 +651,7 @@ libs-y += drivers/dma/
 libs-y += drivers/gpio/
 libs-y += drivers/i2c/
 libs-y += drivers/mmc/
+libs-y += drivers/pcb_mgr/
 libs-y += drivers/mtd/
 libs-$(CONFIG_CMD_NAND) += drivers/mtd/nand/
 libs-y += drivers/mtd/onenand/
@@ -687,9 +705,12 @@ u-boot-main := $(libs-y)
 ifeq ($(CONFIG_USE_PRIVATE_LIBGCC),y)
 PLATFORM_LIBGCC = arch/$(ARCH)/lib/lib.a
 else
-PLATFORM_LIBGCC := -L $(shell dirname `$(CC) $(c_flags) -print-libgcc-file-name`) -lgcc
+PLATFORM_LIBGCC := -L $(shell dirname `$(CC) $(AACC) $(c_flags) -print-libgcc-file-name`) -lgcc
 endif
 PLATFORM_LIBS += $(PLATFORM_LIBGCC)
+ifneq ($(wildcard static_lib/libefuse.a),)
+PLATFORM_LIBS += static_lib/libefuse.a
+endif
 export PLATFORM_LIBS
 export PLATFORM_LIBGCC
 
@@ -699,6 +720,7 @@ export PLATFORM_LIBGCC
 LDPPFLAGS += \
 	-include $(srctree)/include/u-boot/u-boot.lds.h \
 	-DCPUDIR=$(CPUDIR) \
+	-DMIPS_BOOTLOAD_LIB_PATH=$(MIPS_BOOTLOAD_LIB_PATH) \
 	$(shell $(LD) --version | \
 	  sed -ne 's/GNU ld version \([0-9][0-9]*\)\.\([0-9][0-9]*\).*/-DLD_MAJOR=\1 -DLD_MINOR=\2/p')
 
@@ -1125,9 +1147,9 @@ u-boot.elf: u-boot.bin
 # Rule to link u-boot
 # May be overridden by arch/$(ARCH)/config.mk
 quiet_cmd_u-boot__ ?= LD      $@
-      cmd_u-boot__ ?= $(LD) $(LDFLAGS) $(LDFLAGS_u-boot) -o $@ \
-      -T u-boot.lds $(u-boot-init)                             \
-      --start-group $(u-boot-main) --end-group                 \
+      cmd_u-boot__ ?= $(LD) $(LDFLAGS) $(LDFLAGS_u-boot) -o $@ 				\
+      -T u-boot.lds $(u-boot-init)                             				\
+      --start-group $(u-boot-main) $(MIPS_BOOTLOAD_LIB_PATH) --end-group 	\
       $(PLATFORM_LIBS) -Map u-boot.map
 
 quiet_cmd_smap = GEN     common/system_map.o
@@ -1138,6 +1160,21 @@ cmd_smap = \
 		-c $(srctree)/common/system_map.c -o common/system_map.o
 
 u-boot:	$(u-boot-init) $(u-boot-main) u-boot.lds
+ifeq ($(MIPS_BOOTLOAD_IMAGE_ENABLE),y)
+		$(CC) $(CFLAGS) -c -o $(MIPS_BOOTLOAD_LIB_DIR)/bootload.o $(MIPS_BOOTLOAD_LIB_DIR)/bootload.c
+		$(LD) $(LDFLAGS) -r -o $(MIPS_BOOTLOAD_LIB_DIR)/$(MIPS_BOOTLOAD_LIB_NAME) $(MIPS_BOOTLOAD_LIB_DIR)/bootload.o
+		$(OBJCOPY) --add-section .v_entry=$(MIPS_BOOTLOAD_IMAGE_PATH)/v_entry.img $(MIPS_BOOTLOAD_LIB_PATH)
+		$(OBJCOPY) --add-section .exc_redirect=$(MIPS_BOOTLOAD_IMAGE_PATH)/exc_redirect.img $(MIPS_BOOTLOAD_LIB_PATH)
+		$(OBJCOPY) --add-section .exc_dispatch=$(MIPS_BOOTLOAD_IMAGE_PATH)/exc_dispatch.img $(MIPS_BOOTLOAD_LIB_PATH)
+		$(OBJCOPY) --add-section .isrvideoimg=$(MIPS_BOOTLOAD_IMAGE_PATH)/isr_video.img $(MIPS_BOOTLOAD_LIB_PATH)
+		$(OBJCOPY) --add-section .rosbootvectorimg=$(MIPS_BOOTLOAD_IMAGE_PATH)/ros_bootvector.img $(MIPS_BOOTLOAD_LIB_PATH)
+		$(OBJCOPY) --add-section .a_entry=$(MIPS_BOOTLOAD_IMAGE_PATH)/a_entry.img $(MIPS_BOOTLOAD_LIB_PATH)
+
+else
+		@echo "Warning : MIPS_BOOTLOAD_IMAGE_ENABLE = n"
+endif
+
+
 	$(call if_changed,u-boot__)
 ifeq ($(CONFIG_KALLSYMS),y)
 	$(call cmd,smap)
@@ -1247,7 +1284,9 @@ $(timestamp_h): $(srctree)/Makefile FORCE
 
 PHONY += depend dep
 depend dep:
-	@echo '*** Warning: make $@ is unnecessary now.'
+#	@echo '*** Warning: make $@ is unnecessary now.'
+
+
 
 # ---------------------------------------------------------------------------
 quiet_cmd_cpp_lds = LDS     $@
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 9908b430d6..56a33f4de8 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -817,6 +817,22 @@ config TARGET_STM32F429_DISCOVERY
 	bool "Support STM32F429 Discovery"
 	select CPU_V7M
 
+config TARGET_RTD1295
+	bool "Support RealTek 1295 platform"
+	select ARM64
+	
+config TARGET_RTD1296
+	bool "Support RealTek 1296 platform"
+	depends on TARGET_RTD1295
+	
+config TARGET_RTD1293
+	bool "Support RealTek 1293 platform"
+	depends on TARGET_RTD1295
+
+config TARGET_RTD1395
+	bool "Support RealTek 1395 platform"
+	select ARM64
+
 endchoice
 
 source "arch/arm/mach-at91/Kconfig"
@@ -984,6 +1000,7 @@ source "board/work-microwave/work_92105/Kconfig"
 source "board/xaeniax/Kconfig"
 source "board/xilinx/zynqmp/Kconfig"
 source "board/zipitz2/Kconfig"
+source "board/realtek/Kconfig"
 
 source "arch/arm/Kconfig.debug"
 
diff --git a/arch/arm/cpu/armv8/Kconfig b/arch/arm/cpu/armv8/Kconfig
index 4cd84b0311..a7e7cd2dec 100644
--- a/arch/arm/cpu/armv8/Kconfig
+++ b/arch/arm/cpu/armv8/Kconfig
@@ -4,3 +4,28 @@ config ARMV8_MULTIENTRY
         boolean "Enable multiple CPUs to enter into U-boot"
 
 endif
+
+config RTK_XEN_MONITOR_SUPPORT
+	boolean "RTK XEN-Monitor mode support"
+	depends on TARGET_RTD1295
+	default n
+	help
+	  REALTEK XEN EL3 Monitor mode support. Turn on this
+	  configuration so XEN could perform initialization
+	  for the 1st time when startup.
+
+config RTK_SLAVE_CPU_BOOT
+	boolean "RTK support for slave cpu boot into uboot"
+	depends on TARGET_RTD1295 || TARGET_RTD1395
+	select ARMV8_MULTIENTRY
+	default n
+	help
+	  Support for RealTek platform slave CPU boot into uboot.
+
+config POWER_DOWN_S5
+	bool "Enter S5 stage at bootcode stage"
+	depends on TARGET_RTD1295
+	default n
+	help
+	  This config will enable SOC to enter S5
+	  stage at bootcode.
diff --git a/arch/arm/cpu/armv8/Makefile b/arch/arm/cpu/armv8/Makefile
index dee5e258b6..40800f4550 100644
--- a/arch/arm/cpu/armv8/Makefile
+++ b/arch/arm/cpu/armv8/Makefile
@@ -17,3 +17,5 @@ obj-y	+= transition.o
 
 obj-$(CONFIG_FSL_LSCH3) += fsl-lsch3/
 obj-$(CONFIG_TARGET_XILINX_ZYNQMP) += zynqmp/
+obj-$(CONFIG_TARGET_RTD1295) += rtd1295/
+obj-$(CONFIG_TARGET_RTD1395) += rtd1395/
diff --git a/arch/arm/cpu/armv8/cache_v8.c b/arch/arm/cpu/armv8/cache_v8.c
index c5ec5297cd..5e99d5ecf4 100644
--- a/arch/arm/cpu/armv8/cache_v8.c
+++ b/arch/arm/cpu/armv8/cache_v8.c
@@ -9,6 +9,10 @@
 #include <asm/system.h>
 #include <asm/armv8/mmu.h>
 
+#ifdef CONFIG_BSP_REALTEK
+#include <asm/arch/system.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #ifndef CONFIG_SYS_DCACHE_OFF
@@ -25,7 +29,8 @@ void set_pgtable_section(u64 *page_table, u64 index, u64 section,
 /* to activate the MMU we need to set up virtual memory */
 static void mmu_setup(void)
 {
-	int i, j, el;
+	u64 i, j;
+	unsigned int el;
 	bd_t *bd = gd->bd;
 	u64 *page_table = (u64 *)gd->arch.tlb_addr;
 
@@ -46,6 +51,11 @@ static void mmu_setup(void)
 		}
 	}
 
+#ifdef CONFIG_BSP_REALTEK	// map RBUS region
+	for (i = RBUS_ADDR >> SECTION_SHIFT ; i <= RBUS_END >> SECTION_SHIFT ; i++ )
+		set_pgtable_section(page_table, i, i << SECTION_SHIFT, MT_DEVICE_NGNRE);
+#endif
+
 	/* load TTBR0 */
 	el = current_el();
 	if (el == 1) {
@@ -65,6 +75,18 @@ static void mmu_setup(void)
 	set_sctlr(get_sctlr() | CR_M);
 }
 
+void mmu_set_region(u64 start, u64 size, u64 memory_type)
+{
+	u64 i;
+	u64 *page_table = (u64 *)gd->arch.tlb_addr;
+
+	for (i = start >> SECTION_SHIFT ; i <= (start + size) >> SECTION_SHIFT ; i++ )
+		set_pgtable_section(page_table, i, i << SECTION_SHIFT, memory_type);
+
+	flush_dcache_all();
+	__asm_invalidate_tlb_all();
+}
+
 /*
  * Performs a invalidation of the entire data cache at all levels
  */
@@ -125,7 +147,7 @@ void dcache_disable(void)
 	sctlr = get_sctlr();
 
 	/* if cache isn't enabled no need to disable */
-	if (!(sctlr & CR_C))
+	if (!(sctlr & CR_C) && !(sctlr & CR_M))
 		return;
 
 	set_sctlr(sctlr & ~(CR_C|CR_M));
@@ -233,3 +255,99 @@ void flush_cache(unsigned long start, unsigned long size)
 {
 	flush_dcache_range(start, start + size);
 }
+
+#ifdef CONFIG_CMD_CACHETEST
+void dcache_disable_no_flush(void)
+{
+	uint32_t sctlr;
+
+	sctlr = get_sctlr();
+
+	/* if cache isn't enabled no need to disable */
+	if (!(sctlr & CR_C))
+		return;
+
+	set_sctlr(sctlr & ~(CR_C|CR_M));
+}
+
+static void mmu_setup_wt(void) // To set up cache as writethrough
+{
+	u64 i, j;
+	unsigned int el;
+	bd_t *bd = gd->bd;
+	u64 *page_table = (u64 *)gd->arch.tlb_addr;
+
+	/* Setup an identity-mapping for all spaces */
+	for (i = 0; i < (PGTABLE_SIZE >> 3); i++) {
+		set_pgtable_section(page_table, i, i << SECTION_SHIFT,
+				    MT_DEVICE_NGNRNE);
+	}
+
+	/* Setup an identity-mapping for all RAM space */
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		ulong start = bd->bi_dram[i].start;
+		ulong end = bd->bi_dram[i].start + bd->bi_dram[i].size;
+		for (j = start >> SECTION_SHIFT;
+		     j < end >> SECTION_SHIFT; j++) {
+			set_pgtable_section(page_table, j, j << SECTION_SHIFT,
+					    MT_NORMAL);
+		}
+	}
+
+#ifdef CONFIG_BSP_REALTEK	// map RBUS region
+	for (i = RBUS_ADDR >> SECTION_SHIFT ; i <= RBUS_END >> SECTION_SHIFT ; i++ )
+		set_pgtable_section(page_table, i, i << SECTION_SHIFT, MT_DEVICE_NGNRE);
+#endif
+
+	/* load TTBR0 */
+	el = current_el();
+	if (el == 1) {
+		set_ttbr_tcr_mair(el, gd->arch.tlb_addr,
+				  TCR_FLAGS | TCR_EL1_IPS_BITS,
+				  MEMORY_ATTRIBUTES_WT);
+	} else if (el == 2) {
+		set_ttbr_tcr_mair(el, gd->arch.tlb_addr,
+				  TCR_FLAGS | TCR_EL2_IPS_BITS,
+				  MEMORY_ATTRIBUTES_WT);
+	} else {
+		set_ttbr_tcr_mair(el, gd->arch.tlb_addr,
+				  TCR_FLAGS | TCR_EL3_IPS_BITS,
+				  MEMORY_ATTRIBUTES_WT);
+	}
+	/* enable the mmu */
+	set_sctlr(get_sctlr() | CR_M);
+}
+
+void dcache_enable_wt(void)
+{
+	/* The data cache is not active unless the mmu is enabled */
+	if (!(get_sctlr() & CR_M)) {
+		invalidate_dcache_all();
+		__asm_invalidate_tlb_all();
+		mmu_setup_wt();
+	}
+
+	set_sctlr(get_sctlr() | CR_C);
+}
+
+void reset_cache_write_through(void)
+{
+	icache_disable();
+	invalidate_icache_all();
+	dcache_disable();
+	invalidate_dcache_all();
+
+	icache_enable();
+	dcache_enable_wt();
+}
+
+void reset_cache_write_back(void)
+{
+	icache_disable();
+	invalidate_icache_all();
+	dcache_disable();
+	invalidate_dcache_all();
+
+	enable_caches();
+}
+#endif
diff --git a/arch/arm/cpu/armv8/cpu.c b/arch/arm/cpu/armv8/cpu.c
index e06c3cc04d..7c8791f34f 100644
--- a/arch/arm/cpu/armv8/cpu.c
+++ b/arch/arm/cpu/armv8/cpu.c
@@ -41,3 +41,11 @@ int cleanup_before_linux(void)
 
 	return 0;
 }
+
+int cleanup_before_bootcode(void) {
+	return cleanup_before_linux();
+}
+
+int cleanup_before_dvrbootexe(void) {
+	return cleanup_before_linux();
+}
\ No newline at end of file
diff --git a/arch/arm/cpu/armv8/exceptions.S b/arch/arm/cpu/armv8/exceptions.S
index baf9401e64..47ea9db20f 100644
--- a/arch/arm/cpu/armv8/exceptions.S
+++ b/arch/arm/cpu/armv8/exceptions.S
@@ -11,6 +11,10 @@
 #include <asm/macro.h>
 #include <linux/linkage.h>
 
+#ifdef CONFIG_RTK_XEN_MONITOR_SUPPORT
+#define XEN_MON_MAGIC	0xaabbccdd
+#endif
+
 /*
  * Enter Exception.
  * This will save the processor state that is ELR/X0~X30
@@ -78,6 +82,10 @@ vectors:
 	.align	7
 	b	_do_error	/* Current EL Error Handler */
 
+#ifdef CONFIG_RTK_XEN_MONITOR_SUPPORT
+	.align	7
+	b	_do_smc_sync	/* Lower EL Synchronous Handler */
+#endif
 
 _do_bad_sync:
 	exception_entry
@@ -110,3 +118,21 @@ _do_fiq:
 _do_error:
 	exception_entry
 	bl	do_error
+
+#ifdef CONFIG_RTK_XEN_MONITOR_SUPPORT
+// For XEN monitor initialization, since Xen runs under EL2
+// EL3 vector table will need to be set up for 1st time.
+// X0:MAGIC, X1:VBAR_XEN, X2:SP_EL3_XEN
+_do_smc_sync:
+	ldr	x3, =XEN_MON_MAGIC
+	cmp	x0, x3
+	bne	1f
+	mov	sp, x2		// Setup EL3 SP from XEN
+	msr	vbar_el3, x1	// Setup XEN MONITOR vector
+	mov	x0, #0
+	b	2f
+1:
+	mov	x0, #1
+2:
+	eret
+#endif
diff --git a/arch/arm/cpu/armv8/start.S b/arch/arm/cpu/armv8/start.S
index e5f2766a4a..26ed007f87 100644
--- a/arch/arm/cpu/armv8/start.S
+++ b/arch/arm/cpu/armv8/start.S
@@ -10,6 +10,7 @@
 #include <linux/linkage.h>
 #include <asm/macro.h>
 #include <asm/armv8/mmu.h>
+#include <asm/arch/cpu.h>
 
 /*************************************************************************
  *
@@ -77,7 +78,16 @@ reset:
 	 */
 
 	/* Processor specific initialization */
+	/* When bootcode is in el2, not to set gic. */
+	switch_el x1, 3f, 2f, 1f
+3:	
+#ifdef CONFIG_GICV3_REALTEK
+	bl	gic_v3_realtek_init
+#else
 	bl	lowlevel_init
+#endif
+2:
+1:
 
 #ifdef CONFIG_ARMV8_MULTIENTRY
 	branch_if_master x0, x1, master_cpu
@@ -87,10 +97,28 @@ reset:
 	 */
 slave_cpu:
 	wfe
+	mov	x0, #0
 	ldr	x1, =CPU_RELEASE_ADDR
-	ldr	x0, [x1]
+	ldr	w0, [x1]
 	cbz	x0, slave_cpu
+#ifdef CONFIG_TARGET_RTD1295
+	//A01 Jump to BL31 at EL3
+	
+#if defined(CONFIG_SYS_RTK_SPI_FLASH) || defined(CONFIG_SYS_RTK_SD_FLASH) || defined(CONFIG_SYS_NO_BL31)
+	mov w2, #RTD129x_CHIP_REVISION_A00
+#else
+ 	ldr x1, =SB2_CHIP_INFO
+ 	ldr	w2, [x1]
+#endif
+ 	cmp w2, #RTD129x_CHIP_REVISION_A01
+ 	bne JUMP_TO_KERNEL   /*Just A01 need to go BL31*/
+JUMP_TO_BL31:
+    ldr x30, =BL31_ENTRY_ADDR
+	ret
+#endif /* CONFIG_TARGET_RTD1295 */
+JUMP_TO_KERNEL:
 	br	x0			/* branch to the given address */
+
 master_cpu:
 	/* On the master CPU */
 #endif /* CONFIG_ARMV8_MULTIENTRY */
@@ -144,12 +172,40 @@ ENDPROC(apply_core_errata)
 WEAK(lowlevel_init)
 	mov	x29, lr			/* Save LR */
 
+#ifndef CONFIG_CORTEX_A55
+	mov	x0, #0x1
+	lsl	x0, x0, #6
+	msr	S3_1_C15_C2_1, x0       /* set up each core CPUECTLR.SMPEN bit for Cache Coherency */
+#endif
+
+	/* setup ACTLR_EL3(2).CPUECTLR_EL1 bit*/
+	mov	x0, #0x2
+	
+	mrs     x1, CurrentEL
+    lsr     x1, x1, #2
+	switch_el x1, 1f, 2f, 3f   /*B00 is at EL2, it does not have privilege to set EL3 */
+	
+3:	mrs x1, ACTLR_EL3
+	orr	x1, x1, x0
+	msr	ACTLR_EL3, x1   
+	
+2:	mrs	x1, ACTLR_EL2
+	orr	x1, x1, x0
+	msr	ACTLR_EL2, x1
+
+1:  mrs	x1, ACTLR_EL1
+	orr	x1, x1, x0
+	msr	ACTLR_EL1, x1
+
 #ifndef CONFIG_ARMV8_MULTIENTRY
 	/*
 	 * For single-entry systems the lowlevel init is very simple.
 	 */
 	ldr	x0, =GICD_BASE
 	bl	gic_init_secure
+	ldr	x0, =GICD_BASE
+	ldr	x1, =GICC_BASE
+	bl	gic_init_secure_percpu
 
 #else /* CONFIG_ARMV8_MULTIENTRY is set */
 
@@ -185,7 +241,20 @@ WEAK(lowlevel_init)
 	/*
 	 * All slaves will enter EL2 and optionally EL1.
 	 */
+
+	//A01 Jump to BL31 at EL3
+#ifdef CONFIG_TARGET_RTD1295
+#if defined(CONFIG_SYS_RTK_SPI_FLASH) || defined(CONFIG_SYS_RTK_SD_FLASH) || defined(CONFIG_SYS_NO_BL31)
+	mov w0, #RTD129x_CHIP_REVISION_A00
+#else
+ 	ldr x1, =SB2_CHIP_INFO
+ 	ldr	w0, [x1]
+#endif
+ 	cmp w0, #RTD129x_CHIP_REVISION_A01
+ 	bge 2f
+#endif /* CONFIG_TARGET_RTD1295 */
 	bl	armv8_switch_to_el2
+
 #ifdef CONFIG_ARMV8_SWITCH_TO_EL1
 	bl	armv8_switch_to_el1
 #endif
@@ -223,3 +292,41 @@ ENTRY(c_runtime_cpu_setup)
 
 	ret
 ENDPROC(c_runtime_cpu_setup)
+
+#ifdef CONFIG_GICV3_REALTEK
+
+ENTRY(gic_v3_realtek_init)
+	mov	x29, lr			/* Save LR */
+
+	mrs	x0, mpidr_el1
+	and x0, x0, 0xffff
+	lsr	x1, x0, #0x8
+	/* The cpu id in cortex-a55 is at [11:8] */
+	mov x0, #0x0
+	cmp x1, x0
+	bne slave_gic_init
+	/* To decide this is the master or slave core */
+	
+	ldr	x0, =GICD_BASE
+	bl rtk_arm_gic_init_percpu_v3
+	b end_gic_init
+
+slave_gic_init:
+	mov x2, #0x20000
+	mul x3, x2, x1
+	/* x1 is the cpu id for computing offset */
+	/* x3 is the offset of RD and SGI base for each core */
+	
+	ldr	x0, =GICR_RD_BASE
+	add x0, x0, x3
+	ldr	x1, =GICR_SGI_BASE
+	add x1, x1, x3
+	bl rtk_arm_gic_init_slavecpu_v3
+	
+end_gic_init:
+
+	mov	lr, x29			/* Restore LR */
+	ret
+ENDPROC(gic_v3_realtek_init)
+
+#endif /* CONFIG_GICV3_REALTEK */
\ No newline at end of file
diff --git a/arch/arm/include/asm/armv8/mmu.h b/arch/arm/include/asm/armv8/mmu.h
index 4b9cb52965..b8e2e2b533 100644
--- a/arch/arm/include/asm/armv8/mmu.h
+++ b/arch/arm/include/asm/armv8/mmu.h
@@ -52,6 +52,12 @@
 				(0x44 << (MT_NORMAL_NC*8)) |		\
 				(UL(0xff) << (MT_NORMAL*8)))
 
+// Normal memory configured as write-through
+#define MEMORY_ATTRIBUTES_WT	((0x00 << (MT_DEVICE_NGNRNE*8)) |	\
+				(0x04 << (MT_DEVICE_NGNRE*8)) |		\
+				(0x0c << (MT_DEVICE_GRE*8)) |		\
+				(0x44 << (MT_NORMAL_NC*8)) |		\
+				(UL(0xbb) << (MT_NORMAL*8)))
 /*
  * Hardware page table definitions.
  *
@@ -132,5 +138,7 @@ static inline void set_ttbr_tcr_mair(int el, u64 table, u64 tcr, u64 attr)
 	}
 	asm volatile("isb");
 }
+
+void mmu_set_region(u64 start, u64 size, u64 memory_type);
 #endif
 #endif /* _ASM_ARMV8_MMU_H_ */
diff --git a/arch/arm/include/asm/io.h b/arch/arm/include/asm/io.h
index bfbe0a0988..719176d80e 100644
--- a/arch/arm/include/asm/io.h
+++ b/arch/arm/include/asm/io.h
@@ -29,9 +29,6 @@
 #include <asm/arch/hardware.h>
 #endif	/* XXX###XXX */
 
-static inline void sync(void)
-{
-}
 
 /*
  * Given a physical address and a length, return a virtual address
@@ -67,6 +64,7 @@ static inline phys_addr_t virt_to_phys(void * vaddr)
  * read/writes.  We define __arch_*[bl] here, and leave __arch_*w
  * to the architecture specific code.
  */
+#if 0
 #define __arch_getb(a)			(*(volatile unsigned char *)(a))
 #define __arch_getw(a)			(*(volatile unsigned short *)(a))
 #define __arch_getl(a)			(*(volatile unsigned int *)(a))
@@ -76,6 +74,17 @@ static inline phys_addr_t virt_to_phys(void * vaddr)
 #define __arch_putw(v,a)		(*(volatile unsigned short *)(a) = (v))
 #define __arch_putl(v,a)		(*(volatile unsigned int *)(a) = (v))
 #define __arch_putq(v,a)		(*(volatile unsigned long long *)(a) = (v))
+#else /* error: cast to pointer from integer of different size [-Werror=int-to-pointer-cast] */
+#define __arch_getb(a)			(*(volatile unsigned char *)((unsigned long)a))
+#define __arch_getw(a)			(*(volatile unsigned short *)((unsigned long)a))
+#define __arch_getl(a)			(*(volatile unsigned int *)((unsigned long)a))
+#define __arch_getq(a)			(*(volatile unsigned long long *)((unsigned long)a))
+
+#define __arch_putb(v,a)		(*(volatile unsigned char *)((unsigned long)a) = (v))
+#define __arch_putw(v,a)		(*(volatile unsigned short *)((unsigned long)a) = (v))
+#define __arch_putl(v,a)		(*(volatile unsigned int *)((unsigned long)a) = (v))
+#define __arch_putq(v,a)		(*(volatile unsigned long long *)((unsigned long)a) = (v))
+#endif
 
 static inline void __raw_writesb(unsigned long addr, const void *data,
 				 int bytelen)
@@ -132,15 +141,27 @@ static inline void __raw_readsl(unsigned long addr, void *data, int longlen)
 #define __raw_readl(a)		__arch_getl(a)
 #define __raw_readq(a)		__arch_getq(a)
 
+
+static inline void sync(void)
+{
+	asm volatile("DMB SY" : : : "memory");
+	__raw_writel(0x00000000, 0x9801A020);
+	asm volatile("DMB SY" : : : "memory");
+}
+
 /*
  * TODO: The kernel offers some more advanced versions of barriers, it might
  * have some advantages to use them instead of the simple one here.
  */
 #define mb()		asm volatile("dsb sy" : : : "memory")
 #define dmb()		__asm__ __volatile__ ("" : : : "memory")
+#define dsb()		__asm__ __volatile__ ("dsb sy" : : : "memory")
 #define __iormb()	dmb()
 #define __iowmb()	dmb()
 
+#define rmb()       dsb()
+#define wmb()       dsb()
+
 #define writeb(v,c)	({ u8  __v = v; __iowmb(); __arch_putb(__v,c); __v; })
 #define writew(v,c)	({ u16 __v = v; __iowmb(); __arch_putw(__v,c); __v; })
 #define writel(v,c)	({ u32 __v = v; __iowmb(); __arch_putl(__v,c); __v; })
@@ -453,6 +474,6 @@ out:
 #endif	/* __mem_isa */
 #endif	/* __KERNEL__ */
 
-#include <iotrace.h>
+//#include <iotrace.h>
 
 #endif	/* __ASM_ARM_IO_H */
diff --git a/arch/arm/include/asm/macro.h b/arch/arm/include/asm/macro.h
index 9bb0efa5ff..35ea0029f3 100644
--- a/arch/arm/include/asm/macro.h
+++ b/arch/arm/include/asm/macro.h
@@ -137,7 +137,7 @@ lr	.req	x30
 
 .macro armv8_switch_to_el2_m, xreg1
 	/* 64bit EL2 | HCE | SMD | RES1 (Bits[5:4]) | Non-secure EL0/EL1 */
-	mov	\xreg1, #0x5b1
+	mov	\xreg1, #0x531
 	msr	scr_el3, \xreg1
 	msr	cptr_el3, xzr		/* Disable coprocessor traps to EL3 */
 	mov	\xreg1, #0x33ff
diff --git a/arch/arm/lib/board.c b/arch/arm/lib/board.c
index 37ea6e90ec..b46c8600ce 100644
--- a/arch/arm/lib/board.c
+++ b/arch/arm/lib/board.c
@@ -40,6 +40,23 @@
 #include <post.h>
 #include <logbuff.h>
 #include <asm/sections.h>
+#include <rtkemmc_generic.h>
+
+#include <asm/arch/platform_lib/board/pcb_mgr.h>
+#include <asm/arch/extern_param.h>
+#include <asm/arch/fw_info.h>
+#include <asm/arch/rtk_ipc_shm.h>
+#include <asm/arch/system.h>
+#include <asm/arch/ir.h>
+#include <asm/arch/pwm.h>
+#include <asm/arch/factorylib.h>
+#include <asm/arch/factorylib_ro.h>
+#include <asm/arch/bootparam.h>
+#include <asm/arch/rbus/iso_reg.h>
+#include <asm/arch/rbus/misc_reg.h>
+#include <asm/arch/md.h>
+#include <logo_disp/logo_disp_api.h>
+#include <watchdog.h>
 
 #ifdef CONFIG_BITBANGMII
 #include <miiphy.h>
@@ -59,6 +76,25 @@ extern void dataflash_print_info(void);
 #include <i2c.h>
 #endif
 
+#ifdef CONFIG_RTK_EMMC_TRADITIONAL_MODE
+#define RTK_eMMC_TRADITIONAL_MODE
+#else
+#define RTK_eMMC_FAST_MODE	//if users want to use mmc command, just undef RTK_eMMC_FAST_MODE
+#endif
+
+/************************************************************************
+ *  External variables
+ ************************************************************************/
+extern int _f_exc_redirect_img, _e_exc_redirect_img;
+extern int _f_exc_dispatch_img, _e_exc_dispatch_img;
+extern int _f_a_entry_img, _e_a_entry_img;
+extern int _f_v_entry_img, _e_v_entry_img;
+extern int _f_isrvideo_img, _e_isrvideo_img;
+extern int _f_rosbootvector_img, _e_rosbootvector_img;
+
+struct RTK119X_ipc_shm ipc_shm;
+struct RTK119X_ipc_shm_ir ipc_ir;
+BOOT_FLASH_T boot_flash_type;
 /************************************************************************
  * Coloured LED functionality
  ************************************************************************
@@ -74,6 +110,11 @@ __weak void yellow_led_off(void) {}
 __weak void blue_led_on(void) {}
 __weak void blue_led_off(void) {}
 
+extern int rtl8168_initialize(bd_t *bis);
+extern void set_hdmi_off(void);
+extern int sink_capability_handler(int set);
+extern int dptx_sink_capability_handler(int set);
+
 /*
  ************************************************************************
  * Init Utilities							*
@@ -134,8 +175,9 @@ static int display_dram_config(void)
 	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
 		size += gd->bd->bi_dram[i].size;
 
+	extern unsigned long get_accessible_ddr_size(int unit);
 	puts("DRAM:  ");
-	print_size(size, "\n");
+	print_size(get_accessible_ddr_size(UNIT_BYTE), "\n");
 #endif
 
 	return (0);
@@ -222,26 +264,26 @@ init_fnc_t *init_sequence[] = {
 #if defined(CONFIG_BOARD_EARLY_INIT_F)
 	board_early_init_f,
 #endif
-	timer_init,		/* initialize timer */
+	timer_init,			/* initialize timer */
 #ifdef CONFIG_BOARD_POSTCLK_INIT
 	board_postclk_init,
 #endif
 #ifdef CONFIG_FSL_ESDHC
 	get_clocks,
 #endif
-	env_init,		/* initialize environment */
+	env_init,			/* initialize environment */
 	init_baudrate,		/* initialze baudrate settings */
 	serial_init,		/* serial communications setup */
 	console_init_f,		/* stage 1 init of console */
 	display_banner,		/* say that we are here */
 	print_cpuinfo,		/* display cpu info (and speed) */
 #if defined(CONFIG_DISPLAY_BOARDINFO)
-	checkboard,		/* display board info */
+	checkboard,			/* display board info */
 #endif
 #if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)
 	init_func_i2c,
 #endif
-	dram_init,		/* configure available RAM banks */
+	dram_init,			/* configure available RAM banks */
 	NULL,
 };
 
@@ -433,11 +475,17 @@ void board_init_f(ulong bootflag)
 	/* Ram ist board specific, so move it to board code ... */
 	dram_init_banksize();
 	display_dram_config();	/* and display it */
-
+#ifdef CONFIG_NO_RELOCATION
+	gd->relocaddr = (ulong)&_start;
+	gd->start_addr_sp = CONFIG_SYS_INIT_SP_ADDR;
+	gd->reloc_off = 0;
+	debug("Don't do relocation!\n");
+#else
 	gd->relocaddr = addr;
 	gd->start_addr_sp = addr_sp;
 	gd->reloc_off = addr - (ulong)&_start;
 	debug("relocation Offset is: %08lx\n", gd->reloc_off);
+#endif //CONFIG_NO_RELOCATION
 	if (new_fdt) {
 		memcpy(new_fdt, gd->fdt_blob, fdt_size);
 		gd->fdt_blob = new_fdt;
@@ -481,6 +529,39 @@ static void display_fdt_model(const void *blob)
 }
 #endif
 
+
+void set_shared_memory_for_communication_with_ACPU(void)
+{
+	unsigned svn_number = 0, svn_len = 0, i=0, mul_base = 1;
+	char *start_ptr = NULL, *end_ptr = NULL;
+
+	memset(&ipc_shm,0x0,sizeof(ipc_shm));
+	memset(&ipc_ir,0x0,sizeof(ipc_ir));
+	
+	// fill the UART register base address for A/V CPU.
+	ipc_shm.sys_assign_serial = SWAPEND32(CONFIG_SYS_NS16550_COM1 | 0xc0000000);
+	// VIDEO FORMAT PTR ADDRESS
+	ipc_shm.pov_boot_vd_std_ptr = SWAPEND32(VO_RESOLUTION);
+	// u-boot version MAGIC pass to FW 'svn\0'
+	ipc_shm.u_boot_version_magic = SWAPEND32(0x73766e00);
+	// u-boot SVN number pass to FW
+	if((start_ptr = strstr(U_BOOT_VERSION, "-svn"))) {
+		start_ptr +=4;
+		if((end_ptr = strchr(start_ptr, ' ')))
+			svn_len = end_ptr - start_ptr;
+		else
+			svn_len = strlen(start_ptr);
+		
+		for(i = 0 ; i < svn_len ; i++) {
+			svn_number += (start_ptr[svn_len-i-1] - '0') * mul_base;
+			mul_base *= 10;
+		}
+	} else {
+		svn_number = 0;
+	}
+	ipc_shm.u_boot_version_info = SWAPEND32(svn_number);
+}
+
 /************************************************************************
  *
  * This is the next part if the initialization sequence: we are now
@@ -498,6 +579,17 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	ulong flash_size;
 #endif
 
+
+#ifdef CONFIG_REALTEK_WATCHDOG
+	WATCHDOG_KICK();
+	puts("Watchdog: Enabled\n");
+#else
+	puts("Watchdog: Disabled\n");
+#endif
+
+	
+	gd = id;
+
 	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
 	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");
 
@@ -505,6 +597,9 @@ void board_init_r(gd_t *id, ulong dest_addr)
 
 	/* Enable caches */
 	enable_caches();
+#ifdef CONFIG_SYS_NONCACHED_MEMORY
+	noncached_init();
+#endif
 
 	debug("monitor flash len: %08lX\n", monitor_flash_len);
 	board_init();	/* Setup chipselects */
@@ -528,9 +623,67 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	post_output_backlog();
 #endif
 
+#ifndef CONFIG_NO_RELOCATION
 	/* The Malloc area is immediately below the monitor copy in DRAM */
 	malloc_start = dest_addr - TOTAL_MALLOC_LEN;
+#else
+	/* RTK disable Relocation */
+	malloc_start = CONFIG_HEAP_ADDR;
+#endif //CONFIG_NO_RELOCATION
 	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);
+	//mem_malloc_noncache_init(UBOOT_NONCACHE_MEMORY_ADDR, (1 << 20));
+
+
+//**************************************************************************		
+/*
+ *********************************************************
+ * Realtek Patch:
+ *	Copy several mips codes from .data section
+ *	to specific ddr region for A/V CPU use.
+ *********************************************************
+ */
+#ifdef CONFIG_BSP_REALTEK
+{
+	unsigned char *a,*b;
+
+#ifndef CONFIG_POWER_DOWN_MD
+	// copy .exc_redirect (MIPS exception redirect)
+	a = (unsigned char *)&_e_exc_redirect_img;
+	b = (unsigned char *)&_f_exc_redirect_img;
+	md_memcpy((unsigned char *)MIPS_EXC_REDIRECT_CODE_ADDR, b, a-b);
+
+	// copy .exc_dispatch (MIPS exception dispatch)
+	a = (unsigned char *)&_e_exc_dispatch_img;
+	b = (unsigned char *)&_f_exc_dispatch_img;
+	md_memcpy((unsigned char *)MIPS_EXC_DISPATCH_CODE_ADDR, b, a-b);
+
+	// copy .isrvideoimg (video cpu isr handler)
+	a = (unsigned char *)&_e_isrvideo_img;
+	b = (unsigned char *)&_f_isrvideo_img;
+	md_memcpy((unsigned char *)MIPS_ISR_VIDEO_IMG_ADDR, b, a-b);
+
+	// copy .rosbootvectorimg (MIPS vector interrupt)
+	a = (unsigned char *)&_e_rosbootvector_img;
+	b = (unsigned char *)&_f_rosbootvector_img;
+	md_memcpy((unsigned char *)MIPS_ROS_BOOT_VECTOR_IMG_ADDR, b, a-b);
+
+	// copy .a_entry (ACPU bootcode)
+	a = (unsigned char *)&_e_a_entry_img;
+	b = (unsigned char *)&_f_a_entry_img;
+	md_memcpy((unsigned char *)MIPS_A_ENTRY_CODE_ADDR, b, a-b);
+#endif
+	// fill the ACPU jump address.
+	// After ACPU got HW semaphore in rom code, it will check this register.
+	rtd_outl(ACPU_JUMP_ADDR_reg,SWAPEND32( MIPS_A_ENTRY_CODE_ADDR | MIPS_KSEG1BASE));
+	rtd_outl(ISO_RESERVED_USE_3,MIPS_A_ENTRY_CODE_ADDR | MIPS_KSEG1BASE);
+	
+	set_shared_memory_for_communication_with_ACPU();
+	
+
+}
+#endif	/* CONFIG_BSP_REALTEK */
+//**************************************************************************	
+	
 
 #ifdef CONFIG_ARCH_EARLY_INIT_R
 	arch_early_init_r();
@@ -564,6 +717,11 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	}
 #endif
 
+#if defined(CONFIG_RTKSPI) && defined(CONFIG_CMD_RTKSPI)
+	extern void rtkspi_init(void);
+	rtkspi_init();		/* SPI initial */
+#endif
+
 #if defined(CONFIG_CMD_NAND)
 	puts("NAND:  ");
 	nand_init();		/* go init the NAND */
@@ -573,10 +731,54 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	onenand_init();
 #endif
 
-#ifdef CONFIG_GENERIC_MMC
+#ifdef CONFIG_RTK_MMC
 	puts("MMC:   ");
+#ifdef RTK_eMMC_FAST_MODE
+	EXECUTE_CUSTOMIZE_FUNC(0); // insert execute customer callback at here
+	printf("Initialize eMMC in fast flow\n");
+	if(rtk_eMMC_init() < 0) {
+		printf("[ERR] bringup mmc failed.\n");
+	}
+#else /* RTK_eMMC_TRADITIONAL_MODE */
+	printf("Initialize eMMC in traditional mmc flow.\n");
 	mmc_initialize(gd->bd);
+	EXECUTE_CUSTOMIZE_FUNC(0); // insert execute customer callback at here
+	if(bringup_mmc_driver() < 0) {
+		printf("[ERR] bringup mmc failed\n");
+	}
+#endif
+#endif
+
+#ifdef CONFIG_RTK_SD
+	puts("SD:\n");
+
+	EXECUTE_CUSTOMIZE_FUNC(0); // insert execute customer callback at here
+
+	sd_initialize(gd->bd);
+
+#ifdef CONFIG_SYS_RTK_SD_FLASH
+	extern int sd_card_init(void);
+	if( sd_card_init() != 0 ) {
+		puts("SD: initialize card failed\n");
+	}
+#endif /* CONFIG_SYS_RTK_SD_FLASH */
+#endif /* CONFIG_RTK_SD */
+	EXECUTE_CUSTOMIZE_FUNC(0); // insert execute customer callback at here
+
+//****************************************************************
+#ifdef CONFIG_BSP_REALTEK
+	pcb_get_boot_flash_type(); 
+#ifdef CONFIG_SYS_FACTORY
+	puts("Factory: ");
+	factory_init();
+	get_bootparam();
+#ifdef CONFIG_SYS_FACTORY_READ_ONLY
+	puts("Factory RO: ");
+	factory_ro_init();	
+#endif
 #endif
+#endif /* CONFIG_BSP_REALTEK */
+//****************************************************************
 
 #ifdef CONFIG_CMD_SCSI
 	puts("SCSI:  ");
@@ -618,6 +820,18 @@ void board_init_r(gd_t *id, ulong dest_addr)
 # endif
 #endif
 
+
+#ifdef CONFIG_HDMITX_MODE
+	if(CONFIG_HDMITX_MODE==0)//HDMI TX always off
+		set_hdmi_off();
+	else
+		sink_capability_handler(1);
+#endif
+#ifdef CONFIG_DPTX_MODE
+	if(CONFIG_DPTX_MODE==1)
+		dptx_sink_capability_handler(1);
+#endif
+
 #if defined(CONFIG_ARCH_MISC_INIT)
 	/* miscellaneous arch dependent initialisations */
 	arch_misc_init();
@@ -635,6 +849,26 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	/* Initialize from environment */
 	load_addr = getenv_ulong("loadaddr", 16, load_addr);
 
+#if defined(CONFIG_BOARD_WD_MONARCH)||defined(CONFIG_BOARD_WD_PELICAN)
+#if defined(CONFIG_RTD129X_PWM)
+    /**
+       @WD_Changes_begin
+       Enable the LED at 50% at the beginning of uboot
+     **/
+    rtd129x_pwm_init();
+    // enable the LED at the earlier boot
+    pwm_set_duty_rate(SYS_LED_PWM_PORT_NUM,50);
+    pwm_enable(SYS_LED_PWM_PORT_NUM,1);
+#ifdef CONFIG_BOARD_WD_PELICAN
+    // for pelican, turn on the FAN
+    //pwm_set_duty_rate(FAN_PWM_PORT_NUM, 100);  // set the FAN speed to 100%
+    pwm_set_duty_rate(FAN_PWM_PORT_NUM, 20);  // set the FAN speed to 100%
+    pwm_enable(FAN_PWM_PORT_NUM, 1);
+#endif /* CONFIG_BOARD_WD_PELICAN */
+#endif /* CONFIG_RTD129X_PWM */
+#endif /* CONFIG_BOARD_WD_MONARCH */ /* CONFIG_BOARD_WD_PELICAN */
+
+
 #ifdef CONFIG_BOARD_LATE_INIT
 	board_late_init();
 #endif
@@ -642,14 +876,24 @@ void board_init_r(gd_t *id, ulong dest_addr)
 #ifdef CONFIG_BITBANGMII
 	bb_miiphy_init();
 #endif
+
+
+#ifndef CONFIG_POWER_DOWN_ETN
 #if defined(CONFIG_CMD_NET)
 	puts("Net:   ");
-	eth_initialize();
+#ifdef CONFIG_BSP_REALTEK
+	rtl8168_initialize(gd->bd);
+#else
+	eth_initialize(gd->bd);
+#endif
 #if defined(CONFIG_RESET_PHY_R)
 	debug("Reset Ethernet PHY\n");
 	reset_phy();
 #endif
-#endif
+#endif //CONFIG_CMD_NET
+#endif //CONFIG_POWER_DOWN_ETN
+
+
 
 #ifdef CONFIG_POST
 	post_run(NULL, POST_RAM | post_bootmode_get(0));
diff --git a/arch/arm/lib/bootm.c b/arch/arm/lib/bootm.c
index ee56d7403e..12b83a5879 100644
--- a/arch/arm/lib/bootm.c
+++ b/arch/arm/lib/bootm.c
@@ -25,13 +25,33 @@
 #include <linux/compiler.h>
 #include <bootm.h>
 #include <vxworks.h>
+#include <asm/arch/fw_info.h>
+#include <stdlib.h>
 
 #ifdef CONFIG_ARMV7_NONSEC
 #include <asm/armv7.h>
 #endif
 
+#ifdef CONFIG_RTK_SLAVE_CPU_BOOT
+#include <asm/arch/cpu.h>
+#endif
+
+#include <asm/arch/cpu.h>
+#include <asm/io.h>
+
 DECLARE_GLOBAL_DATA_PTR;
 
+extern BOOT_MODE boot_mode;
+extern unsigned int Auto_AFW_MEM_START;
+
+#ifdef CONFIG_RTD1295
+#if defined(CONFIG_SYS_RTK_SPI_FLASH) || defined(CONFIG_SYS_RTK_SD_FLASH) || defined(CONFIG_SYS_NO_BL31)
+	static int spi_boot_flow = 1;
+#else
+	static int spi_boot_flow = 0;
+#endif
+#endif
+
 static struct tag *params;
 
 static ulong get_sp(void)
@@ -42,6 +62,11 @@ static ulong get_sp(void)
 	return ret;
 }
 
+#ifdef CONFIG_TARGET_RTD1295
+static void (*bl31_entrypoint) (void* para1, void* para2) = (void*)BL31_ENTRY_ADDR;
+#endif
+
+
 void arch_lmb_reserve(struct lmb *lmb)
 {
 	ulong sp;
@@ -71,8 +96,18 @@ void arch_lmb_reserve(struct lmb *lmb)
  */
 static void announce_and_cleanup(int fake)
 {
-	printf("\nStarting kernel ...%s\n\n", fake ?
-		"(fake run for tracing)" : "");
+#ifdef CONFIG_TARGET_RTD1295
+	if (get_rtd129x_cpu_revision() == RTD129x_CHIP_REVISION_A01 && !spi_boot_flow)
+		printf("Jump to BL31 entrypoint\n");
+	else{
+		printf("\nStarting %s ...%s\n\n", (getenv("hyp_loadaddr") ? "Hypervisor" : "Kernel"), (fake ?
+			"(fake run for tracing)" : ""));
+	}
+#else // !CONFIG_TARGET_RTD1295
+	printf("\nStarting %s ...%s\n\n", (getenv("hyp_loadaddr") ? "Hypervisor" : "Kernel"), (fake ?
+		"(fake run for tracing)" : ""));
+#endif //CONFIG_TARGET_RTD1295
+
 	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_HANDOFF, "start_kernel");
 #ifdef CONFIG_BOOTSTAGE_FDT
 	bootstage_fdt_add_report();
@@ -191,15 +226,95 @@ __weak void setup_board_tags(struct tag **in_params) {}
 #ifdef CONFIG_ARM64
 static void do_nonsec_virt_switch(void)
 {
+#ifdef CONFIG_ARMV8_MULTIENTRY
 	smp_kick_all_cpus();
+#endif
 	dcache_disable();	/* flush cache before swtiching to EL2 */
-	armv8_switch_to_el2();
+#ifdef CONFIG_TARGET_RTD1295
+	if (get_rtd129x_cpu_revision() < RTD129x_CHIP_REVISION_A01 || spi_boot_flow)
+#endif //CONFIG_TARGET_RTD1295
+		armv8_switch_to_el2();
+
 #ifdef CONFIG_ARMV8_SWITCH_TO_EL1
 	armv8_switch_to_el1();
 #endif
 }
 #endif
 
+#ifdef CONFIG_SYS_RTK_NAND_FLASH
+/**********************************************************
+ * Append the information of partition to bootargs.
+ **********************************************************/
+extern char rtknand_info[128];
+int rtk_plat_boot_prep_partition(void)
+{
+	if(boot_mode == BOOT_RESCUE_MODE)
+		return 0;
+
+#if defined(CONFIG_RTD1295) && defined(NAS_ENABLE)
+	char *nasargs= NULL;
+	char *tmp_cmdline = NULL;
+	char *mtd_part = NULL;
+
+	nasargs= getenv("nasargs")?:"";
+	mtd_part = getenv("mtd_part")?:"";
+
+	tmp_cmdline = (char *)malloc(strlen(nasargs)+strlen(mtd_part)+strlen(rtknand_info)+3);
+	if (!tmp_cmdline) {
+		printf("%s: Malloc failed\n", __func__);
+	}
+	else {
+		sprintf(tmp_cmdline, "%s %s %s", nasargs, mtd_part, rtknand_info);
+		setenv("nasargs", tmp_cmdline);
+		free(tmp_cmdline);
+	}
+	debug("%s\n",getenv("nasargs"));
+#endif
+
+	return 0;
+}
+#endif
+
+#if (defined(CONFIG_RTD1295) || defined(CONFIG_RTD1395)) && defined(NAS_ENABLE)
+extern uint initrd_size;
+/**********************************************************
+ * Append NAS partitions to bootargs.
+ **********************************************************/
+int rtk_plat_boot_prep_nas_partition(void)
+{
+	char *commandline = getenv("nasargs");
+	char *nas_part = getenv("nas_part");
+	char *tmp_cmdline = NULL;
+	char initrd[32];
+
+	if(boot_mode == BOOT_RESCUE_MODE && initrd_size != 0)
+	{
+		sprintf(initrd, "initrd=%s,0x%08x", getenv("rescue_rootfs_loadaddr"), initrd_size);
+		nas_part = initrd;
+	}
+
+	if (!nas_part)
+	    return 0;
+
+    // Need 2 extra bytes for space and null charactor.
+	tmp_cmdline = (char *)malloc(strlen(commandline) + strlen(nas_part) + 2);
+	if (!tmp_cmdline) {
+		printf("%s: Malloc failed\n", __func__);
+	}
+	else {
+		if(commandline)
+		sprintf(tmp_cmdline, "%s %s", commandline, nas_part);
+		else
+		sprintf(tmp_cmdline, "%s", nas_part);
+		setenv("nasargs", tmp_cmdline);
+		free(tmp_cmdline);
+	}
+	debug("%s\n",getenv("nasargs"));
+
+	return 0;
+}
+#endif
+
 /* Subcommand: PREP */
 static void boot_prep_linux(bootm_headers_t *images)
 {
@@ -261,6 +376,14 @@ bool armv7_boot_nonsec(void)
 /* Subcommand: GO */
 static void boot_jump_linux(bootm_headers_t *images, int flag)
 {
+#ifdef CONFIG_RTK_SLAVE_CPU_BOOT
+	bootup_slave_cpu();
+#endif
+
+	if(!Auto_AFW_MEM_START)
+		Auto_AFW_MEM_START = AFW_MEM_START_ADDR;
+	 /* If AFW load failed, using default address of AFW. */
+
 #ifdef CONFIG_ARM64
 	void (*kernel_entry)(void *fdt_addr, void *res0, void *res1,
 			void *res2);
@@ -276,8 +399,31 @@ static void boot_jump_linux(bootm_headers_t *images, int flag)
 	announce_and_cleanup(fake);
 
 	if (!fake) {
+		int err;
 		do_nonsec_virt_switch();
+		err = fdt_add_mem_rsv(images->ft_addr, getenv_ulong("blue_logo_loadaddr", 16, BOOT_LOGO_ADDR), BOOT_LOGO_SIZE);
+		if (err < 0)
+			printf("## WARNING %s Add BOOT_LOGO_ADDR: %s\n", __func__, fdt_strerror(err));
+		err = fdt_add_mem_rsv(images->ft_addr, Auto_AFW_MEM_START, AFW_MEM_SIZE);
+		if (err < 0)
+			printf("## WARNING %s Add AFW_MEMRSV: %s\n", __func__, fdt_strerror(err));
+		err = fdt_add_mem_rsv(images->ft_addr, UBOOT_MEM_START_ADDR, UBOOT_MEM_SIZE);
+		if (err < 0)
+			printf("## WARNING %s Add UBOOT_MEMRSV: %s\n", __func__, fdt_strerror(err));
+		err = fdt_add_mem_rsv(images->ft_addr, TEE_MEM_START_ADDR, TEE_MEM_SIZE);
+		if (err < 0)
+			printf("## WARNING %s Add TEE_MEMRSV: %s\n", __func__, fdt_strerror(err));
+#ifdef CONFIG_TARGET_RTD1295
+		//Just A01 need to go this flow, because A00 dosen't have the security and 
+		//the security of B00 is done before EL2 which not need bl31 again. 
+		if (get_rtd129x_cpu_revision() == RTD129x_CHIP_REVISION_A01 && !spi_boot_flow) {
+			bl31_entrypoint(kernel_entry, images->ft_addr);
+		} else {
+			kernel_entry(images->ft_addr, NULL, NULL, NULL);
+		}
+#else // !CONFIG_TARGET_RTD1295
 		kernel_entry(images->ft_addr, NULL, NULL, NULL);
+#endif // CONFIG_TARGET_RTD1295
 	}
 #else
 	unsigned long machid = gd->bd->bi_arch_number;
diff --git a/arch/arm/lib/cache.c b/arch/arm/lib/cache.c
index 74cfde637c..59c06ee020 100644
--- a/arch/arm/lib/cache.c
+++ b/arch/arm/lib/cache.c
@@ -9,6 +9,7 @@
 
 #include <common.h>
 #include <malloc.h>
+#include <asm/armv8/mmu.h>
 
 __weak void flush_cache(unsigned long start, unsigned long size)
 {
@@ -62,6 +63,25 @@ static unsigned long noncached_start;
 static unsigned long noncached_end;
 static unsigned long noncached_next;
 
+#ifdef CONFIG_BSP_REALTEK
+void noncached_init(void)
+{
+	phys_addr_t start, end;
+	size_t size;
+
+	start = CONFIG_SYS_NONCACHED_START;
+	size = CONFIG_SYS_NONCACHED_SIZE;
+	end = start + size;
+
+	printf("mapping memory 0x%08lx-0x%08lx non-cached\n", start, end);
+
+	noncached_start = start;
+	noncached_end = end;
+	noncached_next = start;
+
+	mmu_set_region(start, size, MT_DEVICE_NGNRNE);
+}
+#else
 void noncached_init(void)
 {
 	phys_addr_t start, end;
@@ -81,6 +101,7 @@ void noncached_init(void)
 	mmu_set_region_dcache_behaviour(noncached_start, size, DCACHE_OFF);
 #endif
 }
+#endif //CONFIG_BSP_REALTEK
 
 phys_addr_t noncached_alloc(size_t size, size_t align)
 {
diff --git a/arch/arm/lib/gic_64.S b/arch/arm/lib/gic_64.S
index a3e18f7713..7f59e74c4f 100644
--- a/arch/arm/lib/gic_64.S
+++ b/arch/arm/lib/gic_64.S
@@ -46,8 +46,9 @@ ENTRY(gic_init_secure)
 	ldr	w9, [x0, GICD_TYPER]
 	and	w10, w9, #0x1f		/* ITLinesNumber */
 	cbz	w10, 1f			/* No SPIs */
-	add	x11, x0, (GICD_IGROUPRn + 4)
-	mov	w9, #~0			/* Config SPIs as Grp1 */
+	add	w10, w10, #0x1		/* Also add SGI/PPI to the counter */
+	add	x11, x0, (GICD_IGROUPRn)
+	mov	w9, #~0			/* Config SGI/PPI/SPIs as Grp1 */
 0:	str	w9, [x11], #0x4
 	sub	w10, w10, #0x1
 	cbnz	w10, 0b
@@ -143,7 +144,7 @@ ENTRY(gic_init_secure_percpu)
 					/* EnableGrp0 & EnableGrp1 */
 	str	w9, [x1, GICC_CTLR]	/* Secure GICC_CTLR */
 
-	mov	w9, #0x1 << 7		/* Non-Secure access to GICC_PMR */
+	mov	w9, #0xf8		/* Non-Secure access to GICC_PMR */
 	str	w9, [x1, GICC_PMR]
 #endif
 	ret
@@ -188,3 +189,164 @@ ENTRY(gic_wait_for_interrupt)
 #endif
 	ret
 ENDPROC(gic_wait_for_interrupt)
+
+
+#ifdef CONFIG_GICV3_REALTEK
+/*************************************************************************
+ * For Gicv3:
+ * void rtk_arm_gic_init_percpu_v3(void);
+ *
+ *************************************************************************/
+ENTRY(rtk_arm_gic_init_percpu_v3)
+
+	/*
+	 * Initialize Distributor
+	 * x0: Distributor Base
+	 */
+	 
+	/* Disable GICD_CTLR */
+	mov	w1, #0x0
+	str	w1, [x0]
+
+	/* Set ID0 to non scure (group1) GICD_IGROUPRn  0x084~0x08C */
+	ldr	w1, =0xFFFFFFFF
+	str	w1, [x0, 0x084]
+	str	w1, [x0, 0x088]
+	str	w1, [x0, 0x08C]
+
+	/* Enable ICDD_CTLR */
+	mov	w1, #0x37
+	str	w1, [x0]
+
+	/* Enable redistributor power on */
+	ldr	x0, =GICR_RD_BASE
+	mov	w1, #0x00
+	str	w1, [x0, 0x24]
+	
+	/* Wait until the power on state is reflected */
+1:	
+	ldr w1, [x0, 0x24]
+	mov x4, #0x8
+	
+	and x1, x1, x4
+	cmp x1, #0x0
+	bne 1b
+
+	/* Wake up redistributor: kick ProcessorSleep and wait for ChildrenAsleep to be 0 */
+	ldr	w1, [x0, 0x14]
+	mov w2, #0xFFFFFFFD
+	and	x1, x1, x2
+	str	w1, [x0, 0x14]
+	dsb	st
+	isb
+
+	/* Read the GICR_WAKER */
+2:
+	ldr	w1, [x0, 0x14]
+	mov	x4, #0x4
+
+	/* Read the ChildrenAsleep, bit [2] */
+	and	x1, x1, x4
+	cmp	x1, #0x0
+	bne	2b
+
+	/* Setup redistributor SGI base GICR_IGROUP0 */
+	ldr	x0, =GICR_SGI_BASE
+	mov w1, #0xFFFFFFFF
+	str	w1, [x0, 0x80]
+
+	/* Setup redistributor SGI base GICR_IGRPMOD0 */
+	mov w1, #0x0
+	str	w1, [x0, 0xD00]
+
+	/* Setup distributor GICR_IGROUP0 */
+	ldr	x0, =GICD_BASE
+	mov w1, #0xFFFFFFFF
+	str	w1, [x0, 0x84]
+
+	/* Setup distributor GICR_IGROUP0 */
+	mov w1, #0x0
+	str	w1, [x0, 0xD04]
+
+	/* Setup CPU system register ICC_SRE_EL3*/
+	mrs	x1, S3_6_C12_C12_5
+	mov	x2, #0x9 /* SRE bit0, Enable bit 3 */
+	orr x1,x1,x2
+	msr	S3_6_C12_C12_5, x1
+	isb
+
+	/* Setup CPU system register ICC_CTLR_EL3 */
+	mov	x2, #0x0
+	msr	S3_6_C12_C12_4, x2
+	isb
+
+	ret
+ENDPROC(rtk_arm_gic_init_percpu_v3)
+
+/*************************************************************************
+ * For Gicv3:
+ * void rtk_arm_gic_init_slavecpu_v3(unsigned int GICR_RD_BASE_COREn, unsigned int GICR_SGI_BASE_COREn);
+ *
+ *************************************************************************/
+ENTRY(rtk_arm_gic_init_slavecpu_v3)
+	/* x0 Redistributor base, x1 Redistributor sgi base*/
+	mov x8, x0
+	mov x9, x1
+	
+	/* Enable redistributor power on */	
+	mov	x0, x8 //Set up Redistributor base
+	mov	w1, #0x00
+	str	w1, [x0, 0x24]
+	
+	/* Wait until the power on state is reflected */
+1:	
+	ldr w1, [x0, 0x24]
+	mov x4, #0x8
+	
+	and x1, x1, x4
+	cmp x1, #0x0
+	bne 1b
+
+	/* Wake up redistributor: kick ProcessorSleep and wait for ChildrenAsleep to be 0 */
+	ldr	w1, [x0, 0x14]
+	mov w2, #0xFFFFFFFD
+	and	x1, x1, x2
+	str	w1, [x0, 0x14]
+	dsb	st
+	isb
+
+	/* Read the GICR_WAKER */
+2:
+	ldr	w1, [x0, 0x14]
+	mov	x4, #0x4
+
+	/* Read the ChildrenAsleep, bit [2] */
+	and	x1, x1, x4
+	cmp	x1, #0x0
+	bne	2b
+
+	/* Setup redistributor SGI base GICR_IGROUP1 */
+	mov	x0, x9  //Set up Redistributor SGI base
+	mov w1, #0xFFFFFFFF
+	str	w1, [x0, 0x80]
+
+	/* Setup redistributor SGI base GICR_IGRPMOD1 */
+	mov w1, #0x0
+	str	w1, [x0, 0xD00]
+
+	/* Setup CPU system register ICC_SRE_EL3*/
+	mrs	x1, S3_6_C12_C12_5
+	mov	x2, #0x9 /* SRE bit0, Enable bit 3 */
+	orr x1,x1,x2
+	msr	S3_6_C12_C12_5, x1
+	isb
+
+	/* Setup CPU system register ICC_CTLR_EL3 */
+	mov	x2, #0x0
+	msr	S3_6_C12_C12_4, x2
+	isb
+
+	ret
+ENDPROC(rtk_arm_gic_init_slavecpu_v3)
+
+#endif
\ No newline at end of file
diff --git a/arch/arm/lib/interrupts_64.c b/arch/arm/lib/interrupts_64.c
index b476722556..1b5626eba3 100644
--- a/arch/arm/lib/interrupts_64.c
+++ b/arch/arm/lib/interrupts_64.c
@@ -8,6 +8,10 @@
 #include <common.h>
 #include <linux/compiler.h>
 
+#ifdef CONFIG_CMD_GICTEST
+#include <asm/arch/interrupt.h>
+#endif
+
 
 int interrupt_init(void)
 {
@@ -91,8 +95,19 @@ void do_sync(struct pt_regs *pt_regs, unsigned int esr)
  */
 void do_irq(struct pt_regs *pt_regs, unsigned int esr)
 {
+#ifdef CONFIG_CMD_GICTEST
+	unsigned int irqnr = 0;
+	do {
+		irqnr = gic_get_irq();
+		//printf("IRQ #%u received on CPU:%u\n", irqnr, get_cpu_id());
+		printf("IRQ #%u received\n", irqnr);
+		if (irqnr > 1021)
+			break;
+	} while (1);
+#else
 	printf("\"Irq\" handler, esr 0x%08x\n", esr);
 	show_regs(pt_regs);
+#endif
 	panic("Resetting CPU ...\n");
 }
 
diff --git a/arch/arm/lib/reset.c b/arch/arm/lib/reset.c
index 9a95f08504..67381387bf 100644
--- a/arch/arm/lib/reset.c
+++ b/arch/arm/lib/reset.c
@@ -22,6 +22,8 @@
  */
 
 #include <common.h>
+#include <asm/arch/rbus/iso_reg.h>
+#include <asm/arch/io.h>
 
 __weak void reset_misc(void)
 {
@@ -34,9 +36,20 @@ int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	udelay (50000);				/* wait 50 ms */
 
 	disable_interrupts();
+	
+#if defined(CONFIG_RTD1195) || defined(CONFIG_RTD1295) || defined(CONFIG_RTD1395)
+
+	// trigger watchdog reset
+	rtd_outl(ISO_TCWCR_reg,0xa5);
+	rtd_outl(ISO_TCWTR_reg,0x1);
+	rtd_outl(ISO_TCWOV_reg,1);
+	rtd_outl(ISO_TCWCR_reg,0);
+
+#else
 
 	reset_misc();
 	reset_cpu(0);
+#endif
 
 	/*NOTREACHED*/
 	return 0;
diff --git a/common/Kconfig b/common/Kconfig
index 40cd69ed70..7b625fbec4 100644
--- a/common/Kconfig
+++ b/common/Kconfig
@@ -141,6 +141,18 @@ config CMD_BOOTM
 	help
 	  Boot an application image from the memory.
 
+menu "ARM64 Kernel Image header selection"
+	depends on ARM64 && CMD_BOOTM
+
+config ARM64_IMAGE_LEGACY
+	bool "kernel image header legacy"
+	default n
+	help
+	  ARM64 kernel image header had changed at 3.12 -> 3.13.
+	  Select this option if using kernel version less-equal to 3.12.
+
+endmenu
+
 config CMD_GO
 	bool "go"
 	default y
@@ -171,6 +183,12 @@ config CMD_XIMG
 	help
 	  Extract a part of a multi-image.
 
+config CMD_BOOTR
+	bool "bootr"
+	depends on TARGET_RTD1295 || TARGET_RTD1395
+	default y
+	help
+	  RealTek boot-up sequence.
 endmenu
 
 menu "Environment commands"
@@ -331,12 +349,34 @@ config CMD_USB
 	help
 	  USB support.
 
+config CMD_FASTBOOT
+	bool "fastboot"
+	select USB_FUNCTION_FASTBOOT
+	help
+	  Enables the command "fastboot".
+
+config CMD_RTKBT_INIT
+	bool "rtkbt_init"
+	help
+	  RTK bluetooth support
+
 config CMD_FPGA
 	bool "fpga"
 	default y
 	help
 	  FPGA support.
 
+config CMD_GICTEST
+	depends on TARGET_RTD1295 || TARGET_RTD1395
+	bool "gic test"
+	help
+	  GIC test support.
+
+config CMD_CACHETEST
+	depends on !SYS_DCACHE_OFF
+	bool "cache test"
+	help
+	  Cache stress test support.
 endmenu
 
 
@@ -454,6 +494,11 @@ config CMD_TIMER
 	help
 	  Access the system timer.
 
+config CMD_GETTIME
+	bool "get system timer"
+	help
+	  Return time elapesed since timer initial.
+
 config CMD_SETGETDCR
 	bool "getdcr, setdcr, getidcr, setidcr"
 	depends on 4xx
@@ -474,6 +519,11 @@ config CMD_SOUND
 	     sound init   - set up sound system
 	     sound play   - play a sound
 
+config CMD_DATE
+	bool "RTC date"
+	help
+	  System RTC date command.
+
 endmenu
 
 menu "Boot timing"
@@ -618,4 +668,72 @@ config CMD_REGULATOR
 
 endmenu
 
+config CMD_RTK_PMIC
+	bool "pmic command"
+
+config GMT_G2227
+	bool "pmic command with GMT-G2227"
+	select CMD_RTK_PMIC
+
+config BOOT_DCDC1_FORCE_PWM
+	bool "Set GMT-G2227 DCDC1 to 'force pwm' before boot kernel"
+	depends on GMT_G2227
+
+config BOOT_DCDC2_FORCE_PWM
+	bool "Set GMT-G2227 DCDC2 to 'force pwm' before boot kernel"
+	depends on GMT_G2227
+
+config BOOT_DCDC3_FORCE_PWM
+	bool "Set GMT-G2227 DCDC3 to 'force pwm' before boot kernel"
+	depends on GMT_G2227
+
+config BOOT_DCDC4_FORCE_PWM
+	bool "Set GMT-G2227 DCDC4 to 'force pwm' before boot kernel"
+	depends on GMT_G2227
+
+config BOOT_DCDC5_FORCE_PWM
+	bool "Set GMT-G2227 DCDC5 to 'force pwm' before boot kernel"
+	depends on GMT_G2227
+
+config BOOT_DCDC6_FORCE_PWM
+	bool "Set GMT-G2227 DCDC6 to 'force pwm' before boot kernel"
+	depends on GMT_G2227
+
+config GMT_G2237
+	bool "pmic command with GMT-G2237"
+	select CMD_RTK_PMIC
+
+endmenu
+
+menu "Customize Features"
+
+config CUSTOMIZE_FEATURES
+	bool "Enable Customized Fetures"
+	default 0
+	help
+	  This config switch on/off customized features.
+
+config CUSTOMIZE_BOOTFLOW_1
+	bool "Customize Boot-Flow #1"
+	default 0
+	depends on CUSTOMIZE_FEATURES
+	select RTC_RTD1295
+	select RTK_POWER
+	select POWER_DOWN_S5
+	select CMD_DATE
+	help
+	  This boot-flow will enable power-up-S5 flow.
+
+config CUSTOMIZE_BOOTFLOW_1_PHASE_1
+	bool "Customize Boot-Flow #1 - Phase 1"
+	default 0
+	depends on CUSTOMIZE_BOOTFLOW_1
+
+config CUSTOMIZE_ACCELERATE_BOOT_BLUE_LOGO
+	bool "Load logo and acpu image in the early"
+	default y
+	help
+	  Load logo and acpu image in the early in order to
+	  reduce the flash of blue screen in booting stage.
+
 endmenu
diff --git a/common/Makefile b/common/Makefile
index d6c1d4844d..43259c5398 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -32,14 +32,19 @@ obj-$(CONFIG_DISPLAY_BOARDINFO_LATE) += board_info.o
 
 # core command
 obj-y += cmd_boot.o
+# cmd_boot_md.c was colned from cmd_boot.c
+obj-$(CONFIG_BOOT_FOR_WD) += cmd_boot_wd.o
+obj-$(CONFIG_CMD_WDPP) += cmd_wdpp.o
 obj-$(CONFIG_CMD_BOOTM) += cmd_bootm.o bootm.o bootm_os.o
 obj-y += cmd_help.o
 obj-y += cmd_version.o
+obj-$(CONFIG_CMD_BOOTR) += cmd_bootr.o rtk/boot.o
 
 # environment
 obj-y += env_attr.o
 obj-y += env_callback.o
 obj-y += env_flags.o
+obj-$(CONFIG_ENV_IS_IN_FACTORY) += env_factory.o
 obj-$(CONFIG_ENV_IS_IN_DATAFLASH) += env_dataflash.o
 obj-$(CONFIG_ENV_IS_IN_EEPROM) += env_eeprom.o
 extra-$(CONFIG_ENV_IS_EMBEDDED) += env_embedded.o
@@ -53,7 +58,8 @@ obj-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o
 obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_nvram.o
 obj-$(CONFIG_ENV_IS_IN_ONENAND) += env_onenand.o
 obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
-obj-$(CONFIG_ENV_IS_IN_REMOTE) += env_remote.o
+obj-$(CONFIG_ENV_IS_IN_SPI) += env_spi.o
+#obj-$(CONFIG_ENV_IS_IN_REMOTE) += env_remote.o
 obj-$(CONFIG_ENV_IS_IN_UBI) += env_ubi.o
 obj-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o
 
@@ -63,7 +69,12 @@ obj-$(CONFIG_CMD_AMBAPP) += cmd_ambapp.o
 obj-$(CONFIG_CMD_ARMFLASH) += cmd_armflash.o
 obj-$(CONFIG_SOURCE) += cmd_source.o
 obj-$(CONFIG_CMD_SOURCE) += cmd_source.o
+ifdef CONFIG_RTD1395
+obj-$(CONFIG_CMD_BDI) += cmd_bdinfo_rtd1395.o
+endif
+ifdef CONFIG_RTD1295
 obj-$(CONFIG_CMD_BDI) += cmd_bdinfo.o
+endif
 obj-$(CONFIG_CMD_BEDBUG) += bedbug.o cmd_bedbug.o
 obj-$(CONFIG_CMD_BMP) += cmd_bmp.o
 obj-$(CONFIG_CMD_BOOTMENU) += cmd_bootmenu.o
@@ -137,6 +148,7 @@ endif
 obj-$(CONFIG_CMD_MISC) += cmd_misc.o
 obj-$(CONFIG_CMD_MMC) += cmd_mmc.o
 obj-$(CONFIG_CMD_MMC_SPI) += cmd_mmc_spi.o
+obj-$(CONFIG_CMD_SD) += cmd_sd.o
 obj-$(CONFIG_MP) += cmd_mp.o
 obj-$(CONFIG_CMD_MTDPARTS) += cmd_mtdparts.o
 obj-$(CONFIG_CMD_NAND) += cmd_nand.o
@@ -191,6 +203,8 @@ obj-$(CONFIG_YAFFS2) += cmd_yaffs2.o
 obj-$(CONFIG_CMD_SPL) += cmd_spl.o
 obj-$(CONFIG_CMD_ZIP) += cmd_zip.o
 obj-$(CONFIG_CMD_ZFS) += cmd_zfs.o
+obj-$(CONFIG_CMD_GICTEST) += cmd_gictest.o
+obj-$(CONFIG_CMD_CACHETEST) += cmd_cachetest.o
 
 # others
 obj-$(CONFIG_BOOTSTAGE) += bootstage.o
@@ -283,4 +297,29 @@ obj-y += s_record.o
 obj-y += xyzModem.o
 obj-y += cmd_disk.o
 
+obj-$(CONFIG_CUSTOMIZE_BOOTFLOW_1) += customized_bootflow.o
+
 CFLAGS_env_embedded.o := -Wa,--no-warn -DENV_CRC=$(shell tools/envcrc 2>/dev/null)
+
+obj-$(CONFIG_CMD_RTKSPI) += cmd_rtkspi.o
+obj-$(CONFIG_CMD_RTKRNG) += cmd_rtkrng.o
+obj-$(CONFIG_CMD_RTKGPT) += cmd_rtkgpt.o
+obj-$(CONFIG_CMD_RTKMKFAT) += cmd_rtkmkfat.o
+obj-$(CONFIG_CMD_RTKFDT) += cmd_rtkfdt.o
+obj-$(CONFIG_CMD_RTKPWM) += cmd_rtkpwm.o
+obj-$(CONFIG_CMD_KEY_BURNING) += cmd_burn.o cmd_verify.o
+obj-y += cmd_uart_read_write.o
+
+# realtek cmd pmic
+obj-y += pmic/
+
+# uart mp tool
+obj-y += cmd_uart_write.o
+
+#for rpmb module
+obj-$(CONFIG_CMD_RPMB) += cmd_rpmb.o
+
+# rtk bt init
+ifdef CONFIG_CMD_RTKBT_INIT
+obj-y += rtk_bt_init/
+endif
diff --git a/common/bootm.c b/common/bootm.c
index 667c93471b..d65c910199 100644
--- a/common/bootm.c
+++ b/common/bootm.c
@@ -32,7 +32,7 @@
 
 #ifndef CONFIG_SYS_BOOTM_LEN
 /* use 8MByte as default max gunzip size */
-#define CONFIG_SYS_BOOTM_LEN	0x800000
+#define CONFIG_SYS_BOOTM_LEN	0x8000000
 #endif
 
 #define IH_INITRD_ARCH IH_ARCH_DEFAULT
@@ -818,8 +818,9 @@ static const void *boot_get_kernel(cmd_tbl_t *cmdtp, int flag, int argc,
 			*os_len = image_get_data_size(hdr);
 			break;
 		default:
-			printf("Wrong Image Type for %s command\n",
-			       cmdtp->name);
+			printf("Wrong Image Type for do_booti command\n");
+			/*printf("Wrong Image Type for %s command\n",
+			       cmdtp->name); */
 			bootstage_error(BOOTSTAGE_ID_CHECK_IMAGETYPE);
 			return NULL;
 		}
@@ -863,7 +864,8 @@ static const void *boot_get_kernel(cmd_tbl_t *cmdtp, int flag, int argc,
 		break;
 #endif
 	default:
-		printf("Wrong Image Format for %s command\n", cmdtp->name);
+		printf("Wrong Image Format for do_booti command\n");
+		/*printf("Wrong Image Format for %s command\n", cmdtp->name);*/
 		bootstage_error(BOOTSTAGE_ID_FIT_KERNEL_INFO);
 		return NULL;
 	}
diff --git a/common/cli.c b/common/cli.c
index 075ae9dc4a..bb5241cb1d 100644
--- a/common/cli.c
+++ b/common/cli.c
@@ -24,6 +24,7 @@ DECLARE_GLOBAL_DATA_PTR;
  * @param flag	Execution flags (CMD_FLAG_...)
  * @return 0 on success, or != 0 on error.
  */
+#if 0 
 int run_command(const char *cmd, int flag)
 {
 #ifndef CONFIG_SYS_HUSH_PARSER
@@ -43,6 +44,7 @@ int run_command(const char *cmd, int flag)
 	return parse_string_outer(cmd, hush_flags);
 #endif
 }
+#endif
 
 /*
  * Run a command using the selected parser, and check if it is repeatable.
@@ -68,6 +70,7 @@ int run_command_repeatable(const char *cmd, int flag)
 #endif
 }
 
+#if 0
 int run_command_list(const char *cmd, int len, int flag)
 {
 	int need_buff = 1;
@@ -108,9 +111,11 @@ int run_command_list(const char *cmd, int len, int flag)
 
 	return rcode;
 }
+#endif
 
 /****************************************************************************/
 
+#if 0
 #if defined(CONFIG_CMD_RUN)
 int do_run(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
@@ -134,6 +139,7 @@ int do_run(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	return 0;
 }
 #endif
+#endif
 
 #ifdef CONFIG_OF_CONTROL
 bool cli_process_fdt(const char **cmdp)
diff --git a/common/cli_hush.c b/common/cli_hush.c
index 296542f4c2..cacc23fcc9 100644
--- a/common/cli_hush.c
+++ b/common/cli_hush.c
@@ -973,6 +973,16 @@ static inline void setup_prompt_string(int promptmode, char **prompt_str)
 }
 #endif
 
+
+/*
+ **********************************************************
+ * Realtek Patch:
+ *     Prevent occuring dirty characters after executed some commands.
+ **********************************************************
+ */
+#ifdef CONFIG_BSP_REALTEK
+char the_command_buf[CONFIG_SYS_CBSIZE];
+#endif
 static void get_user_input(struct in_str *i)
 {
 #ifndef __U_BOOT__
@@ -998,9 +1008,28 @@ static void get_user_input(struct in_str *i)
 	i->p = the_command;
 #else
 	int n;
-	static char the_command[CONFIG_SYS_CBSIZE + 1];
 
-	bootretry_reset_cmd_timeout();
+/*
+ **********************************************************
+ * Realtek Patch:
+ *     Ignore the last command feature.
+ *     This feature is that if you press 'Enter' without any input,
+ *         U-boot will execute the last command that saved in "the_command".
+ **********************************************************
+ */
+#ifdef CONFIG_BSP_REALTEK
+	char *the_command = (char *)the_command_buf;
+	memset(the_command, 0, CONFIG_SYS_CBSIZE);
+#else
+	static char the_command[CONFIG_SYS_CBSIZE];
+#endif
+
+#ifdef CONFIG_BOOT_RETRY_TIME
+#  ifndef CONFIG_RESET_TO_RETRY
+#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
+#  endif
+	reset_cmd_timeout();
+#endif
 	i->__promptme = 1;
 	if (i->promptmode == 1) {
 		n = cli_readline(CONFIG_SYS_PROMPT);
diff --git a/common/cmd_bdinfo.c b/common/cmd_bdinfo.c
index ed3b9351b1..d76b28d15a 100644
--- a/common/cmd_bdinfo.c
+++ b/common/cmd_bdinfo.c
@@ -11,6 +11,9 @@
 #include <common.h>
 #include <command.h>
 #include <linux/compiler.h>
+#include <asm/arch/rbus/crt_reg.h>
+#include <asm/arch/io.h>
+#include <asm/arch/ddr.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -362,12 +365,340 @@ int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 #elif defined(CONFIG_ARM)
 
-static int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc,
-			char * const argv[])
+#define DC_SYS_MISC_reg				0xB8008004
+#define DC2_SYS_MISC_reg			0xB8003004
+#define DC_SECURE_MISC_reg				0x18008740
+
+static int ddr_mhz = 0;
+
+static int do_bdinfo_dss(void)
+{
+	//uint regValue = 0;
+
+	printf("*** bdinfo dss ***\n");
+#ifdef CONFIG_RTD299X //(wilma+ 2013/06/29)
+	//DSS1 dc_phy 0xb8008f50
+	rtd_outl(SS_12T_LVT_0_reg, 0x00000000); //DSS1 reset
+	rtd_outl(SS_12T_LVT_0_reg, 0x00000012); //wire_sel=1'b1, ro_sel=3'b001
+	rtd_outl(SS_12T_LVT_0_reg, 0x00000013); //DSS1 enable
+	mdelay(500);		// wait done
+	regValue = rtd_inl(SS_12T_LVT_1_reg); //count_out[23:4]
+	printf("DSS1 DC_PHY   = 0x%05x\n", ((regValue & SS_12T_LVT_1_count_out_mask) >> SS_12T_LVT_1_count_out_shift));
+
+	//DSS2 dc2_phy 0xb8003f50
+	rtd_outl(0xb8003f50,0x00000000); //DSS2 reset
+	rtd_outl(0xb8003f50,0x00000012); //wire_sel=1'b1, ro_sel=3'b001
+	rtd_outl(0xb8003f50,0x00000013); //DSS2 enable
+	mdelay(500);		// wait done
+	regValue = rtd_inl(0xb8003f54); //count_out[23:4]
+	printf("DSS2 DC2_PHY  = 0x%05x\n", ((regValue & 0x00FFFFF0) >> 4));
+
+	//DSS3 SCPU_phy 0xb805_c008
+	rtd_outl(0xb805c008,0x00000000); //DSS3 reset
+	rtd_outl(0xb805c008,0x00000012); //wire_sel=1'b1, ro_sel=3'b001
+	rtd_outl(0xb805c008,0x00000013); //DSS3 enable
+	mdelay(500);		// wait done
+	regValue = rtd_inl(0xb805c010); //count_out[23:4]
+	printf("DSS3 SCPU_PHY = 0x%05x\n", ((regValue & 0x00FFFFF0) >> 4));
+
+	//DSS4 SCPU_phy 0xb805_c000
+	rtd_outl(0xb805c000,0x00000000); //DSS4 reset
+	rtd_outl(0xb805c000,0x00000012); //wire_sel=1'b1, ro_sel=3'b001
+	rtd_outl(0xb805c000,0x00000013); //DSS4 enable
+	mdelay(500);		// wait done
+	regValue = rtd_inl(0xb805c004); //count_out[23:4]
+	printf("DSS4 SCPU_PHY = 0x%05x\n", ((regValue & 0x00FFFFF0) >> 4));
+
+	//DSS5 VCPU 0xb800_0298
+	rtd_outl(SS_12T_RVT_0_reg,0x00000000); //DSS5 reset
+	rtd_outl(SS_12T_RVT_0_reg,0x03000000); //wire_sel=1'b1, ro_sel=3'b001
+	rtd_outl(SS_12T_RVT_0_reg,0x83000000); //DSS5 enable
+	mdelay(500);		// wait done
+	regValue = rtd_inl(SS_12T_RVT_0_reg); //count_out[19:0]
+	printf("DSS5 VCPU     = 0x%05x\n", ((regValue & SS_12T_RVT_0_rvt_12t_count_out_mask) >> SS_12T_RVT_0_rvt_12t_count_out_shift));
+
+	//DSS6 VCPU2 0xb800_0340
+	rtd_outl(SS_9T_LVT_0_reg,0x00000000); //DSS6 reset
+	rtd_outl(SS_9T_LVT_0_reg,0x03000000); //wire_sel=1'b1, ro_sel=3'b001
+	rtd_outl(SS_9T_LVT_0_reg,0x83000000); //DSS6 enable
+	mdelay(500);		// wait done
+	regValue = rtd_inl(SS_9T_LVT_0_reg); //count_out[19:0]
+	printf("DSS6 VCPU2    = 0x%05x\n", ((regValue & SS_9T_LVT_0_lvt_9t_count_out_mask) >> SS_9T_LVT_0_lvt_9t_count_out_shift));
+
+	//DSS7 VCPU2 0xb800_0348
+	rtd_outl(SS_9T_RVT_0_reg,0x00000000); //DSS7 reset
+	rtd_outl(SS_9T_RVT_0_reg,0x03000000); //wire_sel=1'b1, ro_sel=3'b001
+	rtd_outl(SS_9T_RVT_0_reg,0x83000000); //DSS7 enable
+	mdelay(500);		// wait done
+	regValue = rtd_inl(SS_9T_RVT_0_reg); //count_out[19:0]
+	printf("DSS7 VCPU2    = 0x%05x\n", ((regValue & SS_9T_RVT_0_rvt_9t_count_out_mask) >> SS_9T_RVT_0_rvt_9t_count_out_shift));
+
+	//DSS8 tv_sb1 0xb801_c3f0
+	rtd_outl(SS_7T_0_reg,0x00000000); //DSS8 reset
+	rtd_outl(SS_7T_0_reg,0x03000000); //wire_sel=1'b1, ro_sel=3'b001
+	rtd_outl(SS_7T_0_reg,0x83000000); //DSS8 enable
+	mdelay(500);		// wait done
+	regValue = rtd_inl(SS_7T_0_reg); //count_out[19:0]
+	printf("DSS8 TV_SB1   = 0x%05x\n", ((regValue & SS_7T_0_rlvt_7t_count_out_mask) >> SS_7T_0_rlvt_7t_count_out_shift));
+#endif
+	return 0;
+}
+
+/*
+ * get_accessible_ddr_size()
+ */
+
+unsigned long get_accessible_ddr_size(int unit)
+{
+#ifdef CONFIG_BOARD_FPGA
+	return CONFIG_SYS_RAM_DCU1_SIZE;
+#else
+	unsigned long ddr_size = (get_total_ddr_size() * 1024) / 8;
+
+	if(unit == UNIT_MEGABYTE)
+		return ddr_size;
+	else
+		return (ddr_size * 0x100000);
+
+	return 0;
+#endif //CONFIG_BOARD_FPGA
+}
+
+#define DC0_DPI_DLL_CRT_SSC3_reg	0x9800E028
+#define DC1_DPI_DLL_CRT_SSC3_reg	0x9800F028
+#define DCPHY_DPI_DLL_CRT_SSC3_get_DPI_N_CODE_T(data)   ((0x0000FF00&(data))>>8)
+
+static int do_bdinfo_ddr(void)
+{
+	char info_dc0[50], info_dc1[50];
+	int i;
+	printf("*** bdinfo ddr ***\n");
+
+#if defined(CONFIG_RTD1295) || defined(CONFIG_RTD1395)
+	for( i = 0; i < MAX_DC_COUNT; i++){
+		uint ddr_speed_setting;
+		if( i == 0 )
+			ddr_speed_setting = DCPHY_DPI_DLL_CRT_SSC3_get_DPI_N_CODE_T(rtd_inl(DC0_DPI_DLL_CRT_SSC3_reg));
+		else
+			ddr_speed_setting = DCPHY_DPI_DLL_CRT_SSC3_get_DPI_N_CODE_T(rtd_inl(DC1_DPI_DLL_CRT_SSC3_reg));
+		
+		char range_exceed[16] = "";
+
+		switch (ddr_speed_setting) {
+			case 0x2a ... 0xff:
+				ddr_mhz = 2400;
+				strcpy(range_exceed, "OVER");
+				break;
+			case 0x25 ... 0x29:
+				ddr_mhz = 2400;
+				break;
+			case 0x20 ... 0x24:
+				ddr_mhz = 2133;
+				break;
+			case 0x1b ... 0x1f:
+				ddr_mhz = 1866;
+				break;
+			case 0x16 ... 0x1a:
+				ddr_mhz = 1600;
+				break;
+			case 0x15:
+				ddr_mhz = 1333;
+				break;
+			case 0x0 ... 0x14 :
+				ddr_mhz = 1333;
+				strcpy(range_exceed, "UNDER");
+				break;
+			default:	ddr_mhz = 0;	break;
+		}
+		
+		if( i == 0 )
+			sprintf(info_dc0, "DDR        = %s %u MT/s (0x%02x)\n",range_exceed, ddr_mhz, ddr_speed_setting);
+		else
+			sprintf(info_dc1, "DDR        = %s %u MT/s (0x%02x)\n",range_exceed, ddr_mhz, ddr_speed_setting);
+	}
+
+#endif
+	
+	//printf("DDR        = %s %u MHz (0x%02x)\n",range_exceed, ddr_mhz, ddr_speed_setting);
+	print_ddr_info(info_dc0,info_dc1);
+
+	return 0;
+}
+
+#define SCPU_PLL_Output_4 	0x3
+#define SCPU_PLL_Output_2 	0x2
+#define ACPU_PLL_Output_4 	0x3
+#define ACPU_PLL_Output_2 	0x2
+#define BUS_PLL_Output_4 	0x1
+#define BUS_PLL_Output_2 	0x0
+
+static int do_bdinfo_pll(void)
+{
+	char   msg[64];
+	uint value_m, value_n, value_o;
+	uint Ncode, Fcode;
+	uint freq, tmp;
+	uint pdiv;
+	uint div = get_PLL_DIV_reg ;
+	
+
+	printf("*** bdinfo pll ***\n");
+	
+	//27MHz*(Ncode+1+Fcode/2048)/(N+1)
+	tmp = get_PLL_SSC_DIG_SCPU1_reg;
+	Ncode = PLL_SSC_DIG_SCPU1_get_NCODE_T_SCPU(tmp);
+	Fcode = PLL_SSC_DIG_SCPU1_get_FCODE_T_SCPU(tmp);
+	//freq = 27 * (Ncode + 3 + (Fcode/2048));
+	freq = 27 * (Ncode + 3) + (27 * Fcode / 2048);
+	sprintf( msg, "%4d MHz", freq );
+	printf("SCPU   PLL  = %s\n", msg);
+	if( PLL_DIV_get_scpu_freq_sel(div) == SCPU_PLL_Output_4)
+		sprintf( msg, "%4d MHz", freq/4);
+	else if( PLL_DIV_get_scpu_freq_sel(div) == SCPU_PLL_Output_2)
+		sprintf( msg, "%4d MHz", freq/2 );
+	else
+		sprintf( msg, "%4d MHz", freq );
+	printf("SCPU        = %s\n", msg);
+	
+	//27MHz*(M+2)/(N+1)/(O+1)
+	tmp = get_PLL_SSC_DIG_ACPU1_reg;
+	Ncode = PLL_SSC_DIG_ACPU1_get_NCODE_T_ACPU(tmp);
+	Fcode = PLL_SSC_DIG_ACPU1_get_FCODE_T_ACPU(tmp);
+	//freq = 27 * (Ncode + 3 + (Fcode/2048));
+	freq = 27 * (Ncode + 3) + (27 * Fcode / 2048);
+	sprintf( msg, "%4d MHz", freq );
+	printf("ACPU   PLL  = %s\n", msg);	
+	if( PLL_DIV_get_acpu_freq_sel(div) == ACPU_PLL_Output_4)
+		sprintf( msg, "%4d MHz", freq/4);
+	else if( PLL_DIV_get_acpu_freq_sel(div) == ACPU_PLL_Output_2)
+		sprintf( msg, "%4d MHz", freq/2 );
+	else
+		sprintf( msg, "%4d MHz", freq );
+	printf("ACPU        = %s\n", msg);
+
+	// get VCPU PLL MNO value
+	// 27MHz*(M+2)/(N+1)/(O+1)
+	tmp = get_PLL_VCPU1_reg;
+	value_m = PLL_VCPU1_get_PLLVCPU_M(tmp);
+	value_n = PLL_VCPU1_get_PLLVCPU_N(tmp);
+	value_o = PLL_VCPU1_get_REG_PLLVCPU_O(tmp);
+	freq = 27 * (value_m+2) / (value_n+1) / (value_o+1);	
+	sprintf( msg, "%4d MHz", freq );
+	printf("VCPU1  PLL  = %s\n", msg);
+	
+	// get VCPU PLL MNO value
+	// 27MHz*(M+2)/(N+1)/(O+1)
+	tmp = get_PLL_VCPU2_reg;
+	value_m = PLL_VCPU2_get_PLLVCPU_M(tmp);
+	value_n = PLL_VCPU2_get_PLLVCPU_N(tmp);
+	value_o = PLL_VCPU2_get_REG_PLLVCPU_O(tmp);
+	freq = 27 * (value_m+2) / (value_n+1) / (value_o+1);	
+	sprintf( msg, "%4d MHz", freq );
+	printf("VCPU2  PLL  = %s\n", msg);
+
+	// get DDSA PLL MNO value
+	tmp = get_PLL_SSC_DIG_DDSA1_reg;
+	Ncode = PLL_SSC_DIG_DDSA1_get_NCODE_T_DDSA(tmp);
+	Fcode = PLL_SSC_DIG_DDSA1_get_FCODE_T_DDSA(tmp);
+	pdiv = PLL_SSC_DIG_DDSA1_get_REG_PLLDDSA_ICO_PDIV2(tmp);
+	//freq = 27 * (pdiv + 1) * (Ncode + 3 + (Fcode/2048));
+	freq = (27 * (pdiv + 1)) * (Ncode + 3) + ((27 * (pdiv + 1)) * Fcode / 2048);
+	sprintf( msg, "%4d MHz", freq );
+	printf("DDSA   PLL  = %s\n", msg);	
+	
+	// get DDSB PLL MNO value
+	tmp = get_PLL_SSC_DIG_DDSB1_reg;
+	Ncode = PLL_SSC_DIG_DDSB1_get_NCODE_T_DDSB(tmp);
+	Fcode = PLL_SSC_DIG_DDSB1_get_FCODE_T_DDSB(tmp);
+	pdiv = PLL_SSC_DIG_DDSB1_get_REG_PLLDDSB_ICO_PDIV2(tmp);
+	//freq = 27 * (pdiv + 1) * (Ncode + 3 + (Fcode/2048));
+	freq = (27 * (pdiv + 1)) * (Ncode + 3) + ((27 * (pdiv + 1)) * Fcode / 2048);
+	sprintf( msg, "%4d MHz", freq );
+	printf("DDSB   PLL  = %s\n", msg);	
+	
+	// get BUS PLL MNO value
+	tmp = get_PLL_SSC_DIG_BUS1_reg;
+	Ncode = PLL_SSC_DIG_BUS1_get_NCODE_T_BUS(tmp);
+	Fcode = PLL_SSC_DIG_BUS1_get_FCODE_T_BUS(tmp);
+	//freq = 27 * (Ncode + 3 + (Fcode/2048));
+	freq = 27 * (Ncode + 3) + (27 * Fcode / 2048);
+	sprintf( msg, "%4d MHz", freq );
+	printf("BUS    PLL  = %s\n", msg);
+	
+	// get BUS PLL MNO value
+	tmp = get_PLL_SSC_DIG_BUSH1_reg;
+	Ncode = PLL_SSC_DIG_BUSH1_get_NCODE_T_BUS_H(tmp);
+	Fcode = PLL_SSC_DIG_BUSH1_get_FCODE_T_BUS_H(tmp);
+	//freq = 27 * (Ncode + 3 + (Fcode/2048));
+	freq = 27 * (Ncode + 3) + (27 * Fcode / 2048);
+	sprintf( msg, "%4d MHz", freq );
+	printf("BUS_H  PLL  = %s\n", msg);
+
+	// get GPU PLL MNO value
+	tmp = get_PLL_SSC_DIG_GPU1_reg;
+	Ncode = PLL_SSC_DIG_GPU1_get_NCODE_T_GPU(tmp);
+	Fcode = PLL_SSC_DIG_GPU1_get_FCODE_T_GPU(tmp);
+	//freq = 27 * (Ncode + 3 + (Fcode/2048));
+	freq = 27 * (Ncode + 3) + (27 * Fcode / 2048);
+	sprintf( msg, "%4d MHz", freq );
+	printf("GPU    PLL  = %s\n", msg);
+	
+	// get VODMA PLL MNO value
+	// 27MHz*(M+2)/(N+1)/(O+1)
+	tmp = get_PLL_VODMA1_reg;
+	value_m = PLL_VODMA1_get_REG_PLLVODMA_M(tmp);
+	value_n = PLL_VODMA1_get_REG_PLLVODMA_N(tmp);
+	value_o = PLL_VODMA1_get_REG_PLLVODMA_O(tmp);
+	freq = 27 * (value_m+2) / (value_n+1) / (value_o+1);	
+	sprintf( msg, "%4d MHz", freq );
+	printf("VODMA  PLL  = %s\n", msg);
+
+	//27MHz*(Ncode+3+Fcode/8192)/(N+1)
+#if 0
+	tmp = get_PLL_DDR_SSC1_reg;
+	Ncode = PLL_DDR_SSC1_get_SSCDDR_N_CODE(tmp);
+	Fcode = PLL_DDR_SSC1_get_SSCDDR_F_CODE(tmp);
+	tmp = get_PLL_DDR1_reg;
+	value_n = PLL_DDR1_get_PLLDDR_PDIV(tmp);
+	freq = (27 * (Ncode +3)+ 27*Fcode/8192) / (value_n+1) ;		
+	sprintf( msg, "%4d MHz", freq );
+	printf("DDR   PLL   = %s\n", msg);
+#endif
+		
+	return 0;
+}
+
+void do_bdinfo_spi (void);
+static int do_bdinfo_flash (void)
+{
+#ifdef CONFIG_CMD_SPI_FLASH_DRIVER
+	do_bdinfo_spi();
+#endif
+
+	return 0;
+}
+
+
+int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	int i;
 	bd_t *bd = gd->bd;
 
+	if (argc == 2) {
+		if (strcmp(argv[1], "pll") == 0) {
+			return do_bdinfo_pll();
+		}
+		else if (strcmp(argv[1], "ddr") == 0) {
+			return do_bdinfo_ddr();
+		}
+		else if (strcmp(argv[1], "dss") == 0) {
+			return do_bdinfo_dss();
+		}
+		else {
+			return CMD_RET_USAGE;
+		}
+	}
+
 	print_num("arch_number",	bd->bi_arch_number);
 	print_num("boot_params",	(ulong)bd->bi_boot_params);
 
@@ -377,18 +708,19 @@ static int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc,
 		print_num("-> size",	bd->bi_dram[i].size);
 	}
 
-#if defined(CONFIG_CMD_NET) && !defined(CONFIG_DM_ETH)
-	print_eths();
+#if defined(CONFIG_CMD_NET)
+	print_eth(0);
+	printf("ip_addr     = %s\n", getenv("ipaddr"));
 #endif
-	printf("baudrate    = %u bps\n", gd->baudrate);
+	printf("baudrate    = %d bps\n", gd->baudrate);
 #if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
 	print_num("TLB addr", gd->arch.tlb_addr);
 #endif
+#if !defined(CONFIG_RTD299X) && !defined(CONFIG_RTD1195) && !defined(CONFIG_RTD1295) && !defined(CONFIG_RTD1395)
 	print_num("relocaddr", gd->relocaddr);
 	print_num("reloc off", gd->reloc_off);
 	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
 	print_num("sp start ", gd->start_addr_sp);
-#if defined(CONFIG_LCD) || defined(CONFIG_VIDEO)
 	print_num("FB base  ", gd->fb_base);
 #endif
 	/*
@@ -400,9 +732,12 @@ static int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc,
 	printf("DSP frequency = %ld MHz\n", gd->bd->bi_dsp_freq);
 	printf("DDR frequency = %ld MHz\n", gd->bd->bi_ddr_freq);
 #endif
-#ifdef CONFIG_BOARD_TYPES
-	printf("Board Type  = %ld\n", gd->board_type);
-#endif
+
+	do_bdinfo_pll();
+	do_bdinfo_ddr();
+	do_bdinfo_flash();
+//	do_bdinfo_dss();
+
 	return 0;
 }
 
diff --git a/common/cmd_boot.c b/common/cmd_boot.c
index 8f2e0701b5..dff2747014 100644
--- a/common/cmd_boot.c
+++ b/common/cmd_boot.c
@@ -2,62 +2,4751 @@
  * (C) Copyright 2000-2003
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 /*
  * Misc boot support
  */
 #include <common.h>
+#ifndef CONFIG_BOOT_FOR_WD
 #include <command.h>
 #include <net.h>
+#include <asm/arch/rbus/crt_reg.h>
+#include <asm/arch/system.h>
+#include <asm/arch/fw_info.h>
+#include <asm/arch/mcp.h>
+#include <watchdog.h>
+#include <nand.h>
+#include <asm/arch/rbus/nand_reg.h>
+#include <asm/arch/rtk_ipc_shm.h>
+#include <asm/arch/rbus/iso_reg.h>
+#include <asm/sizes.h>
+#include <asm/arch/cpu.h>
+#ifdef CONFIG_CMD_SATA
+#include <sata.h>
+#endif
+#include <asm/arch/factorylib.h>
+#include <asm/arch/rtkemmc.h>
+#include <rtkspi.h>
+#ifdef CONFIG_CUSTOMIZE_BOOTFLOW_1
+#include <customized.h>
+#endif
+#if CONFIG_NAS_ENABLE
+#include <fdt_support.h>
+#include <version.h>
+#endif
+
+
+#ifdef CONFIG_LZMA
+#include <lzma/LzmaTypes.h>
+#include <lzma/LzmaDec.h>
+#include <lzma/LzmaTools.h>
+#endif /* CONFIG_LZMA */
+#include "linux/lzo.h"
+
+#define CONFIG_ANDROID_RECOVERY 0
+#if CONFIG_ANDROID_RECOVERY
+#include <asm/arch/factorylib.h>
+#define RECOVERY_FILE_IN_FACTORY    FACTORY_HEADER_FILE_NAME"recovery"
+
+typedef struct _bootloader_message {
+    char command[32];
+    char status[32];
+    char recovery[1024];
+} bootloader_message;
+#endif
+
+#define CONFIG_FW_TABLE_SIZE    0x8000
+//#define CONFIG_FACTORY_SIZE          0x400000
+
+
+//#define BYPASS_CHECKSUM
+//#define EMMC_BLOCK_LOG
+
+DECLARE_GLOBAL_DATA_PTR;
+
+
+typedef enum{
+	BOOT_FROM_USB_DISABLE,
+	BOOT_FROM_USB_UNCOMPRESSED,
+	BOOT_FROM_USB_COMPRESSED
+}BOOT_FROM_USB_T;
+
+typedef enum{
+	BOOT_FROM_FLASH_NORMAL_MODE,
+	BOOT_FROM_FLASH_MANUAL_MODE
+}BOOT_FROM_FLASH_T;
+
+#if defined(CONFIG_RTD1295) || defined(CONFIG_RTD1395)
+
+#ifdef CONFIG_CMD_SATA
+  extern int sata_boot_debug;
+  extern int sata_curr_device;
+  extern block_dev_desc_t sata_dev_desc[CONFIG_SYS_SATA_MAX_DEVICE];
+#endif /* CONFIG_CMD_SATA */
+
+//[fw] share memory.
+extern struct RTK119X_ipc_shm ipc_shm;
+extern struct RTK119X_ipc_shm_ir ipc_ir;
+int ipc_ir_set = 0;
+
+//[fw] image display.
+uchar boot_logo_enable=0;
+uint custom_logo_src_width=0;
+uint custom_logo_src_height=0;
+uint custom_logo_dst_width=0;
+uint custom_logo_dst_height=0;
+uchar sys_logo_is_HDMI = 0;
+//uchar sys_logo_enabled = 0;
+
+uint eMMC_bootcode_area_size = 0x220000;		// eMMC bootcode area size
+uint eMMC_fw_desc_table_start = 0;				// start address of valid fw desc table in emmc
+uint nand_fw_desc_table_start = 0;				// start address of valid fw desc table in nand
+uint sata_fw_desc_table_start = 34;				// start address of valid fw desc table in sata
+uint spi_fw_desc_table_start = 0x100000;			// start address of valid fw desc table in spi
+
+BOOT_FROM_FLASH_T boot_from_flash = BOOT_FROM_FLASH_NORMAL_MODE;
+BOOT_FROM_USB_T boot_from_usb = BOOT_FROM_USB_DISABLE;
+extern BOOT_MODE boot_mode;
+
+#ifdef CONFIG_TEE
+uint tee_enable=0;
+#endif /* CONFIG_TEE */
+#ifdef NAS_ENABLE
+uint initrd_size=0;
+#endif /* NAS_ENABLE */
+
+#endif /* defined(CONFIG_RTD1295) || defined(CONFIG_RTD1395) */
+
+#ifdef CONFIG_CMD_KEY_BURNING
+extern int OTP_Get_Byte(int offset, unsigned char *ptr, unsigned int cnt);
+extern unsigned int OTP_JUDGE_BIT(unsigned int offset);
+#endif /* CONFIG_CMD_KEY_BURNING */
+
+static int accelerate_state = 0;  /*The flag for controlling faster blue logo*/
+static int audio_fw_state = 0;
+unsigned int Auto_AFW_MEM_START = 0; /* Save the address of AFW from fw_desc */
+
+extern const unsigned int Kh_key_default[4];
 
 #ifdef CONFIG_CMD_GO
 
+#if defined(CONFIG_UBOOT_DEFAULT) || defined(CONFIG_FT_RESCUE)
+#if defined(CONFIG_RTD1295) || defined(CONFIG_RTD1395)
+
+#define BIST_ROOTFS_ADDR    0x30000000
+#define BIST_DTB            "rtd-1295-bist.dtb"
+
+extern void delete_env(void);
+extern void enable_clock(uint reg_reset, uint mask_reset, uint reg_clock, uint mask_clock);
+extern int rtk_plat_boot_go(bootm_headers_t *images);
+
+extern unsigned int mcp_dscpt_addr;
+extern const unsigned int Kh_key_default[4];
+
+int rtk_plat_prepare_fw_image_from_NAND(void);
+int rtk_plat_prepare_fw_image_from_eMMC(void);
+int rtk_plat_prepare_fw_image_from_SATA(void);
+int rtk_plat_prepare_fw_image_from_SPI(void);
+int rtk_plat_prepare_fw_image_from_SD(void);
+char *rtk_plat_prepare_fw_image_from_USB(int fw_type);
+int rtk_plat_do_boot_linux(void);
+int rtk_plat_boot_handler(void);
+//static int rtk_call_bootm(void);
+static int rtk_call_booti(void);
+int decrypt_image(char *src, char *dst, uint length, uint *key);
+int rtk_get_secure_boot_type(void);
+void rtk_hexdump( const char * str, unsigned char * pcBuf, unsigned int length );
+void GetKeyFromSRAM(unsigned int sram_addr, unsigned char* key, unsigned int length);
+
+static void reset_shared_memory(void);
+
+
+static unsigned long do_go_kernel_image(void)
+{
+    int ret = RTK_PLAT_ERR_OK;
+
+#ifdef CONFIG_SYS_RTK_NAND_FLASH
+	ret = rtk_plat_prepare_fw_image_from_NAND();
+#elif defined(CONFIG_SYS_RTK_EMMC_FLASH)
+	ret = rtk_plat_prepare_fw_image_from_eMMC();
+#elif defined(CONFIG_SYS_RTK_SATA_STORAGE)
+	ret = rtk_plat_prepare_fw_image_from_SATA();
+#elif defined(CONFIG_BOOT_FROM_SPI)
+	ret = rtk_plat_prepare_fw_image_from_SPI();
+#endif
+	if (ret!= RTK_PLAT_ERR_OK)
+		return ret;
+
+	return rtk_plat_do_boot_linux();
+}
+
+static unsigned long do_go_audio_fw(void)
+{
+	int magic = SWAPEND32(0x16803001);
+	int offset = SWAPEND32(MIPS_SHARED_MEMORY_ENTRY_ADDR);
+	unsigned long fw_addr = getenv_ulong("audio_loadaddr", 16, 0);
+
+	if(audio_fw_state) return 0;
+
+	// if IR wakeup info is set...
+	if (ipc_ir_set) {
+		// cat ir info to the end of IPC_SHM with 16 byte align
+		void *ir_tbl_addr = (void*)ALIGN((MIPS_SHARED_MEMORY_ENTRY_ADDR + 0xC4 + sizeof(ipc_shm)), 16);
+		memcpy(ir_tbl_addr, &ipc_ir, sizeof(ipc_ir));
+		ipc_shm.ir_extended_tbl_pt = SWAPEND32((unsigned int)(uintptr_t)ir_tbl_addr);
+	}
+
+	printf("Start Audio Firmware ...\n");
+
+	reset_shared_memory();
+
+	if (!fw_addr)
+		fw_addr = CONFIG_FW_LOADADDR;
+	if (!ipc_shm.audio_fw_entry_pt)
+		ipc_shm.audio_fw_entry_pt = SWAPEND32(fw_addr | MIPS_KSEG0BASE);
+
+	memcpy((unsigned char *)(MIPS_SHARED_MEMORY_ENTRY_ADDR+0xC4), &ipc_shm, sizeof(ipc_shm));
+	memcpy((unsigned char *)(MIPS_SHARED_MEMORY_ENTRY_ADDR), &magic, sizeof(magic));
+	memcpy((unsigned char *)(MIPS_SHARED_MEMORY_ENTRY_ADDR +4), &offset, sizeof(offset));
+
+	flush_dcache_all();
+
+#ifdef CONFIG_RTD1395
+	rtd_outl(ACPU_STARTUP_FLAG, ACPU_MAGIC1); //write magic1
+#else
+	rtd_outl(ISO_RESERVED_USE_3, MIPS_A_ENTRY_CODE_ADDR | MIPS_KSEG1BASE);
+#endif
+	sync();
+	/* Enable ACPU */
+	rtd_setbits(CLOCK_ENABLE2_reg,_BIT4);
+
+	audio_fw_state = 1;
+
+	return 0;
+
+}
+
+static unsigned long do_go_all_fw(void)
+{
+
+	int ret = RTK_PLAT_ERR_OK;
+
+	if (run_command("go a", 0) != 0) {
+		printf("go a failed!\n");
+		return RTK_PLAT_ERR_BOOT;
+	}
+
+	if (run_command("go k", 0) != 0) {
+		printf("go k failed!\n");
+		return RTK_PLAT_ERR_BOOT;
+	}
+
+	return ret;
+}
+#endif /* defined(CONFIG_RTD1295) || defined(CONFIG_RTD1395) */
+
+#ifdef CONFIG_RESCUE_FROM_USB
+int rtk_decrypt_rescue_from_usb(char* filename, unsigned int target)
+{
+	char tmpbuf[128];
+	unsigned char ks[16],kh[16],kimg[16];
+    unsigned char aes_key[16],rsa_key[256];
+    unsigned int real_body_size = 0;
+#ifdef CONFIG_CMD_KEY_BURNING
+	unsigned int * Kh_key_ptr = NULL;
+#else
+	unsigned int * Kh_key_ptr = (unsigned int *)(uintptr_t)Kh_key_default;
+#endif
+	unsigned int img_truncated_size = RSA_SIGNATURE_LENGTH*2+NP_INV32_LENGTH; // install_a will append 256-byte signature data to it
+	int ret;
+	unsigned int image_size=0;
+
+	extern unsigned int mcp_dscpt_addr;
+	mcp_dscpt_addr = 0;
+
+
+	sprintf(tmpbuf, "fatload usb 0:1 %x %s",ENCRYPTED_FW_ADDR,filename);
+	if (run_command(tmpbuf, 0) != 0) {
+			return RTK_PLAT_ERR_READ_FW_IMG;
+	}
+
+	image_size = getenv_ulong("filesize", 16, 0);
+
+	memset(ks,0x00,16);
+	memset(kh,0x00,16);
+	memset(kimg,0x00,16);
+
+    memset(aes_key,0x00,16);
+	memset(rsa_key,0x00,256);
+
+    GetKeyFromSRAM(KH_P_SRAM_ADDR, aes_key, AES_KEY_SIZE);
+    GetKeyFromSRAM(RSA_KEY_FW_SRAM_ADDR, rsa_key, RSA_KEY_SIZE);
+    flush_cache((unsigned int) (uintptr_t)aes_key, AES_KEY_SIZE);
+    flush_cache((unsigned int) (uintptr_t)rsa_key, RSA_KEY_SIZE);
+
+#ifdef CONFIG_CMD_KEY_BURNING
+	OTP_Get_Byte(OTP_K_S, ks, 16);
+	OTP_Get_Byte(OTP_K_H, kh, 16);
+	sync();
+	flush_cache((unsigned int) (uintptr_t)ks, 16);
+	flush_cache((unsigned int) (uintptr_t)kh, 16);
+#endif
+	AES_ECB_encrypt(ks, 16, kimg, (unsigned int *)kh);
+	flush_cache((unsigned int) (uintptr_t)kimg, 16);
+	sync();
+
+	//Kh_key_ptr = kimg;
+	//Kh_key_ptr[0] = swap_endian(Kh_key_ptr[0]);
+	//Kh_key_ptr[1] = swap_endian(Kh_key_ptr[1]);
+	//Kh_key_ptr[2] = swap_endian(Kh_key_ptr[2]);
+	//Kh_key_ptr[3] = swap_endian(Kh_key_ptr[3]);
+    Kh_key_ptr = (unsigned int *) (uintptr_t)aes_key;
+	flush_cache((unsigned int) (uintptr_t)aes_key, 16);
+
+    // decrypt image
+	printf("to decrypt...\n");
+
+	flush_cache((unsigned int) ENCRYPTED_FW_ADDR, image_size);
+
+    if (decrypt_image((char *)ENCRYPTED_FW_ADDR,
+		(char *)(uintptr_t)target,
+		image_size - img_truncated_size,
+		Kh_key_ptr))
+	{
+		printf("decrypt image:%s error!\n", filename);
+		return RTK_PLAT_ERR_READ_FW_IMG;
+	}
+
+	sync();
+	memset(ks,0x00,16);
+	memset(kh,0x00,16);
+	memset(kimg,0x00,16);
+
+    copy_memory((void *)(uintptr_t)target + image_size - img_truncated_size,(void *) ENCRYPTED_FW_ADDR + image_size - img_truncated_size, img_truncated_size);
+	flush_cache((unsigned int) target, image_size);
+
+    real_body_size = (UINT32)(REG32((volatile UINT32 *)(uintptr_t)target + (image_size - img_truncated_size) - 4));
+    real_body_size = swap_endian(real_body_size);
+	real_body_size /= 8;
+
+	ret = Verify_SHA256_hash( (unsigned char *)(uintptr_t)target,
+							real_body_size,
+							(unsigned char *)(uintptr_t)(target + image_size - img_truncated_size),
+							1, rsa_key);
+	if( ret < 0 ) {
+		printf("[ERR] %s: verify hash fail(%d)\n", __FUNCTION__, ret );
+		return RTK_PLAT_ERR_READ_FW_IMG;
+	}
+
+	return RTK_PLAT_ERR_OK;
+}
+
+int boot_rescue_from_usb(void)
+{
+	char tmpbuf[128];
+	int ret = RTK_PLAT_ERR_OK;
+	char *filename;
+	unsigned int secure_mode=0;
+
+	secure_mode = rtk_get_secure_boot_type();
+
+	printf("==== %s (secure mode:%d)=====\n", __func__, secure_mode);
+
+	run_command("usb start", 0);	/* "usb start" always return 0 */
+	if (run_command("usb dev", 0) != 0) {
+		printf("No USB device found!\n");
+		return RTK_PLAT_ERR_READ_RESCUE_IMG;
+	}
+
+	/* DTB */
+	if ((filename = getenv("rescue_dtb")) == NULL) {
+		filename =(char*) CONFIG_RESCUE_FROM_USB_DTB;
+	}
+	sprintf(tmpbuf, "fatload usb 0:1 %s %s", getenv("fdt_loadaddr"), filename);
+	if (run_command(tmpbuf, 0) != 0) {
+		goto loading_failed;
+	}
+
+	printf("Loading \"%s\" to %s is OK.\n\n", filename, getenv("fdt_loadaddr"));
+
+	/* Linux kernel */
+	if ((filename = getenv("rescue_vmlinux")) == NULL) {
+		filename =(char*) CONFIG_RESCUE_FROM_USB_VMLINUX;
+	}
+	if(secure_mode == RTK_SECURE_BOOT)
+	{
+		if (rtk_decrypt_rescue_from_usb(filename,getenv_ulong("kernel_loadaddr", 16, 0)))
+		goto loading_failed;
+	}
+	else
+	{
+		sprintf(tmpbuf, "fatload usb 0:1 %s %s", getenv("kernel_loadaddr"), filename);
+		if (run_command(tmpbuf, 0) != 0) {
+			goto loading_failed;
+		}
+	}
+
+	printf("Loading \"%s\" to %s is OK.\n\n", filename, getenv("kernel_loadaddr"));
+
+	/* rootfs */
+	if ((filename = getenv("rescue_rootfs")) == NULL) {
+		filename =(char*) CONFIG_RESCUE_FROM_USB_ROOTFS;
+	}
+	if(secure_mode == RTK_SECURE_BOOT)
+	{
+		if (rtk_decrypt_rescue_from_usb(filename, getenv_ulong("rootfs_loadaddr", 16, 0)))
+		goto loading_failed;
+	}
+	else
+	{
+		sprintf(tmpbuf, "fatload usb 0:1 %s %s", getenv("rootfs_loadaddr"), filename);
+		if (run_command(tmpbuf, 0) != 0) {
+			goto loading_failed;
+		}
+	}
+
+	printf("Loading \"%s\" to %s is OK.\n\n", filename, getenv("rootfs_loadaddr"));
+
+#if 0
+	/* TEE OS */
+	filename = "tee.bin";
+	sprintf(tmpbuf, "fatload usb 0:1 %x %s", CONFIG_TEE_OS_ADDR, filename);
+	if (run_command(tmpbuf, 0) == 0){
+		printf("Loading \"%s\" to 0x%08x is OK.\n\n", filename, CONFIG_TEE_OS_ADDR);
+	}
+	else{
+		printf("Loading \"%s\" from USB failed.\n", filename);
+		goto loading_failed;
+	}
+
+	/* BL31 */
+	filename = "bl31.bin";
+	sprintf(tmpbuf, "fatload usb 0:1 %x %s", CONFIG_BL31_ADDR, filename);
+	if (run_command(tmpbuf, 0) == 0){
+		printf("Loading \"%s\" to 0x%08x is OK.\n\n", filename, CONFIG_BL31_ADDR);
+	}
+	else{
+		printf("Loading \"%s\" from USB failed.\n", filename);
+		goto loading_failed;
+	}
+#endif
+
+	/* audio firmware */
+	if ((filename = getenv("rescue_audio")) == NULL) {
+		filename =(char*) CONFIG_RESCUE_FROM_USB_AUDIO_CORE;
+	}
+	if(secure_mode == RTK_SECURE_BOOT)
+	{
+		if (!rtk_decrypt_rescue_from_usb(filename, MIPS_AUDIO_FW_ENTRY_ADDR))
+		{
+			printf("Loading \"%s\" to 0x%08x is OK.\n", filename, MIPS_AUDIO_FW_ENTRY_ADDR);
+			run_command("go a", 0);
+		}
+		else
+			printf("Loading \"%s\" from USB failed.\n", filename);
+			/* Go on without Audio firmware. */
+	}
+	else
+	{
+		sprintf(tmpbuf, "fatload usb 0:1 0x%08x %s", MIPS_AUDIO_FW_ENTRY_ADDR, filename);
+		if (run_command(tmpbuf, 0) == 0) {
+			printf("Loading \"%s\" to 0x%08x is OK.\n", filename, MIPS_AUDIO_FW_ENTRY_ADDR);
+			run_command("go a", 0);
+		}
+		else {
+			printf("Loading \"%s\" from USB failed.\n", filename);
+			/* Go on without Audio firmware. */
+		}
+    }
+	boot_mode = BOOT_RESCUE_MODE;
+
+	/* Clear the HYP ADDR since we don't want rescue jump to HYP mode */
+	if (getenv("hyp_loadaddr"))
+		setenv("hyp_loadaddr", "");
+
+	//ret = rtk_call_bootm();
+	ret = rtk_call_booti();
+	/* Should not reach here */
+
+	return ret;
+
+loading_failed:
+	printf("Loading \"%s\" from USB failed.\n", filename);
+	return RTK_PLAT_ERR_READ_RESCUE_IMG;
+}
+#endif /* CONFIG_RESCUE_FROM_USB */
+#endif /* defined(CONFIG_UBOOT_DEFAULT) || defined(CONFIG_FT_RESCUE) */
+
+#ifdef CONFIG_BOOT_FROM_SD
+int boot_from_sd(void)
+{
+	char tmpbuf[128];
+	int ret = RTK_PLAT_ERR_OK;
+	char *filename;
+	unsigned int secure_mode=0;
+
+	secure_mode = rtk_get_secure_boot_type();
+
+	printf("==== %s (boot from SD mode; secure_mode %d)=====\n",
+	__func__, secure_mode);
+
+#if 0 /* had beed executed in board.c>>sd_card_init */
+	ret = run_command("sd init", 0);
+	if( ret != 0 ) {
+		DDDDRED("sd initialize failed\n");
+		goto loading_failed;
+	}
+#endif
+
+	/* DTB 0x02100000 */
+	/* ROOTFS 0x02100000 */
+	/* Kernel 0x03000000 */
+	/* AudioFW 0x0f900000 or 0x01b00000 */
+	/* Image file boot logo 0x1e800000 */
+
+	/* DTB ------------------------------------------------------------------ */
+	if ((filename = getenv("sd_boot_dtb")) == NULL) {
+		filename =(char*) CONFIG_BOOT_FROM_SD_DTB;
+	}
+	sprintf(tmpbuf, "fatload sd 0:1 %s %s", getenv("fdt_loadaddr"), filename);
+	if (run_command(tmpbuf, 0) != 0) {
+		DDDDRED("load %s to %s failed\n", filename, getenv("fdt_loadaddr"));
+		goto loading_failed;
+	}
+	printf("Loading \"%s\" to %s is OK.\n\n", filename, getenv("fdt_loadaddr"));
+
+	/* ROOTFS --------------------------------------------------------------- */
+	if ((filename = getenv("sd_boot_rootfs")) == NULL) {
+		filename =(char*) CONFIG_BOOT_FROM_SD_ROOTFS;
+	}
+	if(secure_mode == RTK_SECURE_BOOT)
+	{
+#if 0
+		if (rtk_decrypt_rescue_from_sd(filename,getenv_ulong("rootfs_loadaddr", 16, 0))) {
+			DDDDRED("Loading \"%s\" to %s failed.\n\n", filename, getenv("rootfs_loadaddr"));
+			goto loading_failed;
+		}
+#else
+		DDDDRED("Not implement for secure mode\n");
+		DDDDRED("Loading \"%s\" to %s failed.\n\n", filename, getenv("rootfs_loadaddr"));
+		goto loading_failed;
+#endif
+	}
+	else {
+		sprintf(tmpbuf, "fatload sd 0:1 %s %s", getenv("rootfs_loadaddr"), filename);
+		if (run_command(tmpbuf, 0) != 0) {
+			DDDDRED("load %s to %s failed\n", filename, getenv("rootfs_loadaddr"));
+#if 0 /* it is not essential for ubuntu kernel */
+			goto loading_failed;
+#endif
+		}
+		else
+			printf("Loading \"%s\" to %s is OK.\n\n", filename, getenv("rootfs_loadaddr"));
+	}
+
+	/* Kernel --------------------------------------------------------------- */
+	if ((filename = getenv("sd_vmlinux")) == NULL) {
+		filename =(char*) CONFIG_BOOT_FROM_SD_VMLINUX;
+	}
+	if(secure_mode == RTK_SECURE_BOOT)
+	{
+#if 0
+		if (rtk_decrypt_rescue_from_sd(filename,getenv_ulong("kernel_loadaddr", 16, 0))) {
+			DDDDRED("Loading \"%s\" to %s failed.\n\n", filename, getenv("kernel_loadaddr"));
+			goto loading_failed;
+		}
+#else
+		DDDDRED("Not implement for secure mode\n");
+		DDDDRED("Loading \"%s\" to %s failed.\n\n", filename, getenv("kernel_loadaddr"));
+		goto loading_failed;
+#endif
+	}
+	else
+	{
+		sprintf(tmpbuf, "fatload sd 0:1 %s %s", getenv("kernel_loadaddr"), filename);
+		if (run_command(tmpbuf, 0) != 0) {
+			DDDDRED("load %s to %s failed\n", filename, getenv("kernel_loadaddr"));
+			goto loading_failed;
+		}
+		printf("Loading \"%s\" to %s is OK.\n\n", filename, getenv("kernel_loadaddr"));
+	}
+
+	/* TEE OS, BL31 --------------------------------------------------------- */
+#if 0
+	/* TEE OS */
+	filename = "tee.bin";
+	sprintf(tmpbuf, "fatload sd 0:1 %x %s", CONFIG_TEE_OS_ADDR, filename);
+	if (run_command(tmpbuf, 0) == 0){
+		printf("Loading \"%s\" to 0x%08x is OK.\n\n", filename, CONFIG_TEE_OS_ADDR);
+	}
+	else{
+		printf("Loading \"%s\" from SD failed.\n", filename);
+		goto loading_failed;
+	}
+
+	/* BL31 */
+	filename = "bl31.bin";
+	sprintf(tmpbuf, "fatload sd 0:1 %x %s", CONFIG_BL31_ADDR, filename);
+	if (run_command(tmpbuf, 0) == 0){
+		printf("Loading \"%s\" to 0x%08x is OK.\n\n", filename, CONFIG_BL31_ADDR);
+	}
+	else{
+		printf("Loading \"%s\" from SD failed.\n", filename);
+		goto loading_failed;
+	}
+#endif
+
+	/* audio firmware ------------------------------------------------------- */
+	if ((filename = getenv("sd_audio")) == NULL) {
+		filename =(char*) CONFIG_BOOT_FROM_SD_AUDIO_CORE;
+	}
+	if(secure_mode == RTK_SECURE_BOOT)
+	{
+#if 0
+		if (rtk_decrypt_rescue_from_sd(filename,getenv_ulong("audio_loadaddr", 16, 0))) {
+			DDDDRED("Loading \"%s\" to %s failed.\n\n", filename, getenv("audio_loadaddr"));
+			goto loading_failed;
+		}
+#else
+		DDDDRED("Not implement for secure mode\n");
+		DDDDRED("Loading \"%s\" to %s failed.\n\n", filename, getenv("audio_loadaddr"));
+		goto loading_failed;
+#endif
+	}
+	else
+	{
+		sprintf(tmpbuf, "fatload sd 0:1 %s %s", getenv("audio_loadaddr"), filename);
+		if (run_command(tmpbuf, 0) != 0) {
+			DDDDRED("load %s to %s failed\n", filename, getenv("audio_loadaddr"));
+			goto loading_failed;
+		}
+		printf("Loading \"%s\" to %s is OK.\n\n", filename, getenv("audio_loadaddr"));
+	}
+	run_command("go a", 0);
+
+	boot_mode = BOOT_RESCUE_MODE;
+
+#ifdef CONFIG_WAIT_AFW_1_SECOND
+	mdelay(1000); /* wait audio fw log print out */
+#endif
+
+	/* Clear the HYP ADDR since we don't want rescue jump to HYP mode */
+	if (getenv("hyp_loadaddr"))
+		setenv("hyp_loadaddr", "");
+
+	//ret = rtk_call_bootm();
+	ret = rtk_call_booti();
+	/* Should not reach here */
+
+	return ret;
+
+loading_failed:
+	//printf("Loading \"%s\" from SD failed.\n", filename);
+	return RTK_PLAT_ERR_READ_SD_IMG;
+}
+#endif /* CONFIG_LOADBOOTCODE_FROM_SD */
+
+#ifdef CONFIG_LOADBOOTCODE_FROM_SD
+int load_bootcode_from_sd(void)
+{
+	int ret;
+	unsigned char * pBuf;
+
+	printf("==== start load bootcode from SD =====\n");
+
+	do {
+		ret = run_command("sd init", 0);
+		if( ret != 0 ) {
+			DDDDRED("sd initialize failed\n");
+			break;
+		}
+		/* add sanity check here */
+		run_command("sd read 0x00020000 0x50 0x3F0", 0);
+		pBuf = (unsigned char *)0x00020000;
+		/* add sanity check here */
+		if( ! ( pBuf[0] == 0x0A &&
+			    pBuf[1] == 0x00 &&
+			    pBuf[2] == 0x00 &&
+			    pBuf[3] == 0x14 ) ) {
+			DDDDRED("[WARNING] bootcode seem is not valid, first 4 bytes:\n"
+			         "          %02x %02x %02x %02x\n",
+			         pBuf[0], pBuf[1], pBuf[2], pBuf[3]);
+			break;
+		}
+		run_command("icache off", 0);
+		run_command("dcache off", 0);
+		printf("finish to load bootcode from SD to 0x00020000\n");
+		run_command("go 0x00020000", 0);
+
+		DDDDRED("==== sholud not reach =====\n");
+	}
+	while(0);
+
+	return RTK_PLAT_ERR_BOOT;
+}
+#endif /* CONFIG_LOADBOOTCODE_FROM_SD */
+
 /* Allow ports to override the default behavior */
 __attribute__((weak))
-unsigned long do_go_exec(ulong (*entry)(int, char * const []), int argc,
-				 char * const argv[])
+unsigned long do_go_exec (ulong (*entry)(int, char * const []), int argc, char * const argv[])
 {
 	return entry (argc, argv);
 }
 
-static int do_go(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+
+int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	ulong	addr, rc;
 	int     rcode = 0;
+	int     do_cleanup = 0;
 
 	if (argc < 2)
 		return CMD_RET_USAGE;
 
+#if defined(CONFIG_UBOOT_DEFAULT) || defined(CONFIG_FT_RESCUE)
+#if defined(CONFIG_RTD1295) || defined(CONFIG_RTD1395)
+	if (argv[1][0] == 'a')
+	{
+		if (argv[1][1] == '\0')	// audio fw
+		{
+			return do_go_audio_fw();
+		}
+		else if (argv[1][1] == 'l' && argv[1][2] == 'l')	// all fw
+		{
+			return do_go_all_fw();
+		}
+		else
+		{
+			printf("Unknown command '%s'\n", argv[1]);
+			return CMD_RET_USAGE;
+		}
+	}
+	else if( strncmp( argv[1], "sdb", 3 ) == 0 )
+	{
+#ifdef CONFIG_LOADBOOTCODE_FROM_SD
+		return load_bootcode_from_sd();
+#else
+		printf("Unknown command '%s'\n", argv[1]);
+		return CMD_RET_USAGE;
+#endif /* CONFIG_LOADBOOTCODE_FROM_SD */
+	}
+	else if( strncmp( argv[1], "sd", 2 ) == 0 )
+	{
+#ifdef CONFIG_BOOT_FROM_SD
+		return boot_from_sd();
+#else
+		printf("Unknown command '%s'\n", argv[1]);
+		return CMD_RET_USAGE;
+#endif /* CONFIG_LOADBOOTCODE_FROM_SD */
+	}
+#ifdef CONFIG_BOOT_FROM_SATA
+	else if (argv[1][0] == 's')
+	{
+		sata_boot_debug = 0;
+		if( argc > 2 ) {
+			if( strncmp( argv[2], "debug", 5 ) == 0 ) {
+				sata_boot_debug = 1;
+			}
+		}
+		if( strncmp( argv[1], "snboot", 6 ) == 0 ) {
+			boot_mode = BOOT_NORMAL_MODE;
+			return rtk_plat_boot_handler();
+		}
+		else if( strncmp( argv[1], "saboot", 6 ) == 0 ) {
+			boot_mode = BOOT_ANDROID_MODE;
+			return rtk_plat_boot_handler();
+		}
+		else if( strncmp( argv[1], "srboot", 6 ) == 0 ) {
+			boot_mode = BOOT_RESCUE_MODE;
+			return rtk_plat_boot_handler();
+		}
+		else if( strncmp( argv[1], "sgboot", 6 ) == 0 ) {
+			boot_mode = BOOT_GOLD_MODE;
+			return rtk_plat_boot_handler();
+		}
+	}
+	else if (argv[1][0] == 'i')
+	{
+		if( strncmp( argv[1], "info", 4 ) == 0 ) {
+			printf("## boot_mode is %d\n", boot_mode);
+			printf("## boot_flash_type is %d\n", boot_flash_type);
+			printf("## sata_curr_device is %d\n", sata_curr_device);
+			printf("## fw_desc_table_v1 struct size    = 0x%lx\n", sizeof(fw_desc_table_v1_t));
+			printf("## part_entry struct size          = 0x%lx\n", sizeof(part_desc_entry_v1_t));
+			printf("## fw_entry struct size            = 0x%lx\n", sizeof(fw_desc_entry_v1_t));
+			return 0;
+		}
+	}
+#endif /* CONFIG_BOOT_FROM_SATA */
+	else if (argv[1][0] == 'k')
+	{
+		if (argv[1][1] == '\0')	// getkernel image from ddr;
+		{
+			return rtk_plat_do_boot_linux();
+		}
+		else if (argv[1][1] == 'f')	// get kernel image from flash;
+		{
+			boot_mode = BOOT_KERNEL_ONLY_MODE;
+			return do_go_kernel_image();
+		}
+		else
+		{
+			printf("Unknown command '%s'\n", argv[1]);
+			return CMD_RET_USAGE;
+		}
+
+	}
+	else if (argv[1][0] == 'r')
+	{
+		if (argv[1][1] == '\0') // rescue from flash
+		{
+#ifdef NAS_DUAL
+			boot_mode = BOOT_GOLD_MODE;
+#else
+			boot_mode = BOOT_RESCUE_MODE;
+#endif
+#ifdef NAS_ENABLE
+			if (RTK_PLAT_ERR_OK == rtk_plat_boot_handler())
+				return RTK_PLAT_ERR_OK;
+			else
+				boot_mode=BOOT_GOLD_MODE;
+#endif
+			return rtk_plat_boot_handler();
+		}
+		else if (argv[1][1] == 'a') // rescue for android
+		{
+			boot_mode = BOOT_ANDROID_MODE;
+			return rtk_plat_boot_handler();
+		}
+#ifdef CONFIG_RESCUE_FROM_USB
+		else if (argv[1][1] == 'u') // rescue from usb
+		{
+			return boot_rescue_from_usb();
+		}
+#endif
+		else
+		{
+			return 0;
+		}
+	}
+#endif /* defined(CONFIG_RTD1295) || defined(CONFIG_RTD1395) */
+#endif /* defined(CONFIG_UBOOT_DEFAULT) || defined(CONFIG_FT_RESCUE) */
+
 	addr = simple_strtoul(argv[1], NULL, 16);
 
-	printf ("## Starting application at 0x%08lX ...\n", addr);
+#ifdef CONFIG_CLEAR_ENV_AFTER_UPDATE_BOOTCODE
+	if (addr == DVRBOOT_EXE_BIN_ENTRY_ADDR)
+	{
+		printf ("Clear env when updating bootcode ...\n");
+		delete_env();
+	}
+#endif
+
+	printf ("Starting application at 0x%08lX ...\n", addr);
+
+	if( strncmp( argv[2], "nocache", 7 ) == 0 ) {
+		do_cleanup = 1;
+		printf ("Run application w/o any cache\n");
+		//cleanup_before_dvrbootexe();
+	}
 
 	/*
 	 * pass address parameter as argv[0] (aka command name),
 	 * and all remaining args
 	 */
-	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
+	rc = do_go_exec ((void *)addr, argc - 1 - do_cleanup, argv + 1 + do_cleanup);
 	if (rc != 0) rcode = 1;
 
-	printf ("## Application terminated, rc = 0x%lX\n", rc);
+	printf ("Application terminated, rc = 0x%lX\n", rc);
 	return rcode;
 }
 
+
+int do_goru (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	//boot_mode = BOOT_CONSOLE_MODE;
+#ifdef CONFIG_RESCUE_FROM_USB
+	WATCHDOG_DISABLE();
+	setenv("bootcmd", "bootr");
+	return boot_rescue_from_usb();
+#else
+	return 0;
+#endif
+}
+
+
+int do_gosd (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	//boot_mode = BOOT_CONSOLE_MODE;
+#ifdef CONFIG_BOOT_FROM_SD
+	WATCHDOG_DISABLE();
+	setenv("bootcmd", "bootr");
+	return boot_from_sd();
+#else
+	DDDDRED("command \"gosd\" not IMPLEMENT\n");
+	return 0;
+#endif
+}
+
+/* sdb means SD Bootcode */
+int do_gosdb (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	//boot_mode = BOOT_CONSOLE_MODE;
+#ifdef CONFIG_LOADBOOTCODE_FROM_SD
+	WATCHDOG_DISABLE();
+	return load_bootcode_from_sd();
+#else
+	DDDDRED("command \"gosdb\" not IMPLEMENT\n");
+	return 0;
+#endif
+}
+
 /* -------------------------------------------------------------------- */
 
 U_BOOT_CMD(
 	go, CONFIG_SYS_MAXARGS, 1,	do_go,
-	"start application at address 'addr'",
-	"addr [arg ...]\n    - start application at address 'addr'\n"
-	"      passing 'arg' as arguments"
+	"start application at address 'addr' or start running fw",
+	"[addr/a/v/v1/v2/k] [arg ...]\n"
+	"\taddr  - start application at address 'addr'\n"
+	"\ta     - start audio firmware\n"
+	"\tk     - start kernel\n"
+	"\tr     - start rescue linux\n"
+#ifdef CONFIG_RESCUE_FROM_USB
+	"\tru    - start rescue linux from usb\n"
+#endif
+#ifdef CONFIG_LOADBOOTCODE_FROM_SD
+	"\tsdb   - start load bootcode from SD\n"
+#endif
+#ifdef CONFIG_BOOT_FROM_SD
+	"\tsd    - start load image from SD\n"
+#endif
+#ifdef CONFIG_BOOT_FROM_SATA
+    "\tsnboot - go sata boot flow(BOOT_NORMAL_MODE)\n"
+    "\tsaboot - go sata boot flow(BOOT_ANDROID_MODE)\n"
+    "\tsrboot - go sata rescue boot flow(BOOT_RESCUE_MODE)\n"
+	"\tsgboot - go golden rescue boot flow(BOOT_GOLD_MODE)\n"
+	"\tinfo   - show curren mode info\n"
+#endif
+	"\tall   - start all firmware\n"
+	"\t[arg] - passing 'arg' as arguments\n"
+);
+
+
+/* -------------------------------------------------------------------- */
+
+U_BOOT_CMD(
+	goru, CONFIG_SYS_MAXARGS, 1,    do_goru,
+	"start rescue linux from usb",
+	""
+);
+
+U_BOOT_CMD(
+	gosd, CONFIG_SYS_MAXARGS, 1,    do_gosd,
+	"start boot from sd",
+	""
+);
+
+U_BOOT_CMD(
+	gosdb, CONFIG_SYS_MAXARGS, 1,    do_gosdb,
+	"load bootcode from sd",
+	""
 );
 
 #endif
 
+
 U_BOOT_CMD(
 	reset, 1, 0,	do_reset,
 	"Perform RESET of the CPU",
 	""
 );
+
+uint get_checksum(uchar *p, uint len) {
+	uint checksum = 0;
+	uint i;
+
+	for(i = 0; i < len; i++) {
+		checksum += *(p+i);
+
+		if (i % 0x200000 == 0)
+		{
+			EXECUTE_CUSTOMIZE_FUNC(0); // insert execute customer callback at here
+		}
+	}
+	return checksum;
+}
+
+
+uint get_mem_layout_when_read_image(MEM_LAYOUT_WHEN_READ_IMAGE_T *mem_layout)
+{
+	if (mem_layout->image_target_addr == 0)
+	{
+		printf("[ERROR] mem_layout->image_target_addr = 0x%08x\n", mem_layout->image_target_addr);
+
+		return 1;
+	}
+
+	if (mem_layout->bIsEncrypted)
+	{
+#ifdef CONFIG_SYS_RTK_NAND_FLASH
+		mem_layout->flash_to_ram_addr = mem_layout->image_target_addr;
+#else
+		mem_layout->flash_to_ram_addr = mem_layout->encrpyted_addr = ENCRYPTED_FW_ADDR;
+#endif
+		if (mem_layout->bIsCompressed)
+		{
+			mem_layout->decrypted_addr = mem_layout->compressed_addr = COMPRESSED_FW_IMAGE_ADDR;
+			mem_layout->decompressed_addr = mem_layout->image_target_addr;
+		}
+		else
+		{
+			mem_layout->decrypted_addr = mem_layout->image_target_addr;
+		}
+	}
+	else
+	{
+		if (mem_layout->bIsCompressed)
+		{
+			mem_layout->flash_to_ram_addr = mem_layout->compressed_addr = COMPRESSED_FW_IMAGE_ADDR;
+			mem_layout->decompressed_addr = mem_layout->image_target_addr;
+		}
+		else
+		{
+			mem_layout->flash_to_ram_addr = mem_layout->image_target_addr;
+		}
+	}
+
+	return 0;
+}
+
+int decrypt_image(char *src, char *dst, uint length, uint *key)
+{
+	//int i;
+	//uint sblock_len;
+	//uchar *sblock_dst, *sblock_src;
+
+	printf("decrypt from 0x%08lu to 0x%08lu, len:0x%08x\n", (ulong)src, (ulong)dst, length);
+
+    if (length & 0xf) {
+        printf("%s %d, fail\n", __FUNCTION__, __LINE__);
+        return -1;
+    }
+
+    if (AES_ECB_decrypt((uchar *)src, length, (uchar *)dst, key)) {
+		printf("%s %d, fail\n", __FUNCTION__, __LINE__);
+		return -1;
+	}
+
+#if 0
+	// get short block size
+	sblock_len = length & 0xf;
+
+	if (AES_CBC_decrypt((uchar *)src, length - sblock_len, (uchar *)dst, key)) {
+		printf("%s %d, fail\n", __FUNCTION__, __LINE__);
+		return -1;
+	}
+
+
+	// handle short block (<16B)
+	if (sblock_len) {
+		// take the last 16B of AES CBC result as input, do AES ECB encrypt
+		sblock_src = (uchar *)src + (length - sblock_len);
+		sblock_dst = (uchar *)dst + (length - sblock_len);
+		//printf("sblock_src: 0x%p, sblock_dst: 0x%p\n", sblock_src, sblock_dst);
+		if (AES_ECB_encrypt((UINT8 *)(sblock_src - 16), 16, sblock_dst, key)) {
+			printf("%s %d, fail\n", __FUNCTION__, __LINE__);
+			return -1;
+		}
+
+		// XOR with short block data to generate final result
+		for (i = 0; i < sblock_len; i++)
+			sblock_dst[i] ^= sblock_src[i];
+	}
+#endif
+
+	return 0;
+}
+
+//#define DUBUG_FW_DESC_TABLE
+#ifdef DUBUG_FW_DESC_TABLE
+void dump_fw_desc_table_v1(fw_desc_table_v1_t *fw_desc_table_v1)
+{
+	if (fw_desc_table_v1 != NULL) {
+		printf("## Fw Desc Table ##############################\n");
+		printf("## fw_desc_table_v1                = 0x%08x\n", fw_desc_table_v1);
+		printf("## fw_desc_table_v1->signature     = %s\n", fw_desc_table_v1->signature);
+		printf("## fw_desc_table_v1->checksum      = 0x%08x\n", fw_desc_table_v1->checksum);
+		printf("## fw_desc_table_v1->version       = 0x%08x\n", fw_desc_table_v1->version);
+		printf("## fw_desc_table_v1->paddings      = 0x%08x\n", fw_desc_table_v1->paddings);
+		printf("## fw_desc_table_v1->part_list_len = 0x%08x\n", fw_desc_table_v1->part_list_len);
+		printf("## fw_desc_table_v1->fw_list_len   = 0x%08x\n", fw_desc_table_v1->fw_list_len);
+		printf("###############################################\n\n");
+	}
+	else {
+		printf("[ERR] %s:%d fw_desc_table_v1 is NULL.\n", __FUNCTION__, __LINE__);
+	}
+}
+
+void dump_part_desc_entry_v1(part_desc_entry_v1_t *part_entry)
+{
+	if (part_entry != NULL) {
+		printf("## Part Desc Entry ############################\n");
+		printf("## part_entry                      = 0x%08x\n", part_entry);
+		printf("## part_entry->type                = 0x%08x\n", part_entry->type);
+		printf("## part_entry->ro                  = 0x%08x\n", part_entry->ro);
+		printf("## part_entry->length              = 0x%08llx\n", part_entry->length);
+		printf("## part_entry->fw_count            = 0x%08x\n", part_entry->fw_count);
+		printf("## part_entry->fw_type             = 0x%08x\n", part_entry->fw_type);
+		printf("###############################################\n\n");
+	}
+	else {
+		printf("[ERR] %s:%d part_entry is NULL.\n", __FUNCTION__, __LINE__);
+	}
+}
+
+void dump_fw_desc_entry_v1(fw_desc_entry_v1_t *fw_entry)
+{
+	if (fw_entry != NULL) {
+		printf("## Fw Desc Entry ##############################\n");
+		printf("## fw_entry                        = 0x%08x\n", fw_entry);
+		printf("## fw_entry->type                  = 0x%08x\n", fw_entry->type);
+		printf("## fw_entry->lzma                  = 0x%08x\n", fw_entry->lzma);
+		printf("## fw_entry->ro                    = 0x%08x\n", fw_entry->ro);
+		printf("## fw_entry->version               = 0x%08x\n", fw_entry->version);
+		printf("## fw_entry->target_addr           = 0x%08x\n", fw_entry->target_addr);
+		printf("## fw_entry->offset                = 0x%08x\n", fw_entry->offset);
+		printf("## fw_entry->length                = 0x%08x\n", fw_entry->length);
+		printf("## fw_entry->paddings              = 0x%08x\n", fw_entry->paddings);
+		printf("## fw_entry->checksum              = 0x%08x\n", fw_entry->checksum);
+		printf("###############################################\n\n");
+	}
+	else {
+		printf("[ERR] %s:%d fw_entry is NULL.\n", __FUNCTION__, __LINE__);
+	}
+}
+
+void dump_fw_desc_entry_v2(fw_desc_entry_v2_t *fw_entry)
+{
+	int i;
+
+	if (fw_entry != NULL) {
+		printf("## Fw Desc Entry ##############################\n");
+		printf("## fw_entry                        = 0x%08x\n", fw_entry);
+		printf("## fw_entry->type                  = 0x%08x\n", fw_entry->type);
+		printf("## fw_entry->lzma                  = 0x%08x\n", fw_entry->lzma);
+		printf("## fw_entry->ro                    = 0x%08x\n", fw_entry->ro);
+		printf("## fw_entry->version               = 0x%08x\n", fw_entry->version);
+		printf("## fw_entry->target_addr           = 0x%08x\n", fw_entry->target_addr);
+		printf("## fw_entry->offset                = 0x%08Lx\n", fw_entry->offset);
+		printf("## fw_entry->length                = 0x%08x\n", fw_entry->length);
+		printf("## fw_entry->paddings              = 0x%08x\n", fw_entry->paddings);
+		printf("## fw_entry->sha_hash              = ");
+		for (i = 0 ; i < 32 ; i++)
+			printf("%02x", fw_entry->sha_hash[i]);
+		printf("\n");
+		printf("###############################################\n\n");
+	}
+	else {
+		printf("[ERR] %s:%d fw_entry is NULL.\n", __FUNCTION__, __LINE__);
+	}
+}
+#endif
+
+//#define DUBUG_BOOT_AV_INFO
+#ifdef DUBUG_BOOT_AV_INFO
+void dump_boot_av_info(boot_av_info_t *boot_av)
+{
+	if (boot_av != NULL) {
+		printf("\n");
+		printf("## Boot AV Info (0x%08x) ##################\n", boot_av);
+		printf("## boot_av->dwMagicNumber          = 0x%08x\n", boot_av->dwMagicNumber);
+		printf("## boot_av->dwVideoStreamAddress   = 0x%08x\n", boot_av->dwVideoStreamAddress);
+		printf("## boot_av->dwVideoStreamLength    = 0x%08x\n", boot_av->dwVideoStreamLength);
+		printf("## boot_av->dwAudioStreamAddress   = 0x%08x\n", boot_av->dwAudioStreamAddress);
+		printf("## boot_av->dwAudioStreamLength    = 0x%08x\n", boot_av->dwAudioStreamLength);
+		printf("## boot_av->bVideoDone             = 0x%08x\n", boot_av->bVideoDone);
+		printf("## boot_av->bAudioDone             = 0x%08x\n", boot_av->bAudioDone);
+		printf("## boot_av->bHDMImode              = 0x%08x\n", boot_av->bHDMImode);
+		printf("## boot_av->dwAudioStreamVolume    = 0x%08x\n", boot_av->dwAudioStreamVolume);
+		printf("## boot_av->dwAudioStreamRepeat    = 0x%08x\n", boot_av->dwAudioStreamRepeat);
+		printf("## boot_av->bPowerOnImage          = 0x%08x\n", boot_av->bPowerOnImage);
+		printf("## boot_av->bRotate                = 0x%08x\n", boot_av->bRotate);
+		printf("## boot_av->dwVideoStreamType      = 0x%08x\n", boot_av->dwVideoStreamType);
+		printf("## boot_av->audio_buffer_addr      = 0x%08x\n", boot_av->audio_buffer_addr);
+		printf("## boot_av->audio_buffer_size      = 0x%08x\n", boot_av->audio_buffer_size);
+		printf("## boot_av->video_buffer_addr      = 0x%08x\n", boot_av->video_buffer_addr);
+		printf("## boot_av->video_buffer_size      = 0x%08x\n", boot_av->video_buffer_size);
+		printf("## boot_av->last_image_addr        = 0x%08x\n", boot_av->last_image_addr);
+		printf("## boot_av->last_image_size        = 0x%08x\n", boot_av->last_image_size);
+		printf("###############################################\n\n");
+	}
+}
+#endif
+
+static void reset_shared_memory(void)
+{
+	boot_av_info_t *boot_av;
+
+	boot_av = (boot_av_info_t *) MIPS_BOOT_AV_INFO_ADDR;
+	if(boot_av-> dwMagicNumber != SWAPEND32(BOOT_AV_INFO_MAGICNO))
+	{
+		/* clear boot_av_info memory */
+		memset(boot_av, 0, sizeof(boot_av_info_t));
+	}
+}
+
+/*
+ * read Efuse.
+ */
+int rtk_get_secure_boot_type(void)
+{
+#ifdef CONFIG_CMD_KEY_BURNING
+	if(OTP_JUDGE_BIT(OTP_BIT_SECUREBOOT))
+		return RTK_SECURE_BOOT;
+#endif
+	//return RTK_SECURE_BOOT;
+	return NONE_SECURE_BOOT;
+}
+
+
+/*
+ * Support boot from NAND or eMMC on squashfs/ext4 partition.
+ */
+#ifdef NAS_ENABLE
+#define NAS_ROOT "/"
+#define NAS_ETC "etc"
+#define NAS_SPI_PARTS "mtdparts=RtkSFC:1024k(Boot)ro,-(FW) "
+int rtk_plat_set_boot_flag_from_part_desc(
+        part_desc_entry_v1_t* part_entry, int part_count)
+{
+#ifndef NAS_DUAL
+    if(boot_mode == BOOT_RESCUE_MODE || boot_mode == BOOT_GOLD_MODE)
+    {
+#if defined(CONFIG_BOOT_FROM_SPI)
+        setenv("nas_part", NAS_SPI_PARTS);
+#endif
+        return RTK_PLAT_ERR_OK;
+    }
+#endif
+
+    const char *nas_root = NAS_ROOT;
+    char *device_path = NULL;
+    if (BOOT_EMMC == boot_flash_type)
+        device_path = "/dev/mmcblk0p";
+    else if (BOOT_NAND == boot_flash_type)
+        device_path = "/dev/mtdblock";
+	else if (BOOT_SATA == boot_flash_type)
+        device_path = "/dev/satablk0p";
+	else if (BOOT_NOR_SERIAL == boot_flash_type) {
+#ifdef CONFIG_BOOT_FROM_SATA
+        device_path = "/dev/satablk0p";
+#elif defined(CONFIG_BOOT_FROM_SPI)
+        device_path = "/dev/sda";
+#endif
+    }
+
+    if (!device_path)
+        return RTK_PLAT_ERR_BOOT;
+
+#ifdef NAS_DUAL
+    if(boot_mode == BOOT_GOLD_MODE)
+        nas_root = "/root";
+#endif
+
+    char *tmp_cmdline = NULL;
+    tmp_cmdline = (char*)malloc(256);
+    if (!tmp_cmdline) {
+        printf("%s: Malloc failed\n", __func__);
+        return RTK_PLAT_ERR_BOOT;
+    }
+    memset(tmp_cmdline, 0, 256);
+
+    unsigned char empty_mount[sizeof(part_entry->mount_point)];
+    memset(empty_mount, 0, sizeof(empty_mount));
+
+#if defined(CONFIG_BOOT_FROM_SPI)
+    // Set mtd Boot partition for read-only access
+    if (BOOT_NOR_SERIAL == boot_flash_type) {
+        strcpy(tmp_cmdline, NAS_SPI_PARTS);
+        strcpy(tmp_cmdline+strlen(tmp_cmdline), "init=/etc/init ");
+        strcpy(tmp_cmdline+strlen(tmp_cmdline), "root=/dev/sda1 rootfstype=squashfs rootwait");
+    }
+#endif
+
+    int i;
+    for(i = 0; i < part_count; i++) {
+        if (memcmp(empty_mount, part_entry[i].mount_point, sizeof(empty_mount)) != 0) {
+            if (0 == strcmp((char *)part_entry[i].mount_point, nas_root)){
+                int minor_num = i;
+#ifdef CONFIG_SYS_RTK_EMMC_FLASH
+                if (BOOT_EMMC == boot_flash_type)
+                    minor_num = part_entry[i].emmc_partIdx;
+#endif
+
+                strcpy(tmp_cmdline+strlen(tmp_cmdline), " init=/etc/init ");
+
+                int cmd_len = strlen(tmp_cmdline);
+                char *rootfstype = "";
+                char *opts = "";
+                switch (part_entry[i].fw_type)
+                {
+                    case FS_TYPE_SQUASH:
+                        rootfstype = "squashfs";
+                        if (BOOT_NAND == boot_flash_type) {
+                            opts = " ubi.mtd=/ ubi.block=0,rootfs";
+                            device_path = "/dev/ubiblock0_";
+                            minor_num = 0;
+                        }
+                        break;
+                    case FS_TYPE_EXT4:
+                        rootfstype = "ext4";
+                        opts = " ro";
+                        break;
+                    case FS_TYPE_UBIFS:
+                        rootfstype = "ubifs";
+                        opts = " rw ubi.mtd=/";
+                        break;
+                    default:
+                        free(tmp_cmdline);
+                        return RTK_PLAT_ERR_PARSE_FW_DESC;
+                }
+
+                if(FS_TYPE_UBIFS == part_entry[i].fw_type){
+                snprintf(tmp_cmdline+cmd_len, 255-cmd_len,
+                        "root=ubi0:rootfs%s rootfstype=%s ",
+                        opts,rootfstype);
+                }
+                else{
+                    snprintf(tmp_cmdline+cmd_len, 255-cmd_len,
+                            "root=%s%d%s rootfstype=%s rootwait ",
+                            device_path,minor_num,opts,rootfstype);
+                }
+                debug("NASROOT found. cmd:%s\n", tmp_cmdline);
+            }
+            else if (0 == strcmp((char *)part_entry[i].mount_point, NAS_ETC)
+                    && FS_TYPE_UBIFS == part_entry[i].fw_type){
+                int cmd_len = strlen(tmp_cmdline);
+                snprintf(tmp_cmdline+cmd_len, 255-cmd_len,
+                        "ubi.mtd=etc ");
+                debug("NASETC found. cmd:%s\n", tmp_cmdline);
+            }
+        }
+    }
+    setenv("nas_part", tmp_cmdline);
+    free(tmp_cmdline);
+
+    return RTK_PLAT_ERR_OK;
+}
+#endif
+
+/*
+ * Use firmware description table to read images from usb.
+ */
+int rtk_plat_read_fw_image_from_USB(int skip)
+{
+#ifdef CONFIG_BOOT_FROM_USB
+	char tmpbuf[128];
+	int ret = RTK_PLAT_ERR_OK;
+	char *filename;
+	unsigned int secure_mode=0;
+
+	secure_mode = rtk_get_secure_boot_type();
+
+	run_command("usb start", 0);	/* "usb start" always return 0 */
+	if (run_command("usb dev", 0) != 0) {
+		printf("No USB device found!\n");
+		return RTK_PLAT_ERR_READ_RESCUE_IMG;
+	}
+
+	if(!skip) /* dtb */
+	{
+		if(boot_mode == BOOT_RESCUE_MODE || boot_mode == BOOT_ANDROID_MODE)
+			filename = rtk_plat_prepare_fw_image_from_USB(FW_TYPE_RESCUE_DT);
+		else
+			filename = rtk_plat_prepare_fw_image_from_USB(FW_TYPE_KERNEL_DT);
+		if(secure_mode == RTK_SECURE_BOOT)
+		{
+			if (rtk_decrypt_rescue_from_usb(filename, getenv_ulong("fdt_loadaddr", 16, 0)))
+			goto loading_failed;
+		}
+		else
+		{
+			sprintf(tmpbuf, "fatload usb 0:1 %s %s", getenv("fdt_loadaddr"), filename);
+			if (run_command(tmpbuf, 0) != 0) {
+				goto loading_failed;
+			}
+		}
+
+		printf("Loading \"%s\" to %s is OK.\n\n", filename, getenv("fdt_loadaddr"));
+	}
+
+	/* Linux kernel */
+	filename = rtk_plat_prepare_fw_image_from_USB(FW_TYPE_KERNEL);
+	if(secure_mode == RTK_SECURE_BOOT)
+	{
+		if (rtk_decrypt_rescue_from_usb(filename,getenv_ulong("kernel_loadaddr", 16, 0)))
+		goto loading_failed;
+	}
+	else
+	{
+		sprintf(tmpbuf, "fatload usb 0:1 %s %s", getenv("kernel_loadaddr"), filename);
+		if (run_command(tmpbuf, 0) != 0) {
+			goto loading_failed;
+		}
+	}
+
+	printf("Loading \"%s\" to %s is OK.\n\n", filename, getenv("kernel_loadaddr"));
+
+	/* rootfs */
+	if(boot_mode == BOOT_RESCUE_MODE || boot_mode == BOOT_ANDROID_MODE)
+		filename = rtk_plat_prepare_fw_image_from_USB(FW_TYPE_RESCUE_ROOTFS);
+	else
+		/* No initrd on NAS normal boot */
+		filename = rtk_plat_prepare_fw_image_from_USB(FW_TYPE_KERNEL_ROOTFS);
+	if(secure_mode == RTK_SECURE_BOOT)
+	{
+		if (rtk_decrypt_rescue_from_usb(filename, getenv_ulong("rootfs_loadaddr", 16, 0)))
+		goto loading_failed;
+	}
+	else
+	{
+		sprintf(tmpbuf, "fatload usb 0:1 %s %s", getenv("rootfs_loadaddr"), filename);
+		if (run_command(tmpbuf, 0) != 0) {
+			goto loading_failed;
+		}
+	}
+
+	printf("Loading \"%s\" to %s is OK.\n\n", filename, getenv("rootfs_loadaddr"));
+
+	/* audio firmware */
+	filename = rtk_plat_prepare_fw_image_from_USB(FW_TYPE_AUDIO);
+	if(secure_mode == RTK_SECURE_BOOT)
+	{
+		if (!rtk_decrypt_rescue_from_usb(filename, MIPS_AUDIO_FW_ENTRY_ADDR))
+		{
+			printf("Loading \"%s\" to 0x%08x is OK.\n", filename, MIPS_AUDIO_FW_ENTRY_ADDR);
+			run_command("go a", 0);
+		}
+		else
+			printf("Loading \"%s\" from USB failed.\n", filename);
+			/* Go on without Audio firmware. */
+	}
+	else
+	{
+		sprintf(tmpbuf, "fatload usb 0:1 0x%08x %s", MIPS_AUDIO_FW_ENTRY_ADDR, filename);
+		if (run_command(tmpbuf, 0) == 0) {
+			printf("Loading \"%s\" to 0x%08x is OK.\n", filename, MIPS_AUDIO_FW_ENTRY_ADDR);
+			run_command("go a", 0);
+		}
+		else {
+			printf("Loading \"%s\" from USB failed.\n", filename);
+			/* Go on without Audio firmware. */
+		}
+    }
+
+	//ret = rtk_call_bootm();
+	ret = rtk_call_booti();
+	/* Should not reach here */
+
+	return ret;
+
+loading_failed:
+	printf("Loading \"%s\" from USB failed.\n", filename);
+	return RTK_PLAT_ERR_READ_RESCUE_IMG;
+
+#endif /* CONFIG_BOOT_FROM_USB */
+
+	return RTK_PLAT_ERR_OK;
+}
+
+
+int rtk_plat_get_dtb_target_address(int dtb_address)
+{
+	if( (CONFIG_FDT_LOADADDR<= dtb_address) && (dtb_address < CONFIG_LOGO_LOADADDR))
+		return dtb_address;
+	else
+		{
+			printf("original DT address=%x\n",dtb_address);
+			return CONFIG_FDT_LOADADDR;
+		}
+}
+
+#ifdef CONFIG_PRELOAD_BOOT_IMAGES
+int rtk_preload_bootimages(void)
+{
+#ifdef CONFIG_RTK_MMC
+	uint block_no=0, img_addr=0, img_size=0;
+#endif
+
+#if  defined(CONFIG_PRELOAD_UBOOT_EMMC_ADDR) && defined(CONFIG_RTK_MMC)
+	block_no = CONFIG_PRELOAD_UBOOT_EMMC_ADDR / EMMC_BLOCK_SIZE;
+	img_addr = getenv_ulong("bootcode2ndtmp_loadaddr", 16, 0);
+	img_size = SZ_1M;
+	printf("%s : load U-Boot 64 from 0x%08x to 0x%08x with size 0x%08x\n", __func__, block_no, img_addr, img_size);
+	if(!rtk_eMMC_read(block_no, img_size, img_addr)) {
+		printf("Error!!!\n");
+		return RTK_PLAT_ERR_READ_FW_IMG;
+	}
+#endif
+#if defined(CONFIG_PRELOAD_KERNEL_EMMC_ADDR) && defined(CONFIG_RTK_MMC)
+	block_no = CONFIG_PRELOAD_KERNEL_EMMC_ADDR / EMMC_BLOCK_SIZE;
+	img_addr = getenv_ulong("kernel_loadaddr", 16, 0);
+	img_size = 7 * SZ_1M;
+	printf("%s : load Kernel from 0x%08x to 0x%08x with size 0x%08x\n", __func__, block_no, img_addr, img_size);
+	if(!rtk_eMMC_read(block_no, img_size, img_addr)) {
+		printf("Error!!!\n");
+		return RTK_PLAT_ERR_READ_FW_IMG;
+	}
+#endif
+#if defined(CONFIG_PRELOAD_DTB_EMMC_ADDR) && defined(CONFIG_RTK_MMC)
+	block_no = CONFIG_PRELOAD_DTB_EMMC_ADDR / EMMC_BLOCK_SIZE;
+	img_addr = getenv_ulong("fdt_loadaddr", 16, 0);
+	img_size = SZ_32K;
+	printf("%s : load Kernel from 0x%08x to 0x%08x with size 0x%08x\n", __func__, block_no, img_addr, img_size);
+	if(!rtk_eMMC_read(block_no, img_size, img_addr)) {
+		printf("Error!!!\n");
+		return RTK_PLAT_ERR_READ_FW_IMG;
+	}
+#endif
+
+	return 0;
+}
+#endif
+
+void GetKeyFromSRAM(unsigned int sram_addr, unsigned char* key, unsigned int length)
+{
+        //#define REG8( addr )		(*(volatile unsigned int*) (addr))
+
+        int i = 0;
+
+        for(i = 0; i < length; i++) {
+            *(key + i) = REG8((uintptr_t)sram_addr + i);
+        }
+}
+
+#if defined(CONFIG_SYS_RTK_EMMC_FLASH) || defined(CONFIG_BOOT_FROM_SPI) || defined(CONFIG_SYS_RTK_NAND_FLASH)
+#ifndef NAS_DUAL
+/* Rescue-ROOTFS has different load addr for B00 compatible. */
+/* B00 rescue-rootfs is preload on DDR before entering LK.   */
+/* LK will then copy img from fw-tbl-addr to final addr.     */
+/* Uboot for A00/01 could just load it on default address.   */
+static unsigned int get_rescue_rootfs_addr(unsigned int fw_tbl_addr)
+{
+	unsigned int final_addr = getenv_ulong("rescue_rootfs_loadaddr", 16, 0);
+
+	if (final_addr == 0)
+		final_addr = CONFIG_RESCUE_ROOTFS_LOADADDR;
+
+	if (fw_tbl_addr != final_addr)
+		printf("change recue-rootfs addr from 0x%08x to 0x%08x\n", fw_tbl_addr, final_addr);
+
+	return final_addr;
+}
+#endif
+#ifdef CONFIG_BFS_SUPPORT_KERNEL_ROOTFS
+static unsigned int get_kernel_rootfs_addr(unsigned int fw_tbl_addr)
+{
+	unsigned int final_addr = getenv_ulong("rootfs_loadaddr", 16, 0);
+
+	if (final_addr == 0)
+		final_addr = CONFIG_ROOTFS_LOADADDR;
+
+	if (fw_tbl_addr != final_addr)
+		printf("change kernel-rootfs addr from 0x%08x to 0x%08x\n", fw_tbl_addr, final_addr);
+
+	return final_addr;
+}
+#endif
+#endif
+
+/*
+ * Use firmware description table to read images from eMMC flash.
+ */
+int rtk_plat_read_fw_image_from_eMMC(
+		uint fw_desc_table_base, part_desc_entry_v1_t* part_entry, int part_count,
+		void* fw_entry, int fw_count,
+		uchar version)
+{
+#ifdef CONFIG_SYS_RTK_EMMC_FLASH
+	void *this_entry;
+	fw_desc_entry_v11_t *v11_entry;
+	//fw_desc_entry_v21_t *v21_entry = NULL;
+	fw_desc_entry_v12_t *v12_entry;
+	//fw_desc_entry_v22_t *v22_entry = NULL;
+	int i, j;
+	uint unit_len;
+	char buf[64];
+	uint fw_checksum = 0;
+#if 0 // mark secure boot
+	char str_phash[256];
+#if defined(Config_Secure_RSA_TRUE)
+	char *checksum, *signature;
+#endif
+	char sha1_hash[SHA1_SIZE];
+	char *hash_str;
+#endif
+	unsigned int secure_mode;
+	unsigned char ks[16],kh[16],kimg[16];
+	unsigned char aes_key[16];
+	unsigned char rsa_key[256];
+	unsigned char sha_hash[32];
+#ifdef CONFIG_CMD_KEY_BURNING
+	unsigned int * Kh_key_ptr = NULL;
+#else
+	unsigned int * Kh_key_ptr = (unsigned int *)(uintptr_t) Kh_key_default;
+#endif
+	unsigned int img_truncated_size; // install_a will append 256-byte signature data to it
+	unsigned int vo_secure_addr;
+	int ret;
+	boot_av_info_t *boot_av;
+//	uint source_addr;
+//	uint target_addr;
+	uint block_no;
+	MEM_LAYOUT_WHEN_READ_IMAGE_T mem_layout;
+	uint imageSize = 0;
+	uint decompressedSize = 0;
+
+	// extern variable
+	extern unsigned int mcp_dscpt_addr;
+	mcp_dscpt_addr = 0;
+
+	secure_mode = rtk_get_secure_boot_type();
+	img_truncated_size = RSA_SIGNATURE_LENGTH*2+NP_INV32_LENGTH;
+
+	unsigned char str[16];// old array size is 5, change to 16. To avoid the risk in memory overlap.
+
+	uchar entry_type = 0;
+	uchar entry_lzma = 0;
+	uint entry_target_addr = 0;
+	u64 entry_offset = 0;
+	uint entry_length = 0;
+
+	/* find fw_entry structure according to version */
+	switch (version)
+	{
+		case FW_DESC_TABLE_V1_T_VERSION_1:
+			unit_len = sizeof(fw_desc_entry_v1_t);
+			break;
+
+		case FW_DESC_TABLE_V1_T_VERSION_11:
+			unit_len = sizeof(fw_desc_entry_v11_t);
+			break;
+
+		case FW_DESC_TABLE_V1_T_VERSION_21:
+			unit_len = sizeof(fw_desc_entry_v21_t);
+			break;
+
+		case FW_DESC_TABLE_V2_T_VERSION_2:
+			unit_len = sizeof(fw_desc_entry_v2_t);
+			break;
+
+		case FW_DESC_TABLE_V2_T_VERSION_12:
+			unit_len = sizeof(fw_desc_entry_v12_t);
+			break;
+
+		case FW_DESC_TABLE_V2_T_VERSION_22:
+			unit_len = sizeof(fw_desc_entry_v22_t);
+			break;
+
+		default:
+			return RTK_PLAT_ERR_READ_FW_IMG;
+	}
+
+#if 0 // mark secure boot
+#if defined(Config_Secure_RSA_TRUE)
+	checksum = (char *)alloc_freemem(sizeof(v21_entry->RSA_sign));
+	signature = (char *)alloc_freemem(sizeof(v21_entry->RSA_sign)+1);
+
+	// set RSA key to env variable
+	if (env_split_and_save("RSA_KEY_MODULUS", Config_Secure_RSA_MODULUS, 96) != OK)
+		return NULL;
+#endif
+
+
+	if (secure_mode == RTK_SECURE_BOOT)
+	{
+		// set AES img key to env variable
+		setenv( "AES_IMG_KEY", SECURE_KH_KEY_STR);
+	}
+
+	//	memset(str_phash, 0, 256);
+#endif
+	/* clear boot_av_info memory */
+	boot_av = (boot_av_info_t *) MIPS_BOOT_AV_INFO_ADDR;
+	memset(boot_av, 0, sizeof(boot_av_info_t));
+
+
+	/* parse each fw_entry */
+	for (i = 0; i < fw_count; i++)
+	{
+		EXECUTE_CUSTOMIZE_FUNC(0); // insert execute customer callback at here
+
+		this_entry = (fw_entry + unit_len * i);
+		FW_ENTRY_MEMBER_GET(entry_target_addr, this_entry, target_addr, version);
+		FW_ENTRY_MEMBER_GET(entry_type, this_entry, type, version);
+		FW_ENTRY_MEMBER_GET(entry_length, this_entry, length, version);
+		FW_ENTRY_MEMBER_GET(entry_offset, this_entry, offset, version);
+		FW_ENTRY_MEMBER_GET(entry_lzma, this_entry, lzma, version);
+
+		if (1 == accelerate_state && entry_type != FW_TYPE_AUDIO && entry_type != FW_TYPE_IMAGE_FILE)
+			continue;
+		else if (2 == accelerate_state && (entry_type == FW_TYPE_AUDIO || entry_type == FW_TYPE_IMAGE_FILE))
+			continue;
+		if (audio_fw_state && (entry_type == FW_TYPE_AUDIO || entry_type == FW_TYPE_GOLD_AUDIO))
+			continue;
+		/*The condition for decision the order of loading FW*/
+
+		if ( entry_type == FW_TYPE_AUDIO || entry_type == FW_TYPE_GOLD_AUDIO)
+			Auto_AFW_MEM_START = entry_target_addr;
+		/* Save the address of AFW from fw_desc */
+
+		if (entry_target_addr)
+		{
+#ifndef NAS_DUAL
+			if (boot_mode == BOOT_RESCUE_MODE || boot_mode == BOOT_ANDROID_MODE)
+			{
+				switch(entry_type)
+				{
+					case FW_TYPE_KERNEL:
+						memset(str, 0, sizeof(str));
+						sprintf((char *)str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("kernel_loadaddr", (char *) str);
+						printf("Kernel:\n");
+						break;
+
+					case FW_TYPE_RESCUE_DT:
+						entry_target_addr = rtk_plat_get_dtb_target_address(entry_target_addr);
+						FW_ENTRY_MEMBER_SET(entry_target_addr, this_entry, target_addr, version);
+						//printf("entry_target_addr =%x\n",entry_target_addr);
+						memset(str, 0, sizeof(str));
+						sprintf((char *) str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("fdt_loadaddr",(char *) str);
+						printf("Rescue DT:\n");
+						break;
+
+					case FW_TYPE_RESCUE_ROOTFS:
+						printf("Rescue ROOTFS:\n");
+						if(boot_mode == BOOT_BIST_MODE)
+                            entry_target_addr = BIST_ROOTFS_ADDR;
+                        else
+						    entry_target_addr = get_rescue_rootfs_addr(entry_target_addr);
+#ifdef NAS_ENABLE
+						initrd_size = entry_length;
+						if(secure_mode != NONE_SECURE_BOOT)
+						{
+							initrd_size -= img_truncated_size;
+							/* Pad 1 ~ 64 bytes by do_sha256 */
+							initrd_size -= 64;
+						}
+#endif
+						break;
+
+					case FW_TYPE_TEE:
+#ifdef CONFIG_TEE
+						printf("TEE:\n");
+						tee_enable=1;
+						break;
+#else
+						continue;
+#endif
+					case FW_TYPE_AUDIO:
+						if(boot_mode == BOOT_KERNEL_ONLY_MODE)
+							continue;
+						else
+						{
+							ipc_shm.audio_fw_entry_pt = CPU_TO_BE32(entry_target_addr | MIPS_KSEG0BASE);
+							printf("Audio FW:\n");
+						}
+						break;
+                    case FW_TYPE_IMAGE_FILE:
+						printf("IMAGE FILE:\n");
+						entry_target_addr = getenv_ulong("blue_logo_loadaddr", 16, BOOT_LOGO_ADDR);
+						vo_secure_addr = entry_target_addr + BOOT_LOGO_SIZE - 0x100000;
+						memset((void *)(uintptr_t)vo_secure_addr, 0x0, sizeof(char)*VO_SECURE_SIZE);
+						printf("Address for boot logo from %x to %x will be reserved.\n", (unsigned int)entry_target_addr,
+							(unsigned int)(entry_target_addr + BOOT_LOGO_SIZE));
+						/* assign boot_av structure */
+						boot_av->dwMagicNumber = SWAPEND32(BOOT_AV_INFO_MAGICNO);
+						if(boot_logo_enable)
+						{
+							boot_av-> logo_enable = boot_logo_enable;
+							boot_av-> logo_addr = CPU_TO_BE32(entry_target_addr);
+							boot_av-> src_width = CPU_TO_BE32(custom_logo_src_width);
+							boot_av-> src_height = CPU_TO_BE32(custom_logo_src_height);
+							boot_av-> dst_width = CPU_TO_BE32(custom_logo_dst_width);
+							boot_av-> dst_height = CPU_TO_BE32(custom_logo_dst_height);
+							boot_av-> vo_secure_addr = CPU_TO_BE32((unsigned int)(uintptr_t)vo_secure_addr);
+						}
+
+						break;
+
+					default:
+						//printf("Unknown FW (%d):\n", entry_type);
+						continue;
+				}
+			}
+			else if(boot_mode == BOOT_GOLD_MODE)
+			{
+				switch(entry_type)
+				{
+					case FW_TYPE_GOLD_KERNEL:
+						//entry_offset=entry_offset-1; //let load gold_fw fail, and it can test enter to USB mode
+						memset(str, 0, sizeof(str));
+						sprintf((char *) str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("kernel_loadaddr",(char *) str);
+						printf("GOLD Kernel:\n");
+						break;
+					case FW_TYPE_GOLD_RESCUE_DT:
+						entry_target_addr = rtk_plat_get_dtb_target_address(entry_target_addr);
+						FW_ENTRY_MEMBER_SET(entry_target_addr, this_entry, target_addr, version);
+						//printf("entry_target_addr =%x\n",entry_target_addr);
+						memset(str, 0, sizeof(str));
+						sprintf((char *) str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("fdt_loadaddr",(char *) str);
+						printf("GOLD Rescue DT:\n");
+						break;
+					case FW_TYPE_GOLD_RESCUE_ROOTFS:
+						printf("GOLD Rescue ROOTFS:\n");
+						entry_target_addr = get_rescue_rootfs_addr(entry_target_addr);
+						break;
+					case FW_TYPE_GOLD_AUDIO:
+						if(boot_mode == BOOT_KERNEL_ONLY_MODE)
+							continue;
+						else
+						{
+							ipc_shm.audio_fw_entry_pt = CPU_TO_BE32(entry_target_addr | MIPS_KSEG0BASE);
+							printf("GOLD Audio FW:\n");
+						}
+						break;
+					default:
+						//printf("Unknown FW (%d):\n", entry_type);
+						continue;
+				}
+			}
+			else
+#endif // NAS_DUAL
+			{
+				switch(entry_type)
+				{
+					case FW_TYPE_BOOTCODE:
+						printf("Boot Code:\n");
+						break;
+
+					case FW_TYPE_KERNEL:
+						//entry_offset=entry_offset-1; //let load fw fail, and it can test enter to gold mode
+						memset(str, 0, sizeof(str));
+						sprintf((char *) str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("kernel_loadaddr",(char *) str);
+						printf("Kernel:\n");
+						break;
+
+					case FW_TYPE_KERNEL_DT:
+						entry_target_addr = rtk_plat_get_dtb_target_address(entry_target_addr);
+						FW_ENTRY_MEMBER_SET(entry_target_addr, this_entry, target_addr, version);
+						//printf("entry_target_addr =%x\n",entry_target_addr);
+						memset(str, 0, sizeof(str));
+						sprintf((char *) str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("fdt_loadaddr",(char *) str);
+						printf("DT:\n");
+						break;
+
+					case FW_TYPE_KERNEL_ROOTFS:
+						printf("ROOTFS:\n");
+						break;
+
+					case FW_TYPE_TEE:
+#ifdef CONFIG_TEE
+						printf("TEE:\n");
+						tee_enable=1;
+						break;
+#else
+						continue;
+#endif
+
+					case FW_TYPE_AUDIO:
+						if(boot_mode == BOOT_KERNEL_ONLY_MODE)
+							continue;
+						else
+						{
+							ipc_shm.audio_fw_entry_pt = CPU_TO_BE32(entry_target_addr | MIPS_KSEG0BASE);
+							printf("Audio FW:\n");
+						}
+						break;
+
+					case FW_TYPE_JFFS2:
+						printf("JFFS2 Image:\n");
+						break;
+
+					case FW_TYPE_SQUASH:
+						printf("Squash Image:\n");
+						break;
+
+					case FW_TYPE_EXT3:
+						printf("EXT3 Image:\n");
+						break;
+
+					case FW_TYPE_ODD:
+						printf("ODD Image:\n");
+						break;
+
+					case FW_TYPE_YAFFS2:
+						printf("YAFFS2 Image:\n");
+						break;
+
+					case FW_TYPE_AUDIO_FILE:
+						//entry_target_addr = (POWER_ON_MUSIC_STREAM_ADDR | MIPS_KSEG0BASE);
+
+						/* if enable boot music, need to assign boot_av structure */
+						//boot_av->dwMagicNumber = SWAPEND32(BOOT_AV_INFO_MAGICNO);
+						//boot_av->dwAudioStreamAddress = SWAPEND32(entry_target_addr);
+						//boot_av->dwAudioStreamLength = SWAPEND32(entry_length);
+						//boot_av->dwAudioStreamVolume = (-17);
+						break;
+
+					case FW_TYPE_VIDEO_FILE:
+
+						/* if enable boot video/jpeg, need to assign boot_av structure */
+						//boot_av->dwMagicNumber = SWAPEND32(BOOT_AV_INFO_MAGICNO);
+						//boot_av->dwVideoStreamAddress = SWAPEND32(entry_target_addr);
+						//boot_av->bPowerOnImage = 0;
+						//boot_av->dwVideoStreamLength = SWAPEND32(entry_length);
+						break;
+
+					case FW_TYPE_IMAGE_FILE:
+#ifdef NAS_ENABLE
+						entry_target_addr = getenv_ulong("logo_loadaddr", 16, BOOT_LOGO_ADDR);
+#else
+						entry_target_addr = getenv_ulong("blue_logo_loadaddr", 16, BOOT_LOGO_ADDR);
+#endif
+						printf("IMAGE FILE:\n");
+						vo_secure_addr = entry_target_addr + BOOT_LOGO_SIZE - 0x100000;
+						memset((void *)(uintptr_t)vo_secure_addr, 0x0, sizeof(char)*VO_SECURE_SIZE);
+						printf("Address for boot logo from %x to %x will be reserved.\n", (unsigned int)entry_target_addr,
+							(unsigned int)(entry_target_addr + BOOT_LOGO_SIZE));
+						/* assign boot_av structure */
+						boot_av->dwMagicNumber = SWAPEND32(BOOT_AV_INFO_MAGICNO);
+						if(boot_logo_enable)
+						{
+							boot_av-> logo_enable = boot_logo_enable;
+							boot_av-> logo_addr = CPU_TO_BE32(entry_target_addr);
+							boot_av-> src_width = CPU_TO_BE32(custom_logo_src_width);
+							boot_av-> src_height = CPU_TO_BE32(custom_logo_src_height);
+							boot_av-> dst_width = CPU_TO_BE32(custom_logo_dst_width);
+							boot_av-> dst_height = CPU_TO_BE32(custom_logo_dst_height);
+							boot_av-> vo_secure_addr = CPU_TO_BE32((unsigned int)(uintptr_t)vo_secure_addr);
+						}
+
+						break;
+
+					case FW_TYPE_UBOOT: // 2nd stage bootcode
+#if defined CONFIG_SECOND_BOOTCODE_SUPPORT && defined CONFIG_GOLDENBOOT_SUPPORT
+						// due to 2nd bootcode run at the same ADDR as 1st, load to other place first
+						printf("Support BootCode64\n");
+						continue;
+						memset(str, 0, sizeof(str));
+						sprintf(str, "%x", CONFIG_BOOTCODE_2ND_TMP_ADDR);
+						setenv("bootcode2ndtmp_loadaddr", str);
+
+						memset(str, 0, sizeof(str));
+						sprintf(str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("bootcode2nd_loadaddr", str);
+						printf("2nd BootCode:\n");
+
+						FW_ENTRY_MEMBER_SET(CONFIG_BOOTCODE_2ND_TMP_ADDR, this_entry, target_addr, version);
+#else
+						printf("%s, 2nd bootloader not support!\n", __func__);
+#endif
+						break;
+
+					case FW_TYPE_HYP:
+						memset(str, 0, sizeof(str));
+						sprintf((char *) str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("hyp_loadaddr",(char *) str);
+						printf("Hypervisor:\n");
+						break;
+
+					default:
+						//printf("Unknown FW (%d):\n", entry_type);
+						continue;
+				}
+			}
+#ifdef CONFIG_RTD1395
+			// at 1395, audio fw belong to trusted fw and need to be loaded by FSBL
+			if (entry_type == FW_TYPE_AUDIO || entry_type == FW_TYPE_GOLD_AUDIO) {
+				printf("\t FW Image preload on 0x%08x, size=0x%08x (0x%08x)\n",
+					entry_target_addr, entry_length, entry_target_addr + entry_length);
+				continue;
+			}
+#endif
+#ifdef EMMC_BLOCK_LOG
+			printf("\t FW Image to 0x%08x ~ 0x%08x, size=0x%08x, 0x%x blocks\n",
+					entry_target_addr,
+					entry_target_addr + entry_length,
+					entry_length,
+					(entry_length%EMMC_BLOCK_SIZE)?(entry_length/EMMC_BLOCK_SIZE)+1:(entry_length/EMMC_BLOCK_SIZE));
+			printf("\t FW Image fr 0x%08Lx, blk 0x%x\n",
+					entry_offset,
+					(eMMC_fw_desc_table_start + entry_offset)/EMMC_BLOCK_SIZE);
+#else
+			printf("\t FW Image to 0x%08x, size=0x%08x (0x%08x)\n",
+					entry_target_addr, entry_length, entry_target_addr + entry_length);
+			printf("\t FW Image fr 0x%08Lx \n", entry_offset);
+#endif
+
+			WATCHDOG_KICK();
+
+				/* secure mode and lzma will only apply to fw image */
+				if (entry_type == FW_TYPE_KERNEL ||
+					entry_type == FW_TYPE_KERNEL_ROOTFS ||
+					entry_type == FW_TYPE_RESCUE_ROOTFS ||
+					entry_type == FW_TYPE_AUDIO ||
+					entry_type == FW_TYPE_GOLD_KERNEL ||
+                    			entry_type == FW_TYPE_GOLD_RESCUE_ROOTFS ||
+                    			entry_type == FW_TYPE_GOLD_AUDIO)
+				{
+					/* get memory layout before copy fw image */
+					mem_layout.bIsEncrypted = (secure_mode != NONE_SECURE_BOOT);
+					mem_layout.bIsCompressed = entry_lzma;
+					mem_layout.image_target_addr = entry_target_addr & (~MIPS_KSEG_MSK);
+				}
+				else
+				{
+					/* get memory layout before copy other image */
+					mem_layout.bIsEncrypted = 0;
+					mem_layout.bIsCompressed = 0;
+
+					mem_layout.image_target_addr = entry_target_addr;
+				}
+
+				get_mem_layout_when_read_image(&mem_layout);
+
+				imageSize = entry_length;
+
+				// 512B aligned
+				if (imageSize&(EMMC_BLOCK_SIZE-1)) {
+					imageSize &= ~(EMMC_BLOCK_SIZE-1);
+					imageSize += EMMC_BLOCK_SIZE;
+				}
+
+				block_no = entry_offset / EMMC_BLOCK_SIZE;
+
+				if (!rtk_eMMC_read(block_no, imageSize, (uint *)(uintptr_t)mem_layout.flash_to_ram_addr))
+				{
+					printf("[ERR] Read fw error (type:%d)!\n", entry_type);
+
+					return RTK_PLAT_ERR_READ_FW_IMG;
+				}
+#ifndef BYPASS_CHECKSUM
+				/* Check checksum */
+				if (FW_DESC_BASE_VERSION(version) == FW_DESC_TABLE_V1_T_VERSION_1) {
+					fw_checksum = get_checksum((uchar *)(uintptr_t)mem_layout.flash_to_ram_addr, entry_length);
+					if (((fw_desc_entry_v1_t*)this_entry)->checksum != fw_checksum &&
+						secure_mode!= RTK_SECURE_BOOT) {
+						printf("\t FW Image checksum FAILED\n");
+						printf("\t FW Image entry  checksum=0x%08x\n",
+							((fw_desc_entry_v1_t*)this_entry)->checksum);
+						printf("\t FW Image result checksum=0x%08x\n", fw_checksum);
+						return RTK_PLAT_ERR_READ_FW_IMG;
+					}
+				} else if (FW_DESC_BASE_VERSION(version) == FW_DESC_TABLE_V2_T_VERSION_2) {
+					SHA256_hash((uchar *)(uintptr_t)mem_layout.flash_to_ram_addr, entry_length, sha_hash, NULL);
+					if ((memcmp(((fw_desc_entry_v2_t*)this_entry)->sha_hash, sha_hash, SHA256_SIZE) != 0) &&
+						secure_mode!= RTK_SECURE_BOOT) {
+						printf("\t FW Image sha FAILED\n");
+						printf("\t FW Image entry sha256==>\n");
+						for (j = 0 ; j < 32 ; j++)
+							printf("%02x ", ((fw_desc_entry_v2_t*)this_entry)->sha_hash[j]);
+						printf("\n\t FW Image result sha256==>\n");
+						for (j = 0 ; j < 32 ; j++)
+							printf("%02x ", sha_hash[j]);
+						printf("\n");
+						return RTK_PLAT_ERR_READ_FW_IMG;
+					}
+				}
+#endif
+				/* if secure mode, do AES CBC decrypt */
+				if (mem_layout.bIsEncrypted)
+				{
+					if (secure_mode == RTK_SECURE_BOOT)
+					{
+					    unsigned int real_body_size = 0;
+						//rtk_hexdump("the first 32-byte encrypted data", (unsigned char *)mem_layout.encrpyted_addr, 32);
+						//rtk_hexdump("the last 512-byte encrypted data", (unsigned char *)(ENCRYPTED_LINUX_KERNEL_ADDR+entry_length-512), 512);
+
+                        memset(ks,0x00,16);
+                        memset(kh,0x00,16);
+                        memset(kimg,0x00,16);
+
+                        memset(aes_key, 0x00, 16);
+                        memset(rsa_key, 0x00, 256);
+
+                        switch(entry_type)
+                        {
+                            case FW_TYPE_KERNEL:
+                            case FW_TYPE_RESCUE_ROOTFS:
+                            case FW_TYPE_KERNEL_ROOTFS:
+                            case FW_TYPE_AUDIO:
+                            case FW_TYPE_GOLD_KERNEL:
+                            case FW_TYPE_GOLD_RESCUE_ROOTFS:
+                            case FW_TYPE_GOLD_AUDIO:
+                                GetKeyFromSRAM(KH_P_SRAM_ADDR, aes_key, AES_KEY_SIZE);
+                                GetKeyFromSRAM(RSA_KEY_FW_SRAM_ADDR, rsa_key, RSA_KEY_SIZE);
+                                flush_cache((unsigned long) aes_key, AES_KEY_SIZE);
+                                flush_cache((unsigned long) aes_key, RSA_KEY_SIZE);
+                                sync();
+                                //rtk_hexdump("kh_p : ", aes_key, AES_KEY_SIZE);
+                                //rtk_hexdump("rsa_key_fw : ", rsa_key, RSA_KEY_SIZE);
+                                break;
+                            case FW_TYPE_TEE:
+                                GetKeyFromSRAM(KX_P_SRAM_ADDR, aes_key, AES_KEY_SIZE);
+                                GetKeyFromSRAM(RSA_KEY_TEE_SRAM_ADDR, rsa_key, RSA_KEY_SIZE);
+                                flush_cache((unsigned long) aes_key, AES_KEY_SIZE);
+                                flush_cache((unsigned long) aes_key, RSA_KEY_SIZE);
+                                sync();
+                                //rtk_hexdump("kx_p : ", aes_key, 16);
+                                //rtk_hexdump("rsa_key_tee : ", rsa_key, RSA_KEY_SIZE);
+                                break;
+                            default:
+                                break;
+                        }
+
+#ifdef CONFIG_CMD_KEY_BURNING
+                        OTP_Get_Byte(OTP_K_S, ks, 16);
+                        OTP_Get_Byte(OTP_K_H, kh, 16);
+                        sync();
+						flush_cache((unsigned int) (uintptr_t)ks, 16);
+						flush_cache((unsigned int) (uintptr_t)kh, 16);
+#endif
+                        AES_ECB_encrypt(ks, 16, kimg,(unsigned int *) kh);
+						flush_cache((unsigned long) kimg, 16);
+                        sync();
+
+                        Kh_key_ptr = (unsigned int *) kimg;
+                        Kh_key_ptr = (unsigned int *) aes_key;
+                        //Kh_key_ptr[0] = swap_endian(Kh_key_ptr[0]);
+                        //Kh_key_ptr[1] = swap_endian(Kh_key_ptr[1]);
+                        //Kh_key_ptr[2] = swap_endian(Kh_key_ptr[2]);
+                        //Kh_key_ptr[3] = swap_endian(Kh_key_ptr[3]);
+						flush_cache((unsigned long) aes_key, 16);
+
+						// decrypt image
+						printf("to decrypt...\n");
+
+						flush_cache((unsigned int) mem_layout.encrpyted_addr, entry_length);
+
+						if (decrypt_image((char *)(uintptr_t)mem_layout.encrpyted_addr,
+							(char *)(uintptr_t)mem_layout.decrypted_addr,
+							entry_length  - img_truncated_size,
+							Kh_key_ptr))
+						{
+							printf("decrypt image(%d) error!\n", entry_type);
+							return RTK_PLAT_ERR_READ_FW_IMG;
+						}
+
+						sync();
+                        memset(ks,0x00,16);
+                        memset(kh,0x00,16);
+                        memset(kimg,0x00,16);
+
+						//rtk_hexdump("the first 32-byte decrypted data", (unsigned char *)mem_layout.decrypted_addr, 32);
+
+						//reverse_signature( (unsigned char *)(mem_layout.decrypted_addr + imageSize - img_truncated_size) );
+
+                        copy_memory( (void *)(uintptr_t)(mem_layout.decrypted_addr + entry_length - img_truncated_size), (void *)(uintptr_t)(mem_layout.encrpyted_addr + entry_length - img_truncated_size), img_truncated_size);
+                        flush_cache((unsigned int) mem_layout.decrypted_addr, entry_length);
+
+                        real_body_size = (UINT32)(REG32( (uintptr_t)(mem_layout.decrypted_addr + (entry_length - img_truncated_size) - 4) ));
+                        real_body_size = swap_endian(real_body_size);
+                    	real_body_size /= 8;
+
+						flush_cache((unsigned int) mem_layout.decrypted_addr, entry_length);
+						ret = Verify_SHA256_hash( (unsigned char *)(uintptr_t)mem_layout.decrypted_addr,
+												  real_body_size,
+												  (unsigned char *)(uintptr_t)(mem_layout.decrypted_addr + entry_length - img_truncated_size),
+												  1, rsa_key);
+						if( ret < 0 ) {
+							printf("[ERR] %s: verify hash fail(%d)\n", __FUNCTION__, ret );
+							return RTK_PLAT_ERR_READ_FW_IMG;
+						}
+
+						//imageSize = imageSize - img_truncated_size - SHA256_SIZE;
+					}
+				}
+
+				/* if lzma type, decompress image */
+				if (mem_layout.bIsCompressed)
+				{
+					#ifndef CONFIG_FT_RESCUE
+					if (lzmaBuffToBuffDecompress((uchar*)(uintptr_t)mem_layout.decompressed_addr, (SizeT *)&decompressedSize, (uchar*)(uintptr_t)mem_layout.compressed_addr, imageSize) != 0)
+					{
+						printf("[ERR] %s:Decompress using LZMA error!!\n", __FUNCTION__);
+
+						return RTK_PLAT_ERR_READ_FW_IMG;
+					}
+					#endif //CONFIG_FT_RESCUE
+				}
+		}
+	}
+
+#ifdef NAS_ENABLE
+	if(1 != accelerate_state)
+		rtk_plat_set_boot_flag_from_part_desc(part_entry, part_count);
+#endif
+
+	if (accelerate_state)
+		accelerate_state++;
+	/*The accelerate_flag for faster blue logo*/
+
+		if (version == FW_DESC_TABLE_V1_T_VERSION_11)
+		{
+			v11_entry = (fw_desc_entry_v11_t*) (fw_entry + unit_len * i);
+
+			if (v11_entry->act_size != 0)
+			{
+				// string format: "part_num:act_size:hash,"
+				memset(buf, 0, sizeof(buf));
+				sprintf(buf, "%d:%d:", v11_entry->part_num, v11_entry->act_size);
+//				strncat(str_phash, buf, strlen(buf));
+				memset(buf, 0, sizeof(buf));
+				memcpy(buf, v11_entry->hash, sizeof(v11_entry->hash));
+				buf[sizeof(v11_entry->hash)] = ',';
+//				strncat(str_phash, buf, strlen(buf));
+			}
+		}
+		else if (version == FW_DESC_TABLE_V1_T_VERSION_21)
+		{
+			//v21_entry = (fw_desc_entry_v21_t *)this_entry;
+
+#if defined(Config_Secure_RSA_TRUE)
+			// exclude partition 0 (contain bootcode/kernel/audio/video image)
+			if ( (v21_entry->part_num != PART_TYPE_RESERVED) &&
+				(v21_entry->act_size != 0) ){
+				// recover hash value from signature
+				memset(checksum, 0, sizeof(v21_entry->RSA_sign));
+				memset(signature, 0, sizeof(v21_entry->RSA_sign)+1);
+				memcpy(signature, v21_entry->RSA_sign, sizeof(v21_entry->RSA_sign));
+
+				rsa_verify(signature, Config_Secure_RSA_MODULUS, checksum);
+
+				// string format: "part_num:act_size:hash,"
+				memset(buf, 0, sizeof(buf));
+				sprintf(buf, "%d:%d:%s,", v21_entry->part_num, v21_entry->act_size, checksum);
+//				strncat(str_phash, buf, strlen(buf));
+				//printf("[DEBUG_MSG] part_num:%x, act_size:%x, recovered hash:%s\n", v21_entry->part_num, v21_entry->act_size, checksum);
+			}
+#endif	/* defined(Config_Secure_RSA_TRUE) */
+		}
+		else if (version == FW_DESC_TABLE_V2_T_VERSION_12)
+		{
+			v12_entry = (fw_desc_entry_v12_t*) (fw_entry + unit_len * i);
+
+			if (v12_entry->act_size != 0)
+			{
+				// string format: "part_num:act_size:hash,"
+				memset(buf, 0, sizeof(buf));
+				sprintf(buf, "%d:%d:", v12_entry->part_num, v12_entry->act_size);
+//				strncat(str_phash, buf, strlen(buf));
+				memset(buf, 0, sizeof(buf));
+				memcpy(buf, v12_entry->hash, sizeof(v12_entry->hash));
+				buf[sizeof(v12_entry->hash)] = ',';
+//				strncat(str_phash, buf, strlen(buf));
+			}
+		}
+		else if (version == FW_DESC_TABLE_V2_T_VERSION_22)
+		{
+			//v22_entry = (fw_desc_entry_v22_t *)this_entry;
+
+#if defined(Config_Secure_RSA_TRUE)
+			// exclude partition 0 (contain bootcode/kernel/audio/video image)
+			if ( (v22_entry->part_num != PART_TYPE_RESERVED) &&
+				(v22_entry->act_size != 0) ){
+				// recover hash value from signature
+				memset(checksum, 0, sizeof(v22_entry->RSA_sign));
+				memset(signature, 0, sizeof(v22_entry->RSA_sign)+1);
+				memcpy(signature, v22_entry->RSA_sign, sizeof(v22_entry->RSA_sign));
+
+				rsa_verify(signature, Config_Secure_RSA_MODULUS, checksum);
+
+				// string format: "part_num:act_size:hash,"
+				memset(buf, 0, sizeof(buf));
+				sprintf(buf, "%d:%d:%s,", v22_entry->part_num, v22_entry->act_size, checksum);
+//				strncat(str_phash, buf, strlen(buf));
+				//printf("[DEBUG_MSG] part_num:%x, act_size:%x, recovered hash:%s\n", v22_entry->part_num, v22_entry->act_size, checksum);
+			}
+#endif	/* defined(Config_Secure_RSA_TRUE) */
+		}
+
+
+	//printf("Many message are v21 part %d  v22 part %d \n",v21_entry->part_num,v22_entry->part_num);
+
+
+	/* set boot_av_info_ptr */
+	if (boot_av->dwMagicNumber == SWAPEND32(BOOT_AV_INFO_MAGICNO))
+	{
+		boot_av->bHDMImode = sys_logo_is_HDMI;// ignored.
+
+		// enable audio sound
+		if (boot_av->dwAudioStreamLength != 0)
+		{
+			;
+		}
+
+		ipc_shm.pov_boot_av_info = SWAPEND32((uint)(uintptr_t) boot_av);
+
+		#ifdef DUBUG_BOOT_AV_INFO
+		dump_boot_av_info(boot_av);
+		#endif
+	}
+
+	/* Flush caches */
+	flush_dcache_all();
+
+#endif /* CONFIG_SYS_RTK_EMMC_FLASH */
+
+	return RTK_PLAT_ERR_OK;
+}
+
+/*
+ * Use firmware description table to read images from NAND flash.
+ */
+int rtk_plat_read_fw_image_from_NAND(
+		uint fw_desc_table_base, part_desc_entry_v1_t* part_entry, int part_count,
+		void* fw_entry, int fw_count,
+		uchar version)
+{
+	int ret = RTK_PLAT_ERR_OK;
+#ifdef CONFIG_SYS_RTK_NAND_FLASH
+	void *this_entry;
+	int i, j;
+	uint unit_len;
+	uint fw_checksum = 0;
+	unsigned int secure_mode;
+	unsigned char sha_hash[32];
+	boot_av_info_t *boot_av;
+	MEM_LAYOUT_WHEN_READ_IMAGE_T mem_layout;
+	uint imageSize = 0;
+	uint decompressedSize = 0;
+
+	struct mtd_info *mtd = &nand_info[nand_curr_device];
+	size_t rwsize;
+	unsigned char empty_mount[sizeof(part_entry->mount_point)] = {0};
+	char buf[64];
+	char tmp[16];
+	char *tmp_cmdline = NULL;
+	u64 size;
+	char str[16];// old array size is 5, change to 16. To avoid the risk in memory overlap.
+
+	uchar entry_type = 0;
+	uchar entry_lzma = 0;
+	uint entry_target_addr = 0;
+	u64 entry_offset = 0;
+	uint entry_length = 0;
+
+	secure_mode = rtk_get_secure_boot_type();
+
+	/* find fw_entry structure according to version */
+	switch (version)
+	{
+		case FW_DESC_TABLE_V1_T_VERSION_1:
+			unit_len = sizeof(fw_desc_entry_v1_t);
+			break;
+
+		case FW_DESC_TABLE_V2_T_VERSION_2:
+			unit_len = sizeof(fw_desc_entry_v2_t);
+			break;
+
+		default:
+			return RTK_PLAT_ERR_READ_FW_IMG;
+	}
+
+
+	/* clear boot_av_info memory */
+	boot_av = (boot_av_info_t *) MIPS_BOOT_AV_INFO_ADDR;
+	memset(boot_av, 0, sizeof(boot_av_info_t));
+
+	/* Add mtd_part env var */
+	if(boot_mode != BOOT_RESCUE_MODE && boot_mode != BOOT_GOLD_MODE)
+	{
+		for(i = 0; i < part_count; i++) {
+			part_entry[i].length =BE64_TO_CPU(part_entry[i].length);
+			size=(part_entry[i].length >> 10);
+
+			memset(buf, 0, sizeof(buf));
+			memset(tmp, 0, sizeof(tmp));
+			snprintf(tmp, 16, "%llu", size);
+
+			if (memcmp(empty_mount, part_entry[i].mount_point, sizeof(empty_mount)) != 0) {
+				sprintf(buf, "%sk(%s%s",tmp, part_entry[i].mount_point,i == part_count-1? ")" :"),");
+			}
+			else {
+				sprintf(buf, "%s%s",tmp,i == part_count-1? "k" :"k,");
+			}
+			//printf("buf=%s\n",buf);
+			tmp_cmdline = (char *)malloc(strlen(getenv("mtd_part")) + 60);
+			if (!tmp_cmdline) {
+				printf("%s: Malloc failed\n", __func__);
+			}
+			else {
+				sprintf(tmp_cmdline, "%s%s", getenv("mtd_part"),buf);
+				setenv("mtd_part", tmp_cmdline);
+				free(tmp_cmdline);
+			}
+			debug(">%s\n",getenv("mtd_part"));
+		}
+	}
+
+	/* parse each fw_entry */
+	for (i = 0; i < fw_count; i++)
+	{
+		EXECUTE_CUSTOMIZE_FUNC(0); // insert execute customer callback at here
+
+		this_entry = (fw_entry + unit_len * i);
+		FW_ENTRY_MEMBER_GET(entry_target_addr, this_entry, target_addr, version);
+		FW_ENTRY_MEMBER_GET(entry_type, this_entry, type, version);
+		FW_ENTRY_MEMBER_GET(entry_length, this_entry, length, version);
+		FW_ENTRY_MEMBER_GET(entry_offset, this_entry, offset, version);
+		FW_ENTRY_MEMBER_GET(entry_lzma, this_entry, lzma, version);
+
+		if (entry_target_addr)
+		{
+			if(boot_mode == BOOT_GOLD_MODE)
+			{
+				switch(entry_type)
+				{
+					case FW_TYPE_GOLD_KERNEL:
+						//entry_offset=entry_offset-1; //let load gold_fw fail, and it can test enter to USB mode
+						memset(str, 0, sizeof(str));
+						sprintf((char *) str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("kernel_loadaddr",(char *) str);
+						printf("GOLD Kernel:\n");
+						break;
+					case FW_TYPE_GOLD_RESCUE_DT:
+						entry_target_addr = rtk_plat_get_dtb_target_address(entry_target_addr);
+						FW_ENTRY_MEMBER_SET(entry_target_addr, this_entry, target_addr, version);
+						//printf("entry_target_addr =%x\n",entry_target_addr);
+						memset(str, 0, sizeof(str));
+						sprintf((char *) str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("fdt_loadaddr",(char *) str);
+						printf("GOLD Rescue DT:\n");
+						break;
+					case FW_TYPE_GOLD_RESCUE_ROOTFS:
+						printf("GOLD Rescue ROOTFS:\n");
+						entry_target_addr = get_rescue_rootfs_addr(entry_target_addr);
+#ifdef NAS_ENABLE
+						initrd_size = entry_length;
+#endif
+						break;
+					case FW_TYPE_GOLD_AUDIO:
+						if(boot_mode == BOOT_KERNEL_ONLY_MODE)
+							continue;
+						else
+						{
+							ipc_shm.audio_fw_entry_pt = CPU_TO_BE32(entry_target_addr | MIPS_KSEG0BASE);
+							printf("GOLD Audio FW:\n");
+						}
+						break;
+					default:
+						//printf("Unknown FW (%d):\n", entry_type);
+						continue;
+				}
+			}
+			else
+			{
+				switch(entry_type)
+				{
+					case FW_TYPE_KERNEL:
+						memset(str, 0, sizeof(str));
+						sprintf(str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("kernel_loadaddr", str);
+						printf("Kernel:\n");
+						break;
+
+					case FW_TYPE_KERNEL_DT:
+						if( boot_mode != BOOT_RESCUE_MODE ) {
+							entry_target_addr = rtk_plat_get_dtb_target_address(entry_target_addr);
+							FW_ENTRY_MEMBER_SET(entry_target_addr, this_entry, target_addr, version);
+							//printf("entry_target_addr =%x\n",entry_target_addr);
+							memset(str, 0, sizeof(str));
+							sprintf((char *)str, "%x", entry_target_addr); /* write entry-point into string */
+							setenv("fdt_loadaddr", (char *)str);
+							printf("DT:\n");
+							break;
+						}
+						else {
+							continue;
+						}
+
+					case FW_TYPE_RESCUE_DT:
+						if( boot_mode == BOOT_RESCUE_MODE ) {
+							entry_target_addr = rtk_plat_get_dtb_target_address(entry_target_addr);
+							FW_ENTRY_MEMBER_SET(entry_target_addr, this_entry, target_addr, version);
+							//printf("entry_target_addr =%x\n",entry_target_addr);
+							memset(str, 0, sizeof(str));
+							sprintf((char *)str, "%x", entry_target_addr); /* write entry-point into string */
+							setenv("fdt_loadaddr", (char *)str);
+							printf("Rescue DT:\n");
+							break;
+						}
+						else {
+							continue;
+						}
+
+					case FW_TYPE_KERNEL_ROOTFS:
+						printf("ROOTFS:\n");
+						break;
+
+					case FW_TYPE_RESCUE_ROOTFS:
+						if( boot_mode == BOOT_RESCUE_MODE ) {
+							printf("Rescue ROOTFS:\n");
+							entry_target_addr = get_rescue_rootfs_addr(entry_target_addr);
+#ifdef NAS_ENABLE
+							initrd_size = entry_length;
+#endif
+							break;
+						}
+						else {
+							continue;
+						}
+
+					case FW_TYPE_AUDIO:
+						if(boot_mode == BOOT_KERNEL_ONLY_MODE)
+							continue;
+						else
+						{
+							ipc_shm.audio_fw_entry_pt = CPU_TO_BE32(entry_target_addr | MIPS_KSEG0BASE);
+							printf("Audio FW:\n");
+						}
+						break;
+
+					case FW_TYPE_IMAGE_FILE:
+						if(boot_mode == BOOT_KERNEL_ONLY_MODE)
+							continue;
+
+#ifdef NAS_ENABLE
+						if(boot_mode == BOOT_RESCUE_MODE )
+							entry_target_addr = getenv_ulong("logo_loadaddr", 16, get_rescue_rootfs_addr(CONFIG_RESCUE_ROOTFS_LOADADDR)+initrd_size);
+						else
+							entry_target_addr = getenv_ulong("logo_loadaddr", 16, 0x2400000);
+#endif
+
+						printf("IMAGE FILE:\n");
+
+						/* assign boot_av structure */
+						boot_av->dwMagicNumber = SWAPEND32(BOOT_AV_INFO_MAGICNO);
+						printf("  boot_logo_enable(%d), magic# 0x%08x\n", boot_logo_enable, boot_av->dwMagicNumber);
+						if(boot_logo_enable)
+						{
+							boot_av-> logo_enable = boot_logo_enable;
+							boot_av-> logo_addr = CPU_TO_BE32(entry_target_addr);
+							boot_av-> src_width = CPU_TO_BE32(custom_logo_src_width);
+							boot_av-> src_height = CPU_TO_BE32(custom_logo_src_height);
+							boot_av-> dst_width = CPU_TO_BE32(custom_logo_dst_width);
+							boot_av-> dst_height = CPU_TO_BE32(custom_logo_dst_height);
+						}
+
+						break;
+
+					default:
+						//printf("Unknown FW (%d):\n", entry_type);
+						continue;
+				}
+			}
+
+			printf("\t FW Image to 0x%08x, size=0x%08x (0x%08x)\n",
+					entry_target_addr, entry_length, entry_target_addr + entry_length);
+
+			printf("\t FW Image fr 0x%08Lx %s\n", entry_offset, entry_lzma ? "(lzma)" : "(non-lzma)");
+
+			WATCHDOG_KICK();
+
+			/* secure mode only apply to fw image */
+			if (entry_type == FW_TYPE_KERNEL ||
+				entry_type == FW_TYPE_KERNEL_ROOTFS ||
+				entry_type == FW_TYPE_RESCUE_ROOTFS ||
+				entry_type == FW_TYPE_AUDIO ||
+				entry_type == FW_TYPE_GOLD_KERNEL ||
+				entry_type == FW_TYPE_GOLD_RESCUE_ROOTFS ||
+				entry_type == FW_TYPE_GOLD_AUDIO)
+			{
+				/* get memory layout before copy fw image */
+				mem_layout.bIsEncrypted = (secure_mode != NONE_SECURE_BOOT);
+			}
+			mem_layout.bIsCompressed = entry_lzma;
+			mem_layout.image_target_addr = entry_target_addr & (~MIPS_KSEG_MSK);
+
+			get_mem_layout_when_read_image(&mem_layout);
+
+			/* read image from flash */
+			imageSize = entry_length;
+
+			rwsize = entry_length;
+			if (rwsize&(mtd->writesize-1))  // page aligned
+			{
+				rwsize &= ~(mtd->writesize-1);
+				rwsize += mtd->writesize;
+			}
+
+			if(mem_layout.bIsEncrypted)
+				ret = nand_read_skip_bad_on_the_fly(mtd, entry_offset, &rwsize, (u_char*)(uintptr_t)mem_layout.flash_to_ram_addr,CP_NF_AES_CBC_128);
+			else
+				ret = nand_read_skip_bad(mtd, entry_offset, &rwsize, NULL, mtd->size, (u_char*)(uintptr_t)mem_layout.flash_to_ram_addr);
+
+			if(ret){
+				printf("[ERR] Read fw error (type:%d)!\n", entry_type);
+				return RTK_PLAT_ERR_READ_FW_IMG;
+			}
+
+			/* Check checksum */
+			if (FW_DESC_BASE_VERSION(version) == FW_DESC_TABLE_V1_T_VERSION_1) {
+				fw_checksum = get_checksum((uchar *)(uintptr_t)mem_layout.flash_to_ram_addr, entry_length);
+				if (((fw_desc_entry_v1_t*)this_entry)->checksum != fw_checksum &&
+					secure_mode!= RTK_SECURE_BOOT) {
+					printf("\t FW Image checksum FAILED\n");
+					printf("\t FW Image entry  checksum=0x%08x\n",
+						((fw_desc_entry_v1_t*)this_entry)->checksum);
+					printf("\t FW Image result checksum=0x%08x\n", fw_checksum);
+					return RTK_PLAT_ERR_READ_FW_IMG;
+				}
+			} else if (FW_DESC_BASE_VERSION(version) == FW_DESC_TABLE_V2_T_VERSION_2) {
+				SHA256_hash((uchar *)(uintptr_t)mem_layout.flash_to_ram_addr, entry_length, sha_hash, NULL);
+				if ((memcmp(((fw_desc_entry_v2_t*)this_entry)->sha_hash, sha_hash, SHA256_SIZE) != 0) &&
+					secure_mode!= RTK_SECURE_BOOT) {
+					printf("\t FW Image sha FAILED\n");
+					printf("\t FW Image entry sha256==>\n");
+					for (j = 0 ; j < 32 ; j++)
+						printf("%02x ", ((fw_desc_entry_v2_t*)this_entry)->sha_hash[j]);
+					printf("\n\t FW Image result sha256==>\n");
+					for (j = 0 ; j < 32 ; j++)
+						printf("%02x ", sha_hash[j]);
+					printf("\n");
+					return RTK_PLAT_ERR_READ_FW_IMG;
+				}
+			}
+
+			/* if secure mode, do AES CBC decrypt */
+/*			if (mem_layout.bIsEncrypted)
+			{
+				if (secure_mode == RTK_SECURE_BOOT)
+				{
+					ret = Verify_SHA256_hash( (unsigned char *)(uintptr_t)mem_layout.flash_to_ram_addr, entry_length - img_truncated_size, (unsigned char *)(uintptr_t)(mem_layout.flash_to_ram_addr + entry_length - img_truncated_size), 1, NULL );
+					if( ret < 0 ) {
+						printf("[ERR] %s: verify hash fail(%d)\n", __FUNCTION__, ret );
+						return RTK_PLAT_ERR_READ_FW_IMG;
+					}
+					//imageSize = imageSize - img_truncated_size - SHA256_SIZE;
+				}
+			}*/
+
+			/* if lzma type, decompress image */
+			if (mem_layout.bIsCompressed)
+			{
+				decompressedSize = 0;
+				if (lzmaBuffToBuffDecompress((uchar*)(uintptr_t)mem_layout.decompressed_addr, (SizeT *)&decompressedSize, (uchar*)(uintptr_t)mem_layout.compressed_addr, imageSize) != 0)
+				{
+					printf("[ERR] %s:Decompress using LZMA error!!\n", __FUNCTION__);
+
+					return RTK_PLAT_ERR_READ_FW_IMG;
+				}
+			}
+#ifdef NAS_ENABLE
+			if (FW_TYPE_RESCUE_ROOTFS == entry_type)
+			{
+				initrd_size = (entry_lzma)?decompressedSize:entry_length;
+			}
+#endif
+		}
+	}
+#ifdef NAS_ENABLE
+	rtk_plat_set_boot_flag_from_part_desc(part_entry, part_count);
+#endif
+
+	/* set boot_av_info_ptr */
+	if (boot_av->dwMagicNumber == SWAPEND32(BOOT_AV_INFO_MAGICNO))
+	{
+		boot_av->bHDMImode = sys_logo_is_HDMI; // ignored.
+
+		// enable audio sound
+		if (boot_av->dwAudioStreamLength != 0)
+		{
+			;
+		}
+
+		ipc_shm.pov_boot_av_info = SWAPEND32((uint)(uintptr_t)boot_av);
+
+		#ifdef DUBUG_BOOT_AV_INFO
+		dump_boot_av_info(boot_av);
+		#endif
+	}
+
+	/* Flush caches */
+	flush_dcache_all();
+
+#endif /* CONFIG_SYS_RTK_NAND_FLASH */
+	/* Start audio fw for S5 power check */
+	if (boot_from_flash == BOOT_FROM_FLASH_NORMAL_MODE) {
+		do_go_audio_fw();
+	}
+
+	return ret;
+}
+
+/*
+ * Use firmware description table to read images from SPI flash.
+ */
+#if defined(CONFIG_RTKSPI) && defined(CONFIG_CMD_RTKSPI)
+extern unsigned int spi_flash_min_erase_size;
+#endif
+int rtk_plat_read_fw_image_from_SPI(
+		uint fw_desc_table_base, part_desc_entry_v1_t* part_entry, int part_count,
+		void* fw_entry, int fw_count,
+		uchar version)
+{
+	int ret = RTK_PLAT_ERR_OK;
+#ifdef CONFIG_BOOT_FROM_SPI
+	void *this_entry;
+	int i, j;
+	uint unit_len;
+	uint fw_checksum = 0;
+	unsigned int secure_mode;
+	unsigned char sha_hash[32];
+	boot_av_info_t *boot_av;
+	MEM_LAYOUT_WHEN_READ_IMAGE_T mem_layout;
+	uint imageSize = 0;
+	uint erasesize = 0x1000; // Set erasesize default to 4KB
+	uint decompressedSize = 0;
+	//unsigned int _iSPI_base_addr;
+	unsigned char str[16];// old array size is 5, change to 16. To avoid the risk in memory overlap.
+
+	uchar entry_type = 0;
+	uchar entry_lzma = 0;
+	uint entry_target_addr = 0;
+	u64 entry_offset = 0;
+	uint entry_length = 0;
+
+	secure_mode = rtk_get_secure_boot_type();
+	//_iSPI_base_addr = SPI_RBUS_BASE_ADDR + spi_fw_desc_table_start;
+#ifdef NAS_ENABLE
+	rtk_plat_set_boot_flag_from_part_desc(part_entry, part_count);
+#endif
+
+	/* find fw_entry structure according to version */
+	switch (version)
+	{
+		case FW_DESC_TABLE_V1_T_VERSION_1:
+			unit_len = sizeof(fw_desc_entry_v1_t);
+			break;
+
+		case FW_DESC_TABLE_V2_T_VERSION_2:
+			unit_len = sizeof(fw_desc_entry_v2_t);
+			break;
+
+		default:
+			return RTK_PLAT_ERR_READ_FW_IMG;
+	}
+
+	/* clear boot_av_info memory */
+	boot_av = (boot_av_info_t *) MIPS_BOOT_AV_INFO_ADDR;
+	memset(boot_av, 0, sizeof(boot_av_info_t));
+
+	/* parse each fw_entry */
+	for (i = 0; i < fw_count; i++)
+	{
+		EXECUTE_CUSTOMIZE_FUNC(0); // insert execute customer callback at here
+
+		this_entry = (fw_entry + unit_len * i);
+		FW_ENTRY_MEMBER_GET(entry_target_addr, this_entry, target_addr, version);
+		FW_ENTRY_MEMBER_GET(entry_type, this_entry, type, version);
+		FW_ENTRY_MEMBER_GET(entry_length, this_entry, length, version);
+		FW_ENTRY_MEMBER_GET(entry_offset, this_entry, offset, version);
+		FW_ENTRY_MEMBER_GET(entry_lzma, this_entry, lzma, version);
+
+		if (entry_target_addr)
+		{
+			switch(entry_type)
+			{
+				case FW_TYPE_KERNEL:
+					memset(str, 0, sizeof(str));
+					sprintf((char *)str, "%x", entry_target_addr); /* write entry-point into string */
+					setenv("kernel_loadaddr", (char *)str);
+					printf("Kernel:\n");
+					break;
+
+				case FW_TYPE_KERNEL_DT:
+					if( boot_mode != BOOT_RESCUE_MODE ) {
+						entry_target_addr = rtk_plat_get_dtb_target_address(entry_target_addr);
+						FW_ENTRY_MEMBER_SET(entry_target_addr, this_entry, target_addr, version);
+						//printf("entry_target_addr =%x\n",entry_target_addr);
+						memset(str, 0, sizeof(str));
+						sprintf((char *)str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("fdt_loadaddr", (char *)str);
+						printf("DT:\n");
+						break;
+					}
+					else {
+						continue;
+					}
+
+				case FW_TYPE_RESCUE_DT:
+					if( boot_mode == BOOT_RESCUE_MODE ) {
+						entry_target_addr = rtk_plat_get_dtb_target_address(entry_target_addr);
+						FW_ENTRY_MEMBER_SET(entry_target_addr, this_entry, target_addr, version);
+						//printf("entry_target_addr =%x\n",entry_target_addr);
+						memset(str, 0, sizeof(str));
+						sprintf((char *)str, "%x", entry_target_addr); /* write entry-point into string */
+						setenv("fdt_loadaddr", (char *)str);
+						printf("Rescue DT:\n");
+						break;
+					}
+					else {
+						continue;
+					}
+
+#ifdef CONFIG_BFS_SUPPORT_KERNEL_ROOTFS
+				case FW_TYPE_KERNEL_ROOTFS:
+					if( boot_mode != BOOT_RESCUE_MODE ) {
+						printf("Kernel ROOTFS:\n");
+						entry_target_addr = get_kernel_rootfs_addr(entry_target_addr);
+#ifdef NAS_ENABLE
+						initrd_size = entry_length;
+#endif
+						break;
+					}
+					else {
+						continue;
+					}
+#endif
+
+				case FW_TYPE_RESCUE_ROOTFS:
+					if( boot_mode == BOOT_RESCUE_MODE ) {
+						printf("Rescue ROOTFS:\n");
+						entry_target_addr = get_rescue_rootfs_addr(entry_target_addr);
+#ifdef NAS_ENABLE
+						initrd_size = entry_length;
+#endif
+						break;
+					}
+					else {
+						continue;
+					}
+
+				case FW_TYPE_AUDIO:
+					if(boot_mode == BOOT_KERNEL_ONLY_MODE)
+						continue;
+					else
+					{
+						ipc_shm.audio_fw_entry_pt = CPU_TO_BE32(entry_target_addr | MIPS_KSEG0BASE);
+						printf("Audio FW:\n");
+					}
+					break;
+
+#ifdef CONFIG_BFS_SUPPORT_LOGO_IMG
+				case FW_TYPE_IMAGE_FILE:
+					if(boot_mode == BOOT_KERNEL_ONLY_MODE)
+						continue;
+
+					printf("IMAGE FILE:\n");
+
+					/* assign boot_av structure */
+					boot_av->dwMagicNumber = SWAPEND32(BOOT_AV_INFO_MAGICNO);
+					printf("  boot_logo_enable(%d), magic# 0x%08x\n", boot_logo_enable, boot_av->dwMagicNumber);
+					if(boot_logo_enable)
+					{
+						boot_av-> logo_enable = boot_logo_enable;
+						boot_av-> logo_addr = CPU_TO_BE32(entry_target_addr);
+						boot_av-> src_width = CPU_TO_BE32(custom_logo_src_width);
+						boot_av-> src_height = CPU_TO_BE32(custom_logo_src_height);
+						boot_av-> dst_width = CPU_TO_BE32(custom_logo_dst_width);
+						boot_av-> dst_height = CPU_TO_BE32(custom_logo_dst_height);
+					}
+
+					break;
+#endif
+
+				default:
+					printf("Unknown FW (%d):\n", entry_type);
+					continue;
+			}
+			printf("\t FW Image to 0x%08x, size=0x%08x (0x%08x)\n",
+					entry_target_addr, entry_length, entry_target_addr + entry_length);
+			printf("\t FW Image fr 0x%08Lx \n", entry_offset);
+
+			WATCHDOG_KICK();
+
+			/* secure mode and lzma will only apply to fw image */
+			if (entry_type == FW_TYPE_KERNEL ||
+				entry_type == FW_TYPE_KERNEL_ROOTFS ||
+				entry_type == FW_TYPE_RESCUE_ROOTFS ||
+#ifdef CONFIG_BFS_SUPPORT_LOGO_IMG
+				entry_type == FW_TYPE_IMAGE_FILE ||
+#endif
+				entry_type == FW_TYPE_AUDIO)
+			{
+				/* get memory layout before copy fw image */
+				mem_layout.bIsEncrypted = (secure_mode != NONE_SECURE_BOOT);
+				mem_layout.bIsCompressed = entry_lzma;
+				mem_layout.image_target_addr = entry_target_addr & (~MIPS_KSEG_MSK);
+			}
+			else
+			{
+				/* get memory layout before copy other image */
+				mem_layout.bIsEncrypted = 0;
+				mem_layout.bIsCompressed = 0;
+				mem_layout.image_target_addr = entry_target_addr & (~MIPS_KSEG_MSK);
+			}
+
+			get_mem_layout_when_read_image(&mem_layout);
+
+			imageSize = entry_length;
+
+#if defined(CONFIG_RTKSPI) && defined(CONFIG_CMD_RTKSPI)
+                        if(spi_flash_min_erase_size) erasesize = spi_flash_min_erase_size;
+#endif
+			// aligned to erasesize
+			if (imageSize&(erasesize-1)) {
+				imageSize &= ~(erasesize-1);
+				imageSize += erasesize;
+			}
+
+		        rtkspi_read32_md(mem_layout.flash_to_ram_addr, SPI_RBUS_BASE_ADDR+entry_offset, imageSize);
+#ifndef BYPASS_CHECKSUM
+			/* Check checksum */
+			if (FW_DESC_BASE_VERSION(version) == FW_DESC_TABLE_V1_T_VERSION_1) {
+				fw_checksum = get_checksum((uchar *)(uintptr_t)mem_layout.flash_to_ram_addr, entry_length);
+				if (((fw_desc_entry_v1_t*)this_entry)->checksum != fw_checksum &&
+					secure_mode!= RTK_SECURE_BOOT) {
+					printf("\t FW Image checksum FAILED\n");
+					printf("\t FW Image entry  checksum=0x%08x\n",
+						((fw_desc_entry_v1_t*)this_entry)->checksum);
+					printf("\t FW Image result checksum=0x%08x\n", fw_checksum);
+					return RTK_PLAT_ERR_READ_FW_IMG;
+				}
+			} else if (FW_DESC_BASE_VERSION(version) == FW_DESC_TABLE_V2_T_VERSION_2) {
+				SHA256_hash((uchar *)(uintptr_t)mem_layout.flash_to_ram_addr, entry_length, sha_hash, NULL);
+				if ((memcmp(((fw_desc_entry_v2_t*)this_entry)->sha_hash, sha_hash, SHA256_SIZE) != 0) &&
+					secure_mode!= RTK_SECURE_BOOT) {
+					printf("\t FW Image sha FAILED\n");
+					printf("\t FW Image entry sha256==>\n");
+					for (j = 0 ; j < 32 ; j++)
+						printf("%02x ", ((fw_desc_entry_v2_t*)this_entry)->sha_hash[j]);
+					printf("\n\t FW Image result sha256==>\n");
+					for (j = 0 ; j < 32 ; j++)
+						printf("%02x ", sha_hash[j]);
+					printf("\n");
+					return RTK_PLAT_ERR_READ_FW_IMG;
+				}
+			}
+#endif
+
+			/* if lzma type, decompress image */
+			if (mem_layout.bIsCompressed)
+			{
+				decompressedSize = 0;
+				if (lzmaBuffToBuffDecompress((uchar*)(uintptr_t)mem_layout.decompressed_addr, (SizeT *)&decompressedSize, (uchar*)(uintptr_t)mem_layout.compressed_addr, imageSize) != 0)
+				{
+					printf("[ERR] %s:Decompress using LZMA error!!\n", __FUNCTION__);
+
+					return RTK_PLAT_ERR_READ_FW_IMG;
+				}
+			}
+#ifdef NAS_ENABLE
+			if (FW_TYPE_RESCUE_ROOTFS == entry_type)
+			{
+				initrd_size = (entry_lzma)?decompressedSize:entry_length;
+			}
+#endif
+		}
+	}
+
+	/* set boot_av_info_ptr */
+	if (boot_av->dwMagicNumber == SWAPEND32(BOOT_AV_INFO_MAGICNO))
+	{
+		boot_av->bHDMImode = sys_logo_is_HDMI;// ignored.
+
+		// enable audio sound
+		if (boot_av->dwAudioStreamLength != 0)
+		{
+			;
+		}
+
+		ipc_shm.pov_boot_av_info = SWAPEND32((uint)(uintptr_t) boot_av);
+
+		#ifdef DUBUG_BOOT_AV_INFO
+		dump_boot_av_info(boot_av);
+		#endif
+	}
+	/* Flush caches */
+	flush_dcache_all();
+
+
+#endif // CONFIG_BOOT_FROM_SPI
+	/* Start audio fw for S5 power check */
+	if (boot_from_flash == BOOT_FROM_FLASH_NORMAL_MODE) {
+		do_go_audio_fw();
+	}
+
+	return ret;
+}
+
+/*
+ * Use firmware description table to read images from SD flash.
+ */
+int rtk_plat_read_fw_image_from_SD(void)
+{
+#if defined(CONFIG_SYS_RTK_SD_FLASH)
+	// add your code here
+#endif
+	return RTK_PLAT_ERR_OK;
+}
+
+/*
+ * Use firmware description table to read images from SATAflash.
+ */
+int rtk_plat_read_fw_image_from_SATA(
+		uint fw_desc_table_base, part_desc_entry_v1_t* part_entry, int part_count,
+		void* fw_entry, int fw_count,
+		uchar version)
+{
+#ifdef CONFIG_SYS_RTK_SATA_STORAGE
+	fw_desc_entry_v1_t *this_entry;
+	//fw_desc_entry_v11_t *v11_entry;
+	//fw_desc_entry_v21_t *v21_entry;
+	int i;
+	uint unit_len;
+	//char buf[64];
+	uint fw_checksum = 0;
+#if 0 // mark secure boot
+	char str_phash[256];
+#if defined(Config_Secure_RSA_TRUE)
+	char *checksum, *signature;
+#endif
+	char sha1_hash[SHA1_SIZE];
+	char *hash_str;
+#endif // mark secure boot
+	unsigned int secure_mode;
+	unsigned char ks[16],kh[16],kimg[16];
+    unsigned char aes_key[16];
+    unsigned char rsa_key[256];
+#ifdef CONFIG_CMD_KEY_BURNING
+	unsigned int * Kh_key_ptr = NULL;
+#else
+	unsigned int * Kh_key_ptr = (unsigned int *)Kh_key_default;
+#endif
+	unsigned int img_truncated_size; // install_a will append 256-byte signature data to it
+	int ret;
+	boot_av_info_t *boot_av;
+	uint block_no;
+	MEM_LAYOUT_WHEN_READ_IMAGE_T mem_layout;
+	uint imageSize = 0;
+	uint imageBlkSize = 0;
+	uint decompressedSize = 0;
+
+	// extern variable
+	extern unsigned int mcp_dscpt_addr;
+	mcp_dscpt_addr = 0;
+
+	secure_mode = rtk_get_secure_boot_type();
+	img_truncated_size = RSA_SIGNATURE_LENGTH*2+NP_INV32_LENGTH;
+
+	char str[16];// old array size is 5, change to 16. To avoid the risk in memory overlap.
+
+	/* find fw_entry structure according to version */
+	switch (version)
+	{
+		case FW_DESC_TABLE_V1_T_VERSION_1:
+			unit_len = sizeof(fw_desc_entry_v1_t);
+			break;
+
+		case FW_DESC_TABLE_V1_T_VERSION_11:
+			unit_len = sizeof(fw_desc_entry_v11_t);
+			break;
+
+		case FW_DESC_TABLE_V1_T_VERSION_21:
+			unit_len = sizeof(fw_desc_entry_v21_t);
+			break;
+
+		default:
+			return RTK_PLAT_ERR_READ_FW_IMG;
+	}
+
+#if 0 // mark secure boot
+#if defined(Config_Secure_RSA_TRUE)
+	checksum = (char *)alloc_freemem(sizeof(v21_entry->RSA_sign));
+	signature = (char *)alloc_freemem(sizeof(v21_entry->RSA_sign)+1);
+
+	// set RSA key to env variable
+	if (env_split_and_save("RSA_KEY_MODULUS", Config_Secure_RSA_MODULUS, 96) != OK)
+		return NULL;
+#endif // defined(Config_Secure_RSA_TRUE)
+
+
+	if (secure_mode == RTK_SECURE_BOOT)
+	{
+		// set AES img key to env variable
+		setenv( "AES_IMG_KEY", SECURE_KH_KEY_STR);
+	}
+
+	//	memset(str_phash, 0, 256);
+#endif // mark secure boot
+
+	/* clear boot_av_info memory */
+	boot_av = (boot_av_info_t *) MIPS_BOOT_AV_INFO_ADDR;
+	memset(boot_av, 0, sizeof(boot_av_info_t));
+
+	//printf("****** %s %d, boot_mode %d\n", __FUNCTION__, __LINE__, boot_mode);
+
+	/* parse each fw_entry */
+	for (i = 0; i < fw_count; i++)
+	{
+		EXECUTE_CUSTOMIZE_FUNC(0); // insert execute customer callback at here
+
+		this_entry = (fw_desc_entry_v1_t *)(fw_entry + unit_len * i);
+
+		if (this_entry->target_addr)
+		{
+			if (boot_mode == BOOT_RESCUE_MODE || boot_mode == BOOT_ANDROID_MODE)
+			{
+				//printf("****** %s %d\n", __FUNCTION__, __LINE__);
+				switch(this_entry->type)
+				{
+					case FW_TYPE_RESCUE_KERNEL:
+						memset(str, 0, sizeof(str));
+						sprintf(str, "%x", this_entry->target_addr); /* write entry-point into string */
+						setenv("kernel_loadaddr", str);
+						printf("Rescue Kernel:\n");
+						break;
+
+					case FW_TYPE_RESCUE_DT:
+						this_entry->target_addr = rtk_plat_get_dtb_target_address(this_entry->target_addr);
+						memset(str, 0, sizeof(str));
+						sprintf(str, "%x", this_entry->target_addr); /* write entry-point into string */
+						setenv("fdt_loadaddr", str);
+						printf("Rescue DT:\n");
+						break;
+
+					case FW_TYPE_RESCUE_ROOTFS:
+						printf("Rescue ROOTFS:\n");
+						break;
+
+					case FW_TYPE_TEE:
+#ifdef CONFIG_TEE
+						printf("TEE:\n");
+						tee_enable=1;
+						break;
+#else
+						continue;
+#endif
+					case FW_TYPE_RESCUE_AUDIO:
+						if(boot_mode == BOOT_KERNEL_ONLY_MODE)
+							continue;
+						else
+						{
+							ipc_shm.audio_fw_entry_pt = CPU_TO_BE32(this_entry->target_addr | MIPS_KSEG0BASE);
+							printf("Rescue Audio FW:\n");
+						}
+						break;
+
+					default:
+						//printf("Unknown FW (%d):\n", this_entry->type);
+						continue;
+				}
+			}
+			else if(boot_mode == BOOT_GOLD_MODE)
+            {
+                //printf("****** %s %d\n", __FUNCTION__, __LINE__);
+                switch(this_entry->type)
+                {
+                    case FW_TYPE_GOLD_KERNEL:
+                        memset(str, 0, sizeof(str));
+                        sprintf(str, "%x", this_entry->target_addr); /* write entry-point into string */
+                        setenv("kernel_loadaddr", str);
+                        printf("GOLD Kernel:\n");
+                        break;
+                    case FW_TYPE_GOLD_RESCUE_DT:
+                        this_entry->target_addr = rtk_plat_get_dtb_target_address(this_entry->target_addr);
+                        memset(str, 0, sizeof(str));
+                        sprintf(str, "%x", this_entry->target_addr); /* write entry-point into string */
+                        setenv("fdt_loadaddr", str);
+                        printf("GOLD Rescue DT:\n");
+                        break;
+                    case FW_TYPE_GOLD_RESCUE_ROOTFS:
+                        printf("GOLD Rescue ROOTFS:\n");
+                        break;
+                    case FW_TYPE_GOLD_AUDIO:
+                        if(boot_mode == BOOT_KERNEL_ONLY_MODE)
+                            continue;
+                        else
+                        {
+                            ipc_shm.audio_fw_entry_pt = CPU_TO_BE32(this_entry->target_addr | MIPS_KSEG0BASE);
+                            printf("GOLD Audio FW:\n");
+                        }
+                        break;
+
+                    default:
+                        //printf("Unknown FW (%d):\n", this_entry->type);
+                        continue;
+                }
+
+            }
+			else
+			{
+				//printf("****** %s %d, fw desc type 0x%02x\n", __FUNCTION__, __LINE__, this_entry->type);
+				switch(this_entry->type)
+				{
+					case FW_TYPE_KERNEL:
+						memset(str, 0, sizeof(str));
+						sprintf(str, "%x", this_entry->target_addr); /* write entry-point into string */
+						setenv("kernel_loadaddr", str);
+						printf("Kernel:\n");
+						break;
+
+					case FW_TYPE_KERNEL_DT:
+						this_entry->target_addr = rtk_plat_get_dtb_target_address(this_entry->target_addr);
+						memset(str, 0, sizeof(str));
+						sprintf(str, "%x", this_entry->target_addr); /* write entry-point into string */
+						setenv("fdt_loadaddr", str);
+						printf("DT:\n");
+						break;
+
+					case FW_TYPE_KERNEL_ROOTFS:
+						printf("ROOTFS:\n");
+						break;
+
+					case FW_TYPE_TEE:
+#ifdef CONFIG_TEE
+						printf("TEE:\n");
+						tee_enable=1;
+						break;
+#else
+						continue;
+#endif
+
+					case FW_TYPE_AUDIO:
+						if(boot_mode == BOOT_KERNEL_ONLY_MODE)
+							continue;
+						else
+						{
+							ipc_shm.audio_fw_entry_pt = CPU_TO_BE32(this_entry->target_addr | MIPS_KSEG0BASE);
+							printf("Audio FW:\n");
+						}
+						break;
+
+					case FW_TYPE_IMAGE_FILE:
+						printf("IMAGE FILE:\n");
+						/* assign boot_av structure */
+						boot_av->dwMagicNumber = SWAPEND32(BOOT_AV_INFO_MAGICNO);
+						if(boot_logo_enable)
+						{
+							boot_av-> logo_enable = boot_logo_enable;
+							boot_av-> logo_addr = CPU_TO_BE32(this_entry->target_addr);
+							boot_av-> src_width = CPU_TO_BE32(custom_logo_src_width);
+							boot_av-> src_height = CPU_TO_BE32(custom_logo_src_height);
+							boot_av-> dst_width = CPU_TO_BE32(custom_logo_dst_width);
+							boot_av-> dst_height = CPU_TO_BE32(custom_logo_dst_height);
+						}
+
+						break;
+
+					case FW_TYPE_UBOOT: /* 37 */ // 2nd stage bootcode
+#if defined(CONFIG_SECOND_BOOTCODE_SUPPORT) && defined(CONFIG_GOLDENBOOT_SUPPORT)
+						// due to 2nd bootcode run at the same ADDR as 1st, load to other place first
+						printf("Support BootCode64\n");
+						continue;
+#endif
+						break;
+
+					case FW_TYPE_HYP: /* 39 */
+						memset(str, 0, sizeof(str));
+						sprintf(str, "%x", this_entry->target_addr); /* write entry-point into string */
+						setenv("hyp_loadaddr", str);
+						printf("Hypervisor:\n");
+						break;
+
+					default:
+						//printf("Unknown FW (%d):\n", this_entry->type);
+						continue;
+				}
+			}
+			printf("\t FW Image to 0x%08x, size=0x%08x (0x%08x)\n", this_entry->target_addr, this_entry->length, this_entry->target_addr + this_entry->length);
+			printf("\t FW Image fr 0x%08x \n", this_entry->offset);
+
+			WATCHDOG_KICK();
+
+				/* secure mode and lzma will only apply to fw image */
+				if (this_entry->type == FW_TYPE_KERNEL ||
+					this_entry->type == FW_TYPE_KERNEL_ROOTFS ||
+					this_entry->type == FW_TYPE_RESCUE_ROOTFS ||
+					this_entry->type == FW_TYPE_AUDIO )
+				{
+					/* get memory layout before copy fw image */
+					mem_layout.bIsEncrypted = (secure_mode != NONE_SECURE_BOOT);
+					mem_layout.bIsCompressed = this_entry->lzma;
+					mem_layout.image_target_addr = this_entry->target_addr & (~MIPS_KSEG_MSK);
+				}
+				else
+				{
+					/* get memory layout before copy other image */
+					mem_layout.bIsEncrypted = 0;
+					mem_layout.bIsCompressed = 0;
+					mem_layout.image_target_addr = this_entry->target_addr & (~MIPS_KSEG_MSK);
+				}
+
+				get_mem_layout_when_read_image(&mem_layout);
+
+				// 512B aligned
+				imageSize = this_entry->length + 511;
+				imageSize &= (~511UL);
+				imageBlkSize = imageSize / 512;
+
+				block_no = (this_entry->offset) / 512;
+
+				if (!rtk_sata_read(block_no, imageBlkSize, (uint *)(uintptr_t)mem_layout.flash_to_ram_addr))
+				{
+					printf("[ERR] Read fw error (type:%d)!\n", this_entry->type);
+
+					return RTK_PLAT_ERR_READ_FW_IMG;
+				}
+#ifndef BYPASS_CHECKSUM
+				/* Check checksum */
+				fw_checksum = get_checksum((uchar *)(uintptr_t)mem_layout.flash_to_ram_addr, this_entry->length);
+
+				if (this_entry->checksum != fw_checksum && secure_mode!= RTK_SECURE_BOOT)
+				{
+					printf("\t FW Image checksum FAILED\n");
+					printf("\t FW Image entry  checksum=0x%08x\n", this_entry->checksum);
+					printf("\t FW Image result checksum=0x%08x\n", fw_checksum);
+					return RTK_PLAT_ERR_READ_FW_IMG;
+				}
+#endif
+				/* if secure mode, do AES CBC decrypt */
+				if (mem_layout.bIsEncrypted)
+				{
+					if (secure_mode == RTK_SECURE_BOOT)
+					{
+						unsigned int real_body_size = 0;
+						//rtk_hexdump("the first 32-byte encrypted data", (unsigned char *)mem_layout.encrpyted_addr, 32);
+						//rtk_hexdump("the last 512-byte encrypted data", (unsigned char *)(ENCRYPTED_LINUX_KERNEL_ADDR+this_entry->length-512), 512);
+
+                        memset(ks,0x00,16);
+                        memset(kh,0x00,16);
+                        memset(kimg,0x00,16);
+
+                        memset(aes_key, 0x00, 16);
+                        memset(rsa_key, 0x00, 256);
+
+                        switch(this_entry->type)
+                        {
+                            case FW_TYPE_KERNEL:
+                            case FW_TYPE_RESCUE_ROOTFS:
+                            case FW_TYPE_KERNEL_ROOTFS:
+                            case FW_TYPE_AUDIO:
+                                GetKeyFromSRAM(KH_P_SRAM_ADDR, aes_key, AES_KEY_SIZE);
+                                GetKeyFromSRAM(RSA_KEY_FW_SRAM_ADDR, rsa_key, RSA_KEY_SIZE);
+                                flush_cache((unsigned long) aes_key, AES_KEY_SIZE);
+                                flush_cache((unsigned long) aes_key, RSA_KEY_SIZE);
+                                sync();
+                                //rtk_hexdump("kh_p : ", aes_key, AES_KEY_SIZE);
+                                //rtk_hexdump("rsa_key_fw : ", rsa_key, RSA_KEY_SIZE);
+                                break;
+                            case FW_TYPE_TEE:
+                                GetKeyFromSRAM(KX_P_SRAM_ADDR, aes_key, AES_KEY_SIZE);
+                                GetKeyFromSRAM(RSA_KEY_TEE_SRAM_ADDR, rsa_key, RSA_KEY_SIZE);
+                                flush_cache((unsigned long) aes_key, AES_KEY_SIZE);
+                                flush_cache((unsigned long) aes_key, RSA_KEY_SIZE);
+                                sync();
+                                //rtk_hexdump("kx_p : ", aes_key, 16);
+                                //rtk_hexdump("rsa_key_tee : ", rsa_key, RSA_KEY_SIZE);
+                                break;
+                            default:
+                                break;
+                        }
+
+#ifdef CONFIG_CMD_KEY_BURNING
+                        OTP_Get_Byte(OTP_K_S, ks, 16);
+                        OTP_Get_Byte(OTP_K_H, kh, 16);
+                        sync();
+						flush_cache((unsigned int) (uintptr_t)ks, 16);
+						flush_cache((unsigned int) (uintptr_t)kh, 16);
+#endif
+                        AES_ECB_encrypt(ks, 16, kimg,(unsigned int *) kh);
+						flush_cache((unsigned long) kimg, 16);
+                        sync();
+
+                        Kh_key_ptr = (unsigned int *) kimg;
+                        Kh_key_ptr = (unsigned int *) aes_key;
+                        //Kh_key_ptr[0] = swap_endian(Kh_key_ptr[0]);
+                        //Kh_key_ptr[1] = swap_endian(Kh_key_ptr[1]);
+                        //Kh_key_ptr[2] = swap_endian(Kh_key_ptr[2]);
+                        //Kh_key_ptr[3] = swap_endian(Kh_key_ptr[3]);
+						flush_cache((unsigned long) aes_key, 16);
+
+						// decrypt image
+						printf("to decrypt...\n");
+
+						flush_cache((unsigned int) mem_layout.encrpyted_addr, this_entry->length);
+
+						if (decrypt_image((char *)(uintptr_t)mem_layout.encrpyted_addr,
+							(char *)(uintptr_t)mem_layout.decrypted_addr,
+							this_entry->length  - img_truncated_size,
+							Kh_key_ptr))
+						{
+							printf("decrypt image(%d) error!\n", this_entry->type);
+							return RTK_PLAT_ERR_READ_FW_IMG;
+						}
+
+						sync();
+                        memset(ks,0x00,16);
+                        memset(kh,0x00,16);
+                        memset(kimg,0x00,16);
+
+						//rtk_hexdump("the first 32-byte decrypted data", (unsigned char *)mem_layout.decrypted_addr, 32);
+
+						//reverse_signature( (unsigned char *)(mem_layout.decrypted_addr + imageSize - img_truncated_size) );
+
+                        copy_memory((void *)(uintptr_t)(mem_layout.decrypted_addr + this_entry->length - img_truncated_size), (void *)(uintptr_t)(mem_layout.encrpyted_addr + this_entry->length - img_truncated_size), img_truncated_size);
+						flush_cache((unsigned int) mem_layout.decrypted_addr, this_entry->length);
+
+                        real_body_size = (UINT32)(REG32( (uintptr_t)(mem_layout.decrypted_addr + (this_entry->length - img_truncated_size) - 4)));
+                        real_body_size = swap_endian(real_body_size);
+						real_body_size /= 8;
+
+						flush_cache((unsigned int) mem_layout.decrypted_addr, this_entry->length);
+						ret = Verify_SHA256_hash( (unsigned char *)(uintptr_t)mem_layout.decrypted_addr,
+												  real_body_size,
+												  (unsigned char *)(uintptr_t)(mem_layout.decrypted_addr + this_entry->length - img_truncated_size),
+												  1, rsa_key);
+						if( ret < 0 ) {
+							printf("[ERR] %s: verify hash fail(%d)\n", __FUNCTION__, ret );
+							return RTK_PLAT_ERR_READ_FW_IMG;
+						}
+
+						//imageSize = imageSize - img_truncated_size - SHA256_SIZE;
+					}
+				}
+
+				/* if lzma type, decompress image */
+				if (mem_layout.bIsCompressed)
+				{
+					if (lzmaBuffToBuffDecompress((uchar*)(uintptr_t)mem_layout.decompressed_addr, (SizeT *)&decompressedSize, (uchar*)(uintptr_t)mem_layout.compressed_addr, imageSize) != 0)
+					{
+						printf("[ERR] %s:Decompress using LZMA error!!\n", __FUNCTION__);
+
+						return RTK_PLAT_ERR_READ_FW_IMG;
+					}
+				}
+		}
+	} // end for-loop
+
+		if (version == FW_DESC_TABLE_V1_T_VERSION_11)
+		{
+			// remove unusing code
+			printf("****** %s %d, not implement\n", __FUNCTION__, __LINE__);
+		}
+		else if (version == FW_DESC_TABLE_V1_T_VERSION_21)
+		{
+			// remove unusing code
+			printf("****** %s %d, not implement\n", __FUNCTION__, __LINE__);
+		}
+
+	/* set boot_av_info_ptr */
+	if (boot_av->dwMagicNumber == SWAPEND32(BOOT_AV_INFO_MAGICNO))
+	{
+		boot_av->bHDMImode = sys_logo_is_HDMI;// ignored.
+
+		// enable audio sound
+		if (boot_av->dwAudioStreamLength != 0)
+		{
+			;
+		}
+
+		ipc_shm.pov_boot_av_info = SWAPEND32((uint)(uintptr_t) boot_av);
+
+		#ifdef DUBUG_BOOT_AV_INFO
+		dump_boot_av_info(boot_av);
+		#endif
+	}
+
+	/* Flush caches */
+	flush_dcache_all();
+
+#endif /* CONFIG_SYS_RTK_EMMC_FLASH */
+	return RTK_PLAT_ERR_OK;
+}
+
+
+#ifdef CONFIG_POWER_DOWN_S5
+int start_audio_fw(void)
+{
+#if defined(CONFIG_RTKSPI) && defined(CONFIG_CMD_RTKSPI)
+	SizeT decompressedSize = 0x00300000;
+	SizeT imageSize = CONFIG_AFW_SIZE;
+        unsigned int afw_addr = CONFIG_AFW_ADDR;
+        unsigned int afw_size = CONFIG_AFW_SIZE;
+
+	rtkspi_read32_md(COMPRESSED_FW_IMAGE_ADDR, SPI_RBUS_BASE_ADDR+afw_addr, afw_size);
+	if (lzmaBuffToBuffDecompress((uchar*)MIPS_AUDIO_FW_ENTRY_ADDR, &decompressedSize, (uchar*)COMPRESSED_FW_IMAGE_ADDR, imageSize) != 0)
+	{
+		printf("[ERR] %s:Decompress using LZMA error!!\n", __FUNCTION__);
+
+		return RTK_PLAT_ERR_READ_FW_IMG;
+	}
+#elif defined(CONFIG_RTK_MMC)
+	run_command_list("bootr f", -1, 0);
+#endif
+
+	do_go_audio_fw();
+	return RTK_PLAT_ERR_OK;
+}
+#endif
+
+
+char *rtk_plat_prepare_fw_image_from_USB(int fw_type)
+{
+#ifdef CONFIG_BOOT_FROM_USB
+	char *filename=NULL;
+
+	switch(fw_type)
+	{
+		case FW_TYPE_KERNEL: /* Linux kernel */
+			filename = getenv("rescue_vmlinux");
+			return (filename==NULL)?(char*) CONFIG_RESCUE_FROM_USB_VMLINUX:filename;
+
+		case FW_TYPE_RESCUE_ROOTFS:
+			filename = getenv("rescue_rootfs");
+			return (filename==NULL)?(char*) CONFIG_RESCUE_FROM_USB_ROOTFS:filename;
+
+		case FW_TYPE_KERNEL_ROOTFS:
+			filename = getenv("rootfs");
+			return (filename==NULL)?(char*) CONFIG_NORMAL_FROM_USB_ROOTFS:filename;
+
+		case FW_TYPE_RESCUE_DT:
+			filename = getenv("rescue_dtb");
+			return (filename==NULL)?(char*) CONFIG_RESCUE_FROM_USB_DTB:filename;
+
+		case FW_TYPE_KERNEL_DT:
+			filename = getenv("dtb");
+			return (filename==NULL)?(char*) CONFIG_NORMAL_FROM_USB_DTB:filename;
+
+		case FW_TYPE_AUDIO:
+			filename = getenv("rescue_audio");
+			return (filename==NULL)?(char*) CONFIG_RESCUE_FROM_USB_AUDIO_CORE:filename;
+
+		default:
+			printf("Unknown FW (%d):\n", fw_type);
+			return NULL;
+	}
+#endif
+	return NULL;
+}
+
+#if defined(CONFIG_SYS_RTK_EMMC_FLASH) || defined(CONFIG_BOOT_FROM_SPI) || defined(CONFIG_SYS_RTK_NAND_FLASH)
+static int rtk_plat_parse_fwdesc(fwdesc_args_t *fwdesc_args,
+        uint fw_desc_table_addr, int (*read_func)(uint, uint, uint*))
+{
+	fw_desc_table_v1_t fw_desc_table_v1;
+	part_desc_entry_v1_t *part_entry;
+	fw_desc_entry_v1_t *fw_entry, *fw_entry_v1;
+	fw_desc_entry_v2_t *fw_entry_v2;
+	fw_desc_entry_v11_t *fw_entry_v11;
+	fw_desc_entry_v21_t *fw_entry_v21;
+	fw_desc_entry_v12_t *fw_entry_v12;
+	fw_desc_entry_v22_t *fw_entry_v22;
+	uint part_count = 0;
+	uint fw_entry_num = 0;
+	uint fw_entry_size = 0;
+	uchar fw_desc_version;
+	uint fw_desc_table_base;
+	uint checksum;
+	int i;
+
+
+	fw_desc_table_base = FIRMWARE_DESCRIPTION_TABLE_ADDR;
+
+	/* copy Firmware Description Table Header from flash */
+	if (!(*read_func)(fw_desc_table_addr, sizeof(fw_desc_table_v1_t), (uint *)(uintptr_t)fw_desc_table_base))
+	{
+		printf("[ERR] %s:Read fw_desc_table_v1_t error! (0x%x, 0x%lu, 0x%x)\n",
+			__FUNCTION__, fw_desc_table_addr, sizeof(fw_desc_table_v1_t), fw_desc_table_base);
+
+		return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+	else
+	{
+		memcpy(&fw_desc_table_v1, (void*)(uintptr_t)fw_desc_table_base, sizeof(fw_desc_table_v1_t));
+	}
+
+	/* Check signature first! */
+	if (strncmp((const char *)fw_desc_table_v1.signature,
+			FIRMWARE_DESCRIPTION_TABLE_SIGNATURE,
+			sizeof(fw_desc_table_v1.signature)) != 0)
+	{
+		printf("[ERR] %s:Signature(%s) error!\n", __FUNCTION__, fw_desc_table_v1.signature);
+		return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+
+	fw_desc_table_v1.checksum = BE32_TO_CPU(fw_desc_table_v1.checksum);
+	fw_desc_table_v1.paddings = BE32_TO_CPU(fw_desc_table_v1.paddings);
+	fw_desc_table_v1.part_list_len = BE32_TO_CPU(fw_desc_table_v1.part_list_len);
+	fw_desc_table_v1.fw_list_len = BE32_TO_CPU(fw_desc_table_v1.fw_list_len);
+	// In boot32 doesn't do the Big Endian
+
+#ifdef DUBUG_FW_DESC_TABLE
+	dump_fw_desc_table_v1(&fw_desc_table_v1);
+#endif
+
+	/* copy Firmware Description/Partition/Fw_entry Tables from flash */
+	if (!(*read_func)(fw_desc_table_addr, fw_desc_table_v1.paddings, (uint *)(uintptr_t)fw_desc_table_base))
+	{
+		printf("[ERR] %s:Read all fw tables error! (0x%x, 0x%x, 0x%x)\n",
+			__FUNCTION__, fw_desc_table_addr, fw_desc_table_v1.paddings, fw_desc_table_base);
+
+		return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+
+	/* Check checksum */
+	checksum = get_checksum((uchar*)(uintptr_t)fw_desc_table_base +
+			offsetof(fw_desc_table_v1_t, version),
+			sizeof(fw_desc_table_v1_t) -
+			offsetof(fw_desc_table_v1_t, version) +
+			fw_desc_table_v1.part_list_len +
+			fw_desc_table_v1.fw_list_len);
+
+	if (fw_desc_table_v1.checksum != checksum)
+	{
+		printf("[ERR] %s:Checksum not match(0x%x != 0x%x)\n", __FUNCTION__,
+			fw_desc_table_v1.checksum, checksum);
+
+		return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+
+	/* Check partition existence */
+	if (fw_desc_table_v1.part_list_len == 0)
+	{
+		printf("[ERR] %s:No partition found!\n", __FUNCTION__);
+		//return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+	else
+	{
+		part_count = fw_desc_table_v1.part_list_len / sizeof(part_desc_entry_v1_t);
+	}
+
+	//fw_entry_num = fw_desc_table_v1.fw_list_len / sizeof(fw_desc_entry_v1_t);
+	//printf("[Info] fw desc table base: 0x%08x, count: %d\n", fw_desc_table_addr, fw_entry_num);
+
+	part_entry = (part_desc_entry_v1_t *)(fw_desc_table_base + sizeof(fw_desc_table_v1_t));
+	fw_entry = (fw_desc_entry_v1_t *)(fw_desc_table_base +
+			sizeof(fw_desc_table_v1_t) +
+			fw_desc_table_v1.part_list_len);
+
+	for (i = 0; i < part_count; i++)
+	{
+		part_entry[i].length = BE32_TO_CPU(part_entry[i].length);
+
+#ifdef DUBUG_FW_DESC_TABLE
+		dump_part_desc_entry_v1(&(part_entry[i]));
+#endif
+	}
+
+	/* Check partition type */
+    /*  It so weired that we use part_entry for checking fw count? So we mark it
+	if (part_entry[0].type != PART_TYPE_FW)
+	{
+		printf("[ERR] %s:No firmware partition found!\n", __FUNCTION__);
+
+		return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+*/
+
+
+	fw_desc_version = fw_desc_table_v1.version;
+
+	switch (fw_desc_version) {
+		case FW_DESC_TABLE_V1_T_VERSION_1:
+			fw_entry_num = fw_desc_table_v1.fw_list_len / sizeof(fw_desc_entry_v1_t);
+			fw_entry_size = sizeof(fw_desc_entry_v1_t);
+			break;
+		case FW_DESC_TABLE_V1_T_VERSION_11:
+			fw_entry_num = fw_desc_table_v1.fw_list_len / sizeof(fw_desc_entry_v11_t);
+			fw_entry_size = sizeof(fw_desc_entry_v11_t);
+			break;
+		case FW_DESC_TABLE_V1_T_VERSION_21:
+			fw_entry_num = fw_desc_table_v1.fw_list_len / sizeof(fw_desc_entry_v21_t);
+			fw_entry_size = sizeof(fw_desc_entry_v21_t);
+			break;
+		case FW_DESC_TABLE_V2_T_VERSION_2:
+			fw_entry_num = fw_desc_table_v1.fw_list_len / sizeof(fw_desc_entry_v2_t);
+			fw_entry_size = sizeof(fw_desc_entry_v2_t);
+			break;
+		case FW_DESC_TABLE_V2_T_VERSION_12:
+			fw_entry_num = fw_desc_table_v1.fw_list_len / sizeof(fw_desc_entry_v12_t);
+			fw_entry_size = sizeof(fw_desc_entry_v12_t);
+			break;
+		case FW_DESC_TABLE_V2_T_VERSION_22:
+			fw_entry_num = fw_desc_table_v1.fw_list_len / sizeof(fw_desc_entry_v22_t);
+			fw_entry_size = sizeof(fw_desc_entry_v22_t);
+			break;
+		default:
+			printf("**** Error fw_desc_version 0x%x\n", fw_desc_version);
+			return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+
+#ifdef CONFIG_SYS_RTK_EMMC_FLASH
+	printf("[Info] fw desc table base: 0x%08x, count: %d\n", fw_desc_table_addr*EMMC_BLOCK_SIZE, fw_entry_num);
+#elif defined(CONFIG_SYS_RTK_NAND_FLASH)
+	printf("[Info] fw desc table base: 0x%08x, count: %d\n", fw_desc_table_addr, fw_entry_num);
+#elif defined(CONFIG_BOOT_FROM_SPI)
+	printf("[Info] fw desc table base: 0x%08lx, count: %d\n", fw_desc_table_addr-SPI_RBUS_BASE_ADDR, fw_entry_num);
+#endif
+
+	for (i = 0 ; i < fw_entry_num ; i++) {
+		uint f_version;
+		uint f_target_addr;
+		u64 f_offset;
+		uint f_length;
+		uint f_paddings;
+		//uint f_checksum;
+		void *fw_desc_ptr;
+		//uchar sha_hash[32]; no need to swap
+
+		fw_desc_ptr = (void*)fw_entry + (i * fw_entry_size);
+
+		/* version */
+		FW_ENTRY_MEMBER_GET(f_version, fw_desc_ptr, version, fw_desc_version);
+		FW_ENTRY_MEMBER_SET(BE32_TO_CPU(f_version), fw_desc_ptr, version, fw_desc_version);
+		/* target_addr */
+		FW_ENTRY_MEMBER_GET(f_target_addr, fw_desc_ptr, target_addr, fw_desc_version);
+		FW_ENTRY_MEMBER_SET(BE32_TO_CPU(f_target_addr), fw_desc_ptr, target_addr, fw_desc_version);
+		/* target_offset */
+		FW_ENTRY_MEMBER_GET(f_offset, fw_desc_ptr, offset, fw_desc_version);
+		if (FW_DESC_BASE_VERSION(fw_desc_version) == 1) {
+			FW_ENTRY_MEMBER_SET(BE32_TO_CPU((uint)f_offset),
+				fw_desc_ptr, offset, fw_desc_version);
+		} else {// Version 2
+			FW_ENTRY_MEMBER_SET(BE64_TO_CPU(f_offset),
+				fw_desc_ptr, offset, fw_desc_version);
+		}
+		/* length */
+		FW_ENTRY_MEMBER_GET(f_length, fw_desc_ptr, length, fw_desc_version);
+		FW_ENTRY_MEMBER_SET(BE32_TO_CPU(f_length), fw_desc_ptr, length, fw_desc_version);
+		/* paddings */
+		FW_ENTRY_MEMBER_GET(f_paddings, fw_desc_ptr, paddings, fw_desc_version);
+		FW_ENTRY_MEMBER_SET(BE32_TO_CPU(f_paddings), fw_desc_ptr, paddings, fw_desc_version);
+		/* checksum */
+		if (FW_DESC_BASE_VERSION(fw_desc_version) == 1) {
+			fw_entry_v1 = (fw_desc_entry_v1_t*)fw_desc_ptr;
+			fw_entry_v1->checksum = BE32_TO_CPU(fw_entry_v1->checksum);
+
+			if (fw_desc_version == FW_DESC_TABLE_V1_T_VERSION_11) {
+				fw_entry_v11 = (fw_desc_entry_v11_t*)fw_desc_ptr;
+				printf("[OK] fw_entry[%d] offset = 0x%x length = 0x%x (paddings = 0x%x) act_size = %d part_num = %d\n",
+					i, fw_entry_v1->offset, fw_entry_v1->length, fw_entry_v1->paddings,
+					fw_entry_v11[i].act_size, fw_entry_v11[i].part_num);
+			} else if (fw_desc_version == FW_DESC_TABLE_V1_T_VERSION_21) {
+				fw_entry_v21 = (fw_desc_entry_v21_t*)fw_desc_ptr;
+				printf("[OK] fw_entry[%d] offset = 0x%x length = 0x%x (paddings = 0x%x) act_size = %d part_num = %d\n",
+					i, fw_entry_v1->offset, fw_entry_v1->length, fw_entry_v1->paddings,
+					fw_entry_v21[i].act_size, fw_entry_v21[i].part_num);
+			}
+		} else if (FW_DESC_BASE_VERSION(fw_desc_version) == 2) {
+			fw_entry_v2 = (fw_desc_entry_v2_t*)fw_desc_ptr;
+			if (fw_desc_version == FW_DESC_TABLE_V2_T_VERSION_12) {
+				fw_entry_v12 = (fw_desc_entry_v12_t*)fw_desc_ptr;
+				printf("[OK] fw_entry[%d] offset = 0x%Lx length = 0x%x (paddings = 0x%x) act_size = %d part_num = %d\n",
+					i, fw_entry_v2->offset, fw_entry_v2->length, fw_entry_v2->paddings,
+					fw_entry_v12[i].act_size, fw_entry_v12[i].part_num);
+			} else if (fw_desc_version == FW_DESC_TABLE_V2_T_VERSION_22) {
+				fw_entry_v22 = (fw_desc_entry_v22_t*)fw_desc_ptr;
+				printf("[OK] fw_entry[%d] offset = 0x%Lx length = 0x%x (paddings = 0x%x) act_size = %d part_num = %d\n",
+					i, fw_entry_v2->offset, fw_entry_v2->length, fw_entry_v2->paddings,
+					fw_entry_v22[i].act_size, fw_entry_v22[i].part_num);
+			}
+
+		}
+
+#ifdef DUBUG_FW_DESC_TABLE
+		if (FW_DESC_BASE_VERSION(fw_desc_version) == 1)
+			dump_fw_desc_entry_v1((fw_desc_entry_v1_t*)fw_desc_ptr);
+		else if (FW_DESC_BASE_VERSION(fw_desc_version) == 2)
+			dump_fw_desc_entry_v2((fw_desc_entry_v2_t*)fw_desc_ptr);
+#endif
+	}
+
+	fwdesc_args->fw_desc_table_base = fw_desc_table_base;
+	fwdesc_args->part_entry = part_entry;
+	fwdesc_args->part_count = part_count;
+	fwdesc_args->fw_entry = fw_entry;
+	fwdesc_args->fw_entry_num = fw_entry_num;
+	fwdesc_args->version = fw_desc_table_v1.version;
+#ifdef NAS_DUAL
+	fwdesc_args->seqnum = fw_desc_table_v1.seqnum;
+#endif
+
+	return RTK_PLAT_ERR_OK;
+}
+#endif
+
+/*
+ * Parse firmware description table and read all data from eMMC flash to ram except kernel image.
+ */
+int rtk_plat_prepare_fw_image_from_eMMC(void)
+{
+	int ret = RTK_PLAT_ERR_OK;
+#ifdef CONFIG_SYS_RTK_EMMC_FLASH
+	fwdesc_args_t fwdesc_args = {0};
+	uint fw_desc_table_blk;	// block no of firmware description table
+#ifdef NAS_DUAL
+	uint fwdesc_len;
+	fwdesc_args_t fwdesc_args2 = {0};
+	void *fwdesc;
+	static int boot_fwdesc_seq = 0;
+#endif
+
+#ifdef NAS_DUAL
+	if(boot_mode==BOOT_GOLD_MODE && !boot_fwdesc_seq)
+#else
+	if(boot_mode==BOOT_GOLD_MODE)
+#endif
+	{
+		printf("---------------LOAD  GOLD  FW  TABLE ---------------\n");
+		eMMC_fw_desc_table_start = eMMC_bootcode_area_size + CONFIG_FACTORY_SIZE + CONFIG_FW_TABLE_SIZE;
+	}
+	else
+	{
+		printf("---------------LOAD  NORMAL FW  TABLE ---------------\n");
+		eMMC_fw_desc_table_start = eMMC_bootcode_area_size + CONFIG_FACTORY_SIZE;
+#ifdef NAS_DUAL
+		if(boot_mode==BOOT_GOLD_MODE)
+			boot_mode = BOOT_NORMAL_MODE;
+#endif
+	}
+
+	/* Firmware Description Table is right behind bootcode blocks */
+	fw_desc_table_blk = eMMC_fw_desc_table_start / EMMC_BLOCK_SIZE;
+
+	ret = rtk_plat_parse_fwdesc(&fwdesc_args, fw_desc_table_blk, rtk_eMMC_read);
+	if (RTK_PLAT_ERR_OK != ret)
+		return ret;
+#ifdef NAS_DUAL
+	if(BOOT_GOLD_MODE == boot_mode)
+		printf("[nas-dual]Golden fwdesc tbl seqnum: %d\n",fwdesc_args.seqnum);
+	else
+		printf("[nas-dual]Normal fwdesc tbl seqnum: %d\n",fwdesc_args.seqnum);
+	if(boot_mode != BOOT_GOLD_MODE && !boot_fwdesc_seq) {
+		fwdesc_len = ((fw_desc_table_v1_t*)(uintptr_t)fwdesc_args.fw_desc_table_base)->paddings;
+		fwdesc = (void*)malloc(fwdesc_len);
+		memcpy(fwdesc, (void*)(uintptr_t)fwdesc_args.fw_desc_table_base, fwdesc_len);
+
+		eMMC_fw_desc_table_start = eMMC_bootcode_area_size + CONFIG_FACTORY_SIZE + CONFIG_FW_TABLE_SIZE;
+		fw_desc_table_blk = eMMC_fw_desc_table_start / EMMC_BLOCK_SIZE;
+		ret = rtk_plat_parse_fwdesc(&fwdesc_args2, fw_desc_table_blk, rtk_eMMC_read);
+		if (RTK_PLAT_ERR_OK == ret && \
+                  ((fwdesc_args2.seqnum > fwdesc_args.seqnum) || \
+                   (0 == fwdesc_args2.seqnum && 255 == fwdesc_args.seqnum)) ) {
+			printf("[nas-dual]Golden fwdesc tbl seqnum: %d\n",fwdesc_args2.seqnum);
+			printf("---------------Use second FW  TABLE ---------------\n");
+			memcpy(&fwdesc_args, &fwdesc_args2, sizeof(fwdesc_args_t));
+			boot_fwdesc_seq = 1;
+			boot_mode = BOOT_GOLD_MODE;
+		}
+		/* Restore eMMC_fw_desc_table_start */
+		else {
+			eMMC_fw_desc_table_start = eMMC_bootcode_area_size + CONFIG_FACTORY_SIZE;
+			memcpy((void*)(uintptr_t)fwdesc_args.fw_desc_table_base, fwdesc, fwdesc_len);
+		}
+		free(fwdesc);
+	}
+#endif
+
+	printf("Normal boot fw follow...\n");
+	ret = rtk_plat_read_fw_image_from_eMMC(
+		fwdesc_args.fw_desc_table_base, fwdesc_args.part_entry,
+		fwdesc_args.part_count, fwdesc_args.fw_entry,
+		fwdesc_args.fw_entry_num, fwdesc_args.version);
+#endif
+	return ret;
+}
+
+int rtk_plat_get_fw_desc_table_start(void)
+{
+#ifdef CONFIG_SYS_RTK_NAND_FLASH
+#ifdef NAS_ENABLE
+	struct mtd_info *mtd = &nand_info[0];
+#else
+	struct mtd_info *mtd = &nand_info[nand_curr_device];
+#endif
+	int uboot_768KB = 0xc0000;
+#ifdef NAS_ENABLE
+	int factory_8MB = CONFIG_FACTORY_SIZE;
+#else
+	int factory_8MB = 0x800000;
+#endif
+	int reservedSize;
+
+	reservedSize = 6* mtd->erasesize;  //NF profile + BBT
+	reservedSize += 1*4* mtd->erasesize; //Hw_setting*4
+	reservedSize += 1*4* mtd->erasesize; //FSBL*4
+#ifndef CONFIG_SYS_NO_BL31
+	reservedSize += ALIGN(uboot_768KB ,mtd->erasesize)*4; //TEE*4
+	reservedSize += 1*4* mtd->erasesize; //BL31*4
+	reservedSize += 1*4* mtd->erasesize; //RSA_FW*4
+	reservedSize += 1*4* mtd->erasesize; //RSA_TEE*4
+#endif
+	reservedSize += ALIGN(uboot_768KB ,mtd->erasesize)*4;
+	reservedSize += ALIGN(factory_8MB ,mtd->erasesize);
+
+	return reservedSize;
+#endif
+	return 0;
+}
+
+/*
+ * Parse firmware description table and read all data from NAND flash to ram except kernel image.
+ */
+int rtk_plat_prepare_fw_image_from_NAND(void)
+{
+	int ret = RTK_PLAT_ERR_OK;
+#ifdef CONFIG_SYS_RTK_NAND_FLASH
+	struct mtd_info *mtd = &nand_info[nand_curr_device];
+	fwdesc_args_t fwdesc_args = {0};
+
+	nand_fw_desc_table_start = rtk_plat_get_fw_desc_table_start();
+	if(boot_mode==BOOT_GOLD_MODE)
+	{
+		printf("---------------LOAD  GOLD  FW  TABLE ---------------\n");
+		nand_fw_desc_table_start += mtd->erasesize;
+	}
+	else
+	{
+		printf("---------------LOAD  NORMAL FW  TABLE ---------------\n");
+	}
+
+	ret = rtk_plat_parse_fwdesc(&fwdesc_args, nand_fw_desc_table_start, rtknand_read);
+
+	if (RTK_PLAT_ERR_OK != ret)
+		return ret;
+
+	printf("Normal boot fw follow...\n");
+	ret = rtk_plat_read_fw_image_from_NAND(
+		fwdesc_args.fw_desc_table_base, fwdesc_args.part_entry,
+		fwdesc_args.part_count, fwdesc_args.fw_entry,
+		fwdesc_args.fw_entry_num, fwdesc_args.version);
+#endif
+
+	return ret;
+}
+
+/*
+ * Parse firmware description table and read all data from SPI flash to ram except kernel image.
+ */
+//#define SPI_MTD_DEBUG
+int rtk_plat_prepare_fw_image_from_SPI(void)
+{
+	int ret = RTK_PLAT_ERR_OK;
+#ifdef CONFIG_SPI_MTD_STATIC
+	int i;
+	SizeT decompressedSize;
+	SizeT imageSize;
+	unsigned long target_addr;
+	boot_av_info_t *boot_av;
+	const fw_type_code_t spi_mtd_fws[] = {
+		FW_TYPE_IMAGE_FILE
+		,FW_TYPE_AUDIO
+                ,FW_TYPE_KERNEL_DT
+                ,FW_TYPE_KERNEL
+                ,FW_TYPE_KERNEL_ROOTFS
+	};
+	const int fw_num = sizeof(spi_mtd_fws)/sizeof(fw_type_code_t);
+	const unsigned int src_offset[] = {
+		CONFIG_LOGO_ADDR
+		,CONFIG_AFW_ADDR
+		,CONFIG_DTS_BASE
+		,CONFIG_KERNEL_ADDR
+		,CONFIG_ROOTFS_ADDR
+	};
+	const unsigned int img_size[] = {
+		CONFIG_LOGO_SIZE
+		,CONFIG_AFW_SIZE
+		,CONFIG_DTS_SIZE
+		,CONFIG_KERNEL_SIZE
+		,CONFIG_ROOTFS_SIZE
+	};
+	const char *target_addr_env[] = {
+		"logo_loadaddr"
+		,"audio_loadaddr"
+		,"fdt_loadaddr"
+		,"kernel_loadaddr"
+		,"rootfs_loadaddr"
+	};
+	const unsigned long target_addr_default[] = {
+		0x2600000
+		,CONFIG_FW_LOADADDR
+		,CONFIG_FDT_LOADADDR
+		,CONFIG_KERNEL_LOADADDR
+		,CONFIG_ROOTFS_LOADADDR
+	};
+	char buffer[CONFIG_SYS_CBSIZE] = "BOOTDEV=";
+	const char *bootdevice = getenv("bootdevice");
+#endif
+
+#ifdef CONFIG_BOOT_FROM_SPI
+	fwdesc_args_t fwdesc_args = {0};
+	unsigned int _iSPI_base_addr;
+
+        printf("---------------LOAD  NORMAL FW  TABLE ---------------\n");
+	_iSPI_base_addr = SPI_RBUS_BASE_ADDR + spi_fw_desc_table_start;
+
+	ret = rtk_plat_parse_fwdesc(&fwdesc_args, _iSPI_base_addr, rtkspi_read);
+
+	if (RTK_PLAT_ERR_OK != ret)
+		return ret;
+
+	printf("Normal boot fw follow...\n");
+	ret = rtk_plat_read_fw_image_from_SPI(
+		fwdesc_args.fw_desc_table_base, fwdesc_args.part_entry,
+		fwdesc_args.part_count, fwdesc_args.fw_entry,
+		fwdesc_args.fw_entry_num, fwdesc_args.version);
+#if defined(CONFIG_BFS_SUPPORT_BACKUP_SPI_IMG)
+	if (RTK_PLAT_ERR_OK != ret) {
+		printf(VT100_LIGHT_GREEN"---------------LOAD  BACKUP FW  TABLE ---------------\n"VT100_NONE);
+		_iSPI_base_addr = SPI_RBUS_BASE_ADDR + spi_fw_desc_table_start + 0x8000;
+
+		ret = rtk_plat_parse_fwdesc(&fwdesc_args, _iSPI_base_addr, rtkspi_read);
+
+		if (RTK_PLAT_ERR_OK != ret)
+			return ret;
+
+		printf(VT100_LIGHT_GREEN"Backup boot fw follow...\n"VT100_NONE);
+		ret = rtk_plat_read_fw_image_from_SPI(
+			fwdesc_args.fw_desc_table_base, fwdesc_args.part_entry,
+			fwdesc_args.part_count, fwdesc_args.fw_entry,
+			fwdesc_args.fw_entry_num, fwdesc_args.version);
+	}
+#endif
+
+#elif defined(CONFIG_SPI_MTD_STATIC)
+	/* clear boot_av_info memory */
+	boot_av = (boot_av_info_t *) MIPS_BOOT_AV_INFO_ADDR;
+	memset(boot_av, 0, sizeof(boot_av_info_t));
+
+	for (i=0; i<fw_num; i++) {
+		/* Target address precedence: env addr > default addr */
+		target_addr = (target_addr_env[i])?
+                  getenv_ulong(target_addr_env[i],16,target_addr_default[i]):
+                    target_addr_default[i];
+		/* No compression on kernel DTB and initrd */
+		switch (spi_mtd_fws[i])
+		{
+			case FW_TYPE_KERNEL_ROOTFS:
+				memset((void*)target_addr, 0, CONFIG_INITRD_SIZE);
+			case FW_TYPE_KERNEL_DT:
+				rtkspi_read32_md(target_addr, SPI_RBUS_BASE_ADDR+src_offset[i], img_size[i]);
+				if(Verify_SHA256_hash((unsigned char *)target_addr, img_size[i]-32, (unsigned char *)(target_addr + img_size[i] - 32), 0, NULL)) {
+					return RTK_PLAT_ERR_READ_FW_IMG;
+				}
+				memset((void*)(target_addr+img_size[i]-32), 0, 32);
+				continue;
+				break;
+			default:
+				break;
+		}
+		rtkspi_read32_md(COMPRESSED_FW_IMAGE_ADDR, SPI_RBUS_BASE_ADDR+src_offset[i], img_size[i]);
+		if(Verify_SHA256_hash((unsigned char *)(uintptr_t)COMPRESSED_FW_IMAGE_ADDR, img_size[i]-32, (unsigned char *)(uintptr_t)(COMPRESSED_FW_IMAGE_ADDR + img_size[i] - 32), 0, NULL)) {
+#ifndef SPI_MTD_DEBUG
+			if (FW_TYPE_IMAGE_FILE == spi_mtd_fws[i] || FW_TYPE_AUDIO == spi_mtd_fws[i]) continue;
+#endif
+			return RTK_PLAT_ERR_READ_FW_IMG;
+		}
+		memset((void*)(uintptr_t)(COMPRESSED_FW_IMAGE_ADDR+img_size[i]-32), 0, 32);
+
+		decompressedSize = 0;
+		imageSize = img_size[i];
+		if (lzmaBuffToBuffDecompress((uchar*)target_addr, &decompressedSize, (uchar*)COMPRESSED_FW_IMAGE_ADDR, imageSize) != 0)
+		{
+			printf("[ERR] %s:Decompress using LZMA error!!\n", __FUNCTION__);
+#ifndef SPI_MTD_DEBUG
+			if (FW_TYPE_IMAGE_FILE == spi_mtd_fws[i] || FW_TYPE_AUDIO == spi_mtd_fws[i]) continue;
+#endif
+			return RTK_PLAT_ERR_READ_FW_IMG;
+		}
+		if(FW_TYPE_AUDIO == spi_mtd_fws[i]) {
+			ipc_shm.audio_fw_entry_pt = CPU_TO_BE32(target_addr | MIPS_KSEG0BASE);
+		}
+		else if(boot_logo_enable && FW_TYPE_IMAGE_FILE == spi_mtd_fws[i]) {
+			boot_av-> logo_addr = CPU_TO_BE32(target_addr);
+		}
+	}
+
+	if(bootdevice) {
+		strncat(buffer, bootdevice, strlen(bootdevice));
+		setenv("nas_part", buffer);
+	}
+
+	/* assign boot_av structure */
+	boot_av->dwMagicNumber = SWAPEND32(BOOT_AV_INFO_MAGICNO);
+	if(boot_logo_enable)
+	{
+		boot_av-> logo_enable = boot_logo_enable;
+		boot_av-> src_width = CPU_TO_BE32(custom_logo_src_width);
+		boot_av-> src_height = CPU_TO_BE32(custom_logo_src_height);
+		boot_av-> dst_width = CPU_TO_BE32(custom_logo_dst_width);
+		boot_av-> dst_height = CPU_TO_BE32(custom_logo_dst_height);
+	}
+	boot_av->bHDMImode = sys_logo_is_HDMI;// ignored.
+	ipc_shm.pov_boot_av_info = SWAPEND32((uint)(uintptr_t) boot_av);
+	/* Flush caches */
+	flush_dcache_all();
+
+	if (boot_from_flash == BOOT_FROM_FLASH_NORMAL_MODE) {
+		do_go_audio_fw();
+	}
+#endif
+
+	return ret;
+}
+
+/*
+ * Parse firmware description table and read all data from SD flash to ram except kernel image.
+ */
+int rtk_plat_prepare_fw_image_from_SD(void)
+{
+	int ret = RTK_PLAT_ERR_OK;
+
+#if 0 // for SD
+	// add your code here
+#endif
+
+	ret = rtk_plat_read_fw_image_from_SD();
+
+	return ret;
+}
+
+/*
+ * Parse firmware description table and read all data from SATA to ram except kernel image.
+ */
+int rtk_plat_prepare_fw_image_from_SATA(void)
+{
+	int ret = RTK_PLAT_ERR_OK;
+#ifdef CONFIG_SYS_RTK_SATA_STORAGE
+	fw_desc_table_v1_t fw_desc_table_v1;
+	part_desc_entry_v1_t *part_entry;
+	fw_desc_entry_v1_t *fw_entry;
+	//fw_desc_entry_v1_t *fw_entry_v1;
+	//fw_desc_entry_v11_t *fw_entry_v11;
+	//fw_desc_entry_v21_t *fw_entry_v21;
+	uint part_count = 0;
+	uint fw_total_len;
+	uint fw_total_paddings;
+	uint fw_entry_num = 0;
+	uint fw_desc_table_base;
+	uint fw_desc_table_blk;	// block no of firmware description table
+	uint checksum;
+	int i;
+
+	if (sata_curr_device == -1) {
+		if (sata_initialize()) {
+			printf("---------------SATA init fail, try again ---------------\n");
+			if (sata_initialize()) {
+				printf("---------------No SATA device ---------------\n");
+				return RTK_PLAT_ERR_BOOT;
+			}
+		}
+	}
+
+    if(boot_mode==BOOT_GOLD_MODE)
+    {
+        printf("---------------LOAD  GOLD  FW  TABLE (%d) ---------------\n", boot_mode);
+    }
+    else if(boot_mode==BOOT_RESCUE_MODE)
+    {
+        printf("---------------LOAD  RESCUE FW  TABLE (%d) ---------------\n", boot_mode);
+    }
+    else if(boot_mode==BOOT_ANDROID_MODE)
+    {
+        printf("---------------LOAD  NORMAL FW  TABLE(%d) ---------------\n", boot_mode);
+    }
+    else
+    {
+        printf("---------------LOAD  NORMAL FW  TABLE(%d) ---------------\n", boot_mode);
+    }
+
+    sata_fw_desc_table_start = 0x4400;
+	fw_desc_table_base = FIRMWARE_DESCRIPTION_TABLE_ADDR; /* 0x06400000 */
+
+	/* Firmware Description Table is right behind bootcode blocks */
+	fw_desc_table_blk = sata_fw_desc_table_start / 512;
+
+	/* copy Firmware Description Table Header from flash */
+	if (!rtk_sata_read(fw_desc_table_blk, sizeof(fw_desc_table_v1_t), (uint *)(uintptr_t)fw_desc_table_base))
+	{
+		printf("[ERR] %s:Read fw_desc_table_v1_t error! (0x%x, 0x%x, 0x%x)\n",
+			__FUNCTION__, (unsigned int)fw_desc_table_blk, (unsigned int)sizeof(fw_desc_table_v1_t), (unsigned int)fw_desc_table_base);
+
+		return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+	else
+	{
+		memcpy(&fw_desc_table_v1, (void*)(uintptr_t)fw_desc_table_base, sizeof(fw_desc_table_v1_t));
+	}
+
+	/* Check signature first! */
+	if (strncmp((const char *)fw_desc_table_v1.signature,
+			FIRMWARE_DESCRIPTION_TABLE_SIGNATURE,
+			sizeof(fw_desc_table_v1.signature)) != 0)
+	{
+		printf("[ERR] %s:Signature(%s) error!\n", __FUNCTION__, fw_desc_table_v1.signature);
+		return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+
+	fw_desc_table_v1.checksum = BE32_TO_CPU(fw_desc_table_v1.checksum);
+	fw_desc_table_v1.paddings = BE32_TO_CPU(fw_desc_table_v1.paddings);
+	fw_desc_table_v1.part_list_len = BE32_TO_CPU(fw_desc_table_v1.part_list_len);
+	fw_desc_table_v1.fw_list_len = BE32_TO_CPU(fw_desc_table_v1.fw_list_len);
+
+#ifdef DUBUG_FW_DESC_TABLE
+	dump_fw_desc_table_v1(&fw_desc_table_v1);
+#endif
+
+	/* copy Firmware Description/Partition/Fw_entry Tables from flash */
+	if (!rtk_sata_read(fw_desc_table_blk, fw_desc_table_v1.paddings, (uint *)(uintptr_t)fw_desc_table_base))
+	{
+		printf("[ERR] %s:Read all fw tables error! (0x%x, 0x%x, 0x%x)\n",
+			__FUNCTION__, fw_desc_table_blk, fw_desc_table_v1.paddings, fw_desc_table_base);
+
+		return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+
+	/* Check checksum */
+	checksum = get_checksum((uchar*)(uintptr_t)fw_desc_table_base +
+			offsetof(fw_desc_table_v1_t, version),
+			sizeof(fw_desc_table_v1_t) -
+			offsetof(fw_desc_table_v1_t, version) +
+			fw_desc_table_v1.part_list_len +
+			fw_desc_table_v1.fw_list_len);
+
+	if (fw_desc_table_v1.checksum != checksum)
+	{
+		printf("[ERR] %s:Checksum not match(0x%x != 0x%x)\n", __FUNCTION__,
+			fw_desc_table_v1.checksum, checksum);
+
+		return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+
+	/* Check partition existence */
+	if (fw_desc_table_v1.part_list_len == 0)
+	{
+		printf("[ERR] %s:No partition found!\n", __FUNCTION__);
+		//return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+	else
+	{
+		part_count = fw_desc_table_v1.part_list_len / sizeof(part_desc_entry_v1_t);
+	}
+
+	fw_entry_num = fw_desc_table_v1.fw_list_len / sizeof(fw_desc_entry_v1_t);
+	printf("[Info] fw desc table base: 0x%08x, count: %d\n", sata_fw_desc_table_start, fw_entry_num);
+
+	part_entry = (part_desc_entry_v1_t *)(fw_desc_table_base + sizeof(fw_desc_table_v1_t));
+	fw_entry = (fw_desc_entry_v1_t *)(fw_desc_table_base +
+			sizeof(fw_desc_table_v1_t) +
+			fw_desc_table_v1.part_list_len);
+
+	for (i = 0; i < part_count; i++)
+	{
+		part_entry[i].length = BE32_TO_CPU(part_entry[i].length);
+
+#ifdef DUBUG_FW_DESC_TABLE
+		dump_part_desc_entry_v1(&(part_entry[i]));
+#endif
+	}
+
+	/* Check partition type */
+    /*  It so weired that we use part_entry for checking fw count? So we mark it
+	if (part_entry[0].type != PART_TYPE_FW)
+	{
+		printf("[ERR] %s:No firmware partition found!\n", __FUNCTION__);
+
+		return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+    */
+	fw_total_len = 0;
+	fw_total_paddings = 0;
+
+	/* Parse firmware entries and compute fw_total_len */
+	switch (fw_desc_table_v1.version)
+	{
+		case FW_DESC_TABLE_V1_T_VERSION_1:
+			fw_entry_num = fw_desc_table_v1.fw_list_len / sizeof(fw_desc_entry_v1_t);
+
+			for (i = 0; i < fw_entry_num; i++)
+			{
+				fw_entry[i].version     = BE32_TO_CPU(fw_entry[i].version);
+				fw_entry[i].target_addr = BE32_TO_CPU(fw_entry[i].target_addr);
+				fw_entry[i].offset      = BE32_TO_CPU(fw_entry[i].offset);
+				fw_entry[i].length      = BE32_TO_CPU(fw_entry[i].length);
+				fw_entry[i].paddings    = BE32_TO_CPU(fw_entry[i].paddings);
+				fw_entry[i].checksum    = BE32_TO_CPU(fw_entry[i].checksum);
+
+#ifdef DUBUG_FW_DESC_TABLE
+				dump_fw_desc_entry_v1(&(fw_entry[i]));
+#endif
+
+				fw_total_len += fw_entry[i].length;
+				fw_total_paddings += fw_entry[i].paddings;
+			}
+
+
+			break;
+
+		case FW_DESC_TABLE_V1_T_VERSION_11:
+			// remove unusing code
+			printf("****** %s %d, not implement\n", __FUNCTION__, __LINE__);
+			break;
+
+		case FW_DESC_TABLE_V1_T_VERSION_21:
+			// remove unusing code
+			printf("****** %s %d, not implement\n", __FUNCTION__, __LINE__);
+			break;
+
+		default:
+			printf("[ERR] %s:unknown version:%d\n", __FUNCTION__, fw_desc_table_v1.version);
+			return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+
+	if(sata_boot_debug) {
+		return RTK_PLAT_ERR_PARSE_FW_DESC;
+	}
+
+	printf("Start loading fw (mode %d)...\n", boot_mode);
+
+	ret = rtk_plat_read_fw_image_from_SATA(
+		fw_desc_table_base, part_entry, part_count,
+		fw_entry, fw_entry_num,
+		fw_desc_table_v1.version);
+
+#endif // CONFIG_SYS_RTK_SATA_STORAGE
+
+	return ret;
+}
+
+//#define DEBUG_SKIP_BOOT_ALL
+//#define DEBUG_SKIP_BOOT_LINUX
+//#define DEBUG_SKIP_BOOT_AV
+#ifdef CONFIG_SYS_RTK_NAND_FLASH
+extern int rtk_plat_boot_prep_partition(void);
+#endif
+#if (defined(CONFIG_RTD1295) || defined(CONFIG_RTD1395)) && defined(NAS_ENABLE)
+extern int rtk_plat_boot_prep_nas_partition(void);
+#endif
+
+static int rtk_call_booti(void)
+{
+	char *booti_argv[] = { "booti", NULL, "-", NULL, NULL };
+	int ret = 0;
+	int j;
+	int argc=4;
+
+	if (getenv("hyp_loadaddr")) {
+		booti_argv[1] = getenv("hyp_loadaddr");
+	} else if ((booti_argv[1] = getenv("kernel_loadaddr")) == NULL) {
+		booti_argv[1] =(char*) CONFIG_KERNEL_LOADADDR;
+	}
+
+	if ((booti_argv[3] = getenv("fdt_loadaddr")) == NULL) {
+		booti_argv[3] =(char*) CONFIG_FDT_LOADADDR;
+	}
+#ifdef CONFIG_NAS_ENABLE
+	void *fdt_addr = (void*)simple_strtoul(booti_argv[3], NULL, 16);
+
+	int nodeoffset;
+	struct fdt_property *prop;
+	int err, oldlen, newlen;
+	char *str = NULL;
+
+	if(!fdt_check_header(fdt_addr)) {
+		nodeoffset = fdt_find_or_add_subnode(fdt_addr, 0, "chosen");
+		if(nodeoffset >= 0){
+			prop = fdt_get_property_w(fdt_addr, nodeoffset, "bootargs", &oldlen);
+			if (prop) {
+				newlen = oldlen+8+strlen(PLAIN_VERSION)+2+strlen(U_BOOT_DATE)+3+strlen(U_BOOT_TIME)+1+1;
+				str = (char *)malloc(newlen);
+				if (str) {
+					memset(str, 0, newlen);
+					memcpy(str, prop->data, oldlen);
+					sprintf(str+oldlen-1, " U-boot=%s (%s - %s)",
+						PLAIN_VERSION, U_BOOT_DATE, U_BOOT_TIME);
+				}
+				err = fdt_setprop_string(fdt_addr, nodeoffset, "bootargs", str);
+				if (err < 0) {
+					printf("WARNING: could not set version in bootargs %s.\n",
+					       fdt_strerror(err));
+				}
+				if (str)
+					free(str);
+			}
+
+		}
+	}
+#endif
+
+	/*
+	 * - do the work -
+	 * exec subcommands of do_booti to init the images
+	 * data structure
+	 */
+	debug("booti_argv ={ ");
+	for (j = 0; j < argc; j++)
+			debug("%s,",booti_argv[j]);
+	debug("}\n");
+
+#ifdef CONFIG_SYS_RTK_NAND_FLASH
+	rtk_plat_boot_prep_partition();
+#endif
+#if (defined(CONFIG_RTD1295) || defined(CONFIG_RTD1395)) && defined(NAS_ENABLE)
+	rtk_plat_boot_prep_nas_partition();
+#endif
+
+#ifdef CONFIG_CMD_RTKFDT
+	extern void rtkfdt_add_factory(void);
+	DDDDYELLOW("[Info] convert some env variable to fdt:factory node\n");
+	rtkfdt_add_factory();
+#endif
+
+	ret = do_booti(find_cmd("do_booti"), 0, argc, booti_argv);
+
+	if (ret) {
+		printf("ERROR do_booti failed!\n");
+		return -1;
+	}
+
+	return 1;
+}
+
+int rtk_plat_set_fw(void)
+{
+	int ret = RTK_PLAT_ERR_OK;
+	//char cmd[16];
+	int magic = SWAPEND32(0x16803001);
+	int offset = SWAPEND32(MIPS_SHARED_MEMORY_ENTRY_ADDR);
+
+	printf("Start Boot Setup ... ");
+
+	/* reset some shared memory */
+	reset_shared_memory();
+
+#ifdef DEBUG_SKIP_BOOT_ALL // Skip by CK
+	printf("(CK skip)\n");
+	return RTK_PLAT_ERR_PARSE_FW_DESC;
+#else
+	printf("\n");
+#endif
+	if (boot_from_usb != BOOT_FROM_USB_DISABLE) // workaround path that read fw img from usb
+	{
+		ret = rtk_plat_read_fw_image_from_USB(0);
+	}
+	else
+	{
+		/* parse fw_desc_table, and read all data from flash to ram except kernel image */
+		if (boot_flash_type == BOOT_EMMC)
+		{
+			/* For eMMC */
+			ret = rtk_plat_prepare_fw_image_from_eMMC();
+		}
+		else if (boot_flash_type == BOOT_SATA)
+		{
+			/* For SATA */
+			ret = rtk_plat_prepare_fw_image_from_SATA();
+		}
+		else if (boot_flash_type == BOOT_NAND)
+		{
+			/* For NAND */
+			ret = rtk_plat_prepare_fw_image_from_NAND();
+		}
+		else if (boot_flash_type == BOOT_SD)
+		{
+			/* For SD */
+			ret = rtk_plat_prepare_fw_image_from_SD();
+		}
+		else
+		{
+#ifdef CONFIG_BOOT_FROM_SATA
+			ret = rtk_plat_prepare_fw_image_from_SATA();
+#else
+			/* For SPI */
+			ret = rtk_plat_prepare_fw_image_from_SPI();
+#ifdef CONFIG_BOOT_FROM_USB
+			if(ret == RTK_PLAT_ERR_OK)
+				ret = rtk_plat_read_fw_image_from_USB(0);
+#endif /* CONFIG_BOOT_FROM_USB */
+#endif /* CONFIG_BOOT_FROM_SATA */
+		}
+	}
+
+#if CONFIG_ANDROID_RECOVERY
+    /* factory save ---------work space----------------*/
+    //gen recovery signature(update.zip from backup partition).
+    if((ret == RTK_PLAT_ERR_OK) && (boot_mode == BOOT_GOLD_MODE))
+    {
+        printf("------------recovery write start--------------\n");
+
+        /* write in emmc */
+        bootloader_message *boot=(bootloader_message *)BACKUP_DESCRIPTION_RECOVERY_ADDR;
+        memset(boot, 0, sizeof(bootloader_message));
+        memset(boot->command, '\0', sizeof(boot->command));
+        memset(boot->recovery, '\0', sizeof(boot->recovery));
+        sprintf(boot->command, "boot-recovery");
+        sprintf(boot->recovery, "recovery\n--update_package=BACKUP:update.zip\n--locale=en_GB");
+
+#ifdef CONFIG_SYS_FACTORY
+    	ret = factory_write(RECOVERY_FILE_IN_FACTORY, (char *)boot, CONFIG_RECOVERY_SIZE);
+		if (ret != 0)
+        {
+            // failed case
+    		printf("[ENV] write_recovery failed\n");
+    	}
+    	else
+		    factory_save();
+#else
+	    printf("[ENV][WARN] CONFIG_SYS_FACTORY is not defined.\n");
+#endif
+        printf("------------recovery write end--------------\n");
+        ret = RTK_PLAT_ERR_OK;
+    }
+#endif
+#ifndef DEBUG_SKIP_BOOT_AV // mark for boot linux kernel only
+	if (boot_from_flash == BOOT_FROM_FLASH_NORMAL_MODE)
+	{
+		if (ret == RTK_PLAT_ERR_OK)
+		if(!accelerate_state && !audio_fw_state)
+		{
+			/* Enable ACPU */
+			if (ipc_shm.audio_fw_entry_pt != 0){
+				printf("Start A/V Firmware ...\n");
+				memcpy((unsigned char *)(MIPS_SHARED_MEMORY_ENTRY_ADDR+0xC4), &ipc_shm, sizeof(ipc_shm));
+				memcpy((unsigned char *)(MIPS_SHARED_MEMORY_ENTRY_ADDR), &magic, sizeof(magic));
+				memcpy((unsigned char *)(MIPS_SHARED_MEMORY_ENTRY_ADDR +4), &offset, sizeof(offset));
+				flush_dcache_all();
+#ifdef CONFIG_RTD1395
+				rtd_outl(ACPU_STARTUP_FLAG, ACPU_MAGIC1); //write magic1
+#else
+				rtd_outl(ISO_RESERVED_USE_3, MIPS_A_ENTRY_CODE_ADDR | MIPS_KSEG1BASE);
+#endif
+				rtd_setbits(CLOCK_ENABLE2_reg,_BIT4);
+				audio_fw_state = 1;
+#ifdef CONFIG_WAIT_AFW_1_SECOND
+				mdelay(1000);
+#endif
+			}
+		}
+	}
+	else
+	{
+		printf("[Skip A] boot manual mode\n");
+	}
+#endif
+
+	return ret;
+}
+
+static void gmt_g2227_set_mode(void)
+{
+#ifdef CONFIG_GMT_G2227
+
+#ifdef CONFIG_BOOT_DCDC1_FORCE_PWM
+      run_command("pmic set dcdc1_mode force_pwm", 0);
+#endif
+
+#ifdef CONFIG_BOOT_DCDC2_FORCE_PWM
+	run_command("pmic set dcdc2_mode force_pwm", 0);
+#endif
+
+#ifdef CONFIG_BOOT_DCDC3_FORCE_PWM
+	run_command("pmic set dcdc3_mode force_pwm", 0);
+#endif
+
+#ifdef CONFIG_BOOT_DCDC4_FORCE_PWM
+	run_command("pmic set dcdc4_mode force_pwm", 0);
+#endif
+
+#ifdef CONFIG_BOOT_DCDC5_FORCE_PWM
+	run_command("pmic set dcdc5_mode force_pwm", 0);
+#endif
+
+#ifdef CONFIG_BOOT_DCDC6_FORCE_PWM
+	run_command("pmic set dcdc6_mode force_pwm", 0);
+#endif
+
+#endif /* CONFIG_GMT_G2227 */
+}
+
+
+
+//all standard boot_cmd entry.
+int rtk_plat_do_boot_linux(void)
+{
+	gmt_g2227_set_mode();
+
+	rtk_call_booti();
+
+	/* Reached here means jump to kernel entry flow failed */
+
+	return RTK_PLAT_ERR_BOOT;
+
+}
+/*
+ ************************************************************************
+ *
+ * This is the final part before booting Linux in realtek platform:
+ * we need to move audio/video firmware and stream files
+ * from flash to ram. We will also decompress or decrypt image files,
+ * if necessary, which depends on the information from flash writer.
+ *
+ ************************************************************************
+ */
+#ifdef CONFIG_CUSTOMIZE_BOOTFLOW_1
+extern int normal_boot;
+#endif
+int  rtk_plat_boot_handler(void)
+{
+	int ret = RTK_PLAT_ERR_OK;
+
+	/* copy audio/video firmware and stream files from flash to ram */
+	ret = rtk_plat_set_fw();
+
+	if (ret == RTK_PLAT_ERR_OK)
+	{
+#ifndef DEBUG_SKIP_BOOT_LINUX
+		if (boot_from_flash == BOOT_FROM_FLASH_NORMAL_MODE)
+		{
+			/* go Linux */
+#ifdef CONFIG_REALTEK_WATCHDOG
+			WATCHDOG_KICK();
+#else
+			WATCHDOG_DISABLE();
+#endif
+
+			EXECUTE_CUSTOMIZE_FUNC(1); // insert execute customer callback at here
+
+#ifdef CONFIG_CUSTOMIZE_BOOTFLOW_1
+			if (normal_boot)
+				ret = rtk_plat_do_boot_linux ();
+			else
+				printf("Skip Normal BOOT flow\n");
+#else
+			ret = rtk_plat_do_boot_linux ();
+#endif
+
+		}
+		else
+		{
+			printf("[Skip K] boot manual mode (execute \"go all\")\n");
+		}
+#endif
+	}
+
+	return ret;
+}
+
+int rtk_plat_do_bootr(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret = RTK_PLAT_ERR_OK;
+
+	/* reset boot flags */
+	boot_from_flash = BOOT_FROM_FLASH_NORMAL_MODE;
+	boot_from_usb = BOOT_FROM_USB_DISABLE;
+
+	/* parse option */
+	if (argc == 1)
+	{
+		boot_from_usb = BOOT_FROM_USB_DISABLE;
+	}
+	else if (argc == 2 && argv[1][0] == 'u')
+	{
+		if (argv[1][1] == 'z')
+		{
+			boot_from_usb = BOOT_FROM_USB_COMPRESSED;
+		}
+		else if (argv[1][1] == '\0')
+		{
+			boot_from_usb = BOOT_FROM_USB_UNCOMPRESSED;
+		}
+		else
+		{
+			return CMD_RET_USAGE;
+		}
+	}
+	else if (argc == 2 && argv[1][0] == 'm')
+	{
+		boot_from_flash = BOOT_FROM_FLASH_MANUAL_MODE;
+	}
+#ifndef NAS_DUAL
+	else if (argc == 2 && argv[1][0] == 'f')
+	{
+		boot_from_flash = BOOT_FROM_FLASH_MANUAL_MODE;
+		accelerate_state = 1;
+		/*The bootr f command is for faster blue logo*/
+	}
+#endif
+	else
+	{
+		return CMD_RET_USAGE;
+	}
+
+	WATCHDOG_KICK();
+	ret = rtk_plat_boot_handler();
+
+    if (ret != RTK_PLAT_ERR_OK) {
+#if defined(NAS_ENABLE) && defined(CONFIG_SPI_MTD_STATIC)
+#if defined(CONFIG_CMD_NET)
+	ret = run_command("run upgrade_img_tftp", 0);
+#endif // tftp
+#if defined(CONFIG_CMD_USB) && defined(CONFIG_USB_STORAGE)
+	if(ret) ret=run_command("run upgrade_img_usb", 0);
+#endif // USB
+	if(!ret) run_command("reset", 0);
+#else
+        /*   LOAD GOLD FW   */
+        ret = RTK_PLAT_ERR_OK;
+        boot_mode=BOOT_GOLD_MODE;
+        accelerate_state = 0;
+        ret = rtk_plat_boot_handler();
+#endif
+    }
+
+#ifdef CONFIG_RESCUE_FROM_USB
+	if (ret != RTK_PLAT_ERR_OK) {
+		ret = boot_rescue_from_usb();
+	}
+#endif /* CONFIG_RESCUE_FROM_USB */
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(
+	bootr, 2, 0,	rtk_plat_do_bootr,
+	"boot realtek platform",
+	"[u/uz]\n"
+	"\tf   - boot faster of blue logo\n"
+	"\tu   - boot from usb\n"
+	"\tuz  - boot from usb (use lzma image)\n"
+	"\tm   - read fw from flash but boot manually (go all)\n"
+);
+
+#endif /* CONFIG_BOOT_FOR_WD */
+
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index 48738ac605..05d4ce87f1 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -635,6 +635,18 @@ U_BOOT_CMD(
 #endif	/* CONFIG_CMD_BOOTZ */
 
 #ifdef CONFIG_CMD_BOOTI
+#ifdef CONFIG_ARM64_IMAGE_LEGACY
+/* ARM64 kernel Image header head changed at 3.12 -> 3.13 */
+struct Image_header {
+	uint32_t	code0;		/* Executable code */
+	uint32_t	res_code;	/* reseved code */
+	uint64_t	text_offset;	/* Image load offset, LE */
+	uint64_t	res0;		/* reserved */
+	uint64_t	res1;		/* reserved */
+};
+
+#define DEFAULT_IMAGE_SIZE	(6 << 20)
+#else //CONFIG_ARM64_IMAGE_LEGACY
 /* See Documentation/arm64/booting.txt in the Linux kernel */
 struct Image_header {
 	uint32_t	code0;		/* Executable code */
@@ -651,16 +663,44 @@ struct Image_header {
 
 #define LINUX_ARM64_IMAGE_MAGIC	0x644d5241
 
+#endif //CONFIG_ARM64_IMAGE_LEGACY
+
+static unsigned Image_Size = 0;
+
 static int booti_setup(bootm_headers_t *images)
 {
 	struct Image_header *ih;
 	uint64_t dst;
+	unsigned long len = CONFIG_GZIP_KERNEL_MAX_LEN;
+	void *decompress_addr = (void*)CONFIG_GZIP_DECOMPRESS_KERNEL_ADDR;
 
 	ih = (struct Image_header *)map_sysmem(images->ep, 0);
 
+#ifdef CONFIG_ARM64_IMAGE_LEGACY
+	printf("Use ARM64 legacy Image, no MAGIC check\n");
+	printf("FIXME : should identify image size from RTK partition info, use default 0x%08x\n", DEFAULT_IMAGE_SIZE);
+	Image_Size = DEFAULT_IMAGE_SIZE;
+#else
 	if (ih->magic != le32_to_cpu(LINUX_ARM64_IMAGE_MAGIC)) {
-		puts("Bad Linux ARM64 Image magic!\n");
-		return 1;
+		printf("Not raw Image, Starting Decompress Image.gz...\n\n\n");
+
+		if (gunzip(decompress_addr, CONFIG_GZIP_KERNEL_MAX_LEN, (unsigned char *)images->ep, &len)) {
+			printf("Decompress FAIL!!\n");
+			return 1;
+		}
+
+		if (len == CONFIG_GZIP_KERNEL_MAX_LEN) {
+			printf("Kernel Image maybe truncated, Please increase CONFIG_GZIP_KERNEL_MAX_LEN size\n");
+			return 1;
+		}
+
+		images->ep = CONFIG_GZIP_DECOMPRESS_KERNEL_ADDR;
+		ih = (struct Image_header *)map_sysmem(images->ep, 0);
+
+		if (ih->magic != le32_to_cpu(LINUX_ARM64_IMAGE_MAGIC)) {
+			puts("Bad Linux ARM64 Image magic!\n");
+			return 1;
+		}
 	}
 	
 	if (ih->image_size == 0) {
@@ -668,6 +708,9 @@ static int booti_setup(bootm_headers_t *images)
 		ih->image_size = (16 << 20);
 	}
 
+	Image_Size = ih->image_size;
+#endif
+
 	/*
 	 * If we are not at the correct run-time location, set the new
 	 * correct location and then move the image there.
@@ -680,7 +723,7 @@ static int booti_setup(bootm_headers_t *images)
 
 		src = (void *)images->ep;
 		images->ep = dst;
-		memmove((void *)dst, src, le32_to_cpu(ih->image_size));
+		memmove((void *)dst, src, le32_to_cpu(Image_Size));
 	}
 
 	return 0;
@@ -693,10 +736,11 @@ static int booti_start(cmd_tbl_t *cmdtp, int flag, int argc,
 			char * const argv[], bootm_headers_t *images)
 {
 	int ret;
-	struct Image_header *ih;
 
-	ret = do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START,
-			      images, 1);
+	ret = do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START | 
+				BOOTM_STATE_FINDOS | BOOTM_STATE_LOADOS,
+			    images, 1);
+	/*BOOTM_STATE_FINDOS and BOOTM_STATE_LOADOS flags are for uImage loading */
 
 	/* Setup Linux kernel Image entry point */
 	if (!argc) {
@@ -713,9 +757,7 @@ static int booti_start(cmd_tbl_t *cmdtp, int flag, int argc,
 	if (ret != 0)
 		return 1;
 
-	ih = (struct Image_header *)map_sysmem(images->ep, 0);
-
-	lmb_reserve(&images->lmb, images->ep, le32_to_cpu(ih->image_size));
+	lmb_reserve(&images->lmb, images->ep, le32_to_cpu(Image_Size));
 
 	/*
 	 * Handle the BOOTM_STATE_FINDOTHER state ourselves as we do not
diff --git a/common/cmd_date.c b/common/cmd_date.c
index 61727e3d1f..241fe483e0 100644
--- a/common/cmd_date.c
+++ b/common/cmd_date.c
@@ -14,6 +14,10 @@
 #include <rtc.h>
 #include <i2c.h>
 
+#ifdef CONFIG_BSP_REALTEK
+#include <asm/arch/factorylib.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 static const char * const weekdays[] = {
@@ -54,6 +58,38 @@ static int do_date(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 #endif
 
 	switch (argc) {
+#ifdef CONFIG_BSP_REALTEK
+	case 3:
+		if (strcmp(argv[1], "alarm")) {
+			rcode = CMD_RET_USAGE;
+			break;
+		}
+
+		if (!strcmp(argv[2], "read")) {
+			if (!rtc_alarm_state(&tm)) {
+				printf ("Date: %4d-%02d-%02d (%sday)    Time: %2d:%02d:%02d\n",
+					tm.tm_year, tm.tm_mon, tm.tm_mday,
+					(tm.tm_wday<0 || tm.tm_wday>6) ?
+						"unknown " : RELOC(weekdays[tm.tm_wday]),
+					tm.tm_hour, tm.tm_min, tm.tm_sec);
+			} else {
+				printf("RTC ALARM Disabled\n");
+			}
+		} else {
+			if (mk_date (argv[2], &tm) != 0) {
+				printf("## Bad date format\n");
+				break;
+			}
+
+			if (rtc_alarm_set(&tm))
+				printf("Set ALARM FAILED!!\n");
+
+			tm.tm_year -= 1900;
+			tm.tm_mon -= 1;
+			factory_write("tmp/factory/RTC", (char*)&tm, sizeof(struct rtc_time));
+		}
+		break;
+#endif // CONFIG_BSP_REALTEK
 	case 2:			/* set date & time */
 		if (strcmp(argv[1],"reset") == 0) {
 			puts ("Reset RTC...\n");
@@ -241,7 +277,7 @@ int mk_date (const char *datestr, struct rtc_time *tmp)
 /***************************************************/
 
 U_BOOT_CMD(
-	date,	2,	1,	do_date,
+	date,	3,	1,	do_date,
 	"get/set/reset date & time",
 	"[MMDDhhmm[[CC]YY][.ss]]\ndate reset\n"
 	"  - without arguments: print date & time\n"
diff --git a/common/cmd_eeprom.c b/common/cmd_eeprom.c
index e9904cd698..572fe0d1ed 100644
--- a/common/cmd_eeprom.c
+++ b/common/cmd_eeprom.c
@@ -40,6 +40,89 @@ extern int eeprom_write_enable (unsigned dev_addr, int state);
 #define MAX_ACKNOWLEDGE_POLLS	10
 #endif
 
+/************************************************************************************************
+*   EEPROM_SIZE:								 		*
+*   24c00: 16, 24c01: 128, 24c02: 256, 24c04: 512, 24c08: 1024, 24c16: 2048	 		*
+*   24c32: 4096, 24c64: 8192, 24c128: 16384, 24c256: 32768, 24c512: 65536, 	 		*
+*												*
+*   I2C_EEPROM_ADDR_LEN:									*
+*   24c00, 24c01,24c02, 24c04, 24c08, 24c16 the address mode is 1 bytes,                        *
+*   24c32, 24c64, 24c128, 24c256, 24c512, the address mode is 2 bytes                           *
+*                                                                                               *
+*   PAGE_WRITE_SIZE:										*
+*   EEPROM supports page write mechanism, however, each eeprom type has different		*
+*   page write size. User needs to read the eeprom spec and look for the page write 		*
+*   size, or user will get trouble when write operation attempts to croos a page 		*
+*   boundary. The following comment is from eeprom data sheet:					*
+*  "Page write operations are limited to writing bytes within a single physical page,		*
+*   regardless of the number of bytes actually being written. Physical page boundaries		*
+*   start at addresses that are integer multiples of the page buffer size (or ‘page size’)	*
+*   and end at addresses that are integer multiples of [page size - 1].				*
+*   If a Page Write command attempts to write across a physical page boundary,			*
+*   the result is that the data wraps around to the beginning of the current page		*
+*   (overwriting data previously stored there), instead of being written to the next page,	*
+*   as might be expected. It is, therefore, necessary for the application software to prevent	*
+*   page write operations that would attempt to cross a page boundary."				*
+*************************************************************************************************/
+#define AT24C01		0
+#define AT24C01A    1
+#define AT24C02		2
+#define AT24C04		3
+#define AT24C08A	4
+#define AT24C16A	5
+#define AT24C32		6
+#define AT24C64		7
+#define AT24C128	8
+#define AT24C256	9
+#define AT24C512	10
+/*new type eeprom type add here*/
+
+#define EEPROM_SUPPORT_LIST 12 //when new eeprom type is added into eeprom_support, users need to modify this value
+
+struct eeprom_data{
+    unsigned int   EEPROM_SIZE;		//eeprom capacity
+    unsigned short PAGE_WRITE_SIZE;	//write page mechanism, 0 if there is not such limitation
+};
+
+/*these data are from ATMEL EEPROM spec, it would need to be modified if any bugs*/
+struct eeprom_data EEPROM[EEPROM_SUPPORT_LIST] ={
+    {128,	4},			//AT24C01
+    {128,   8},     	//AT24C01A
+    {256,	8},			//AT24C02
+    {512,	16},		//AT24C04
+    {1024,	16},		//AT24C08A
+    {2048,	16},		//AT24C16A, AT24C164
+    {4096,	32},		//AT24C32
+    {8192,	32},		//AT24C64
+    {16384,	64},		//AT24C128
+    {32768,	64},		//AT24C256
+    {65536,	128},		//AT24C512
+    {0,0/*New support EEPROM will pe defined from here*/}
+};
+
+//***************************************   User Define Area   ************************************************
+#define EEPROM_TYPE	AT24C16A	//chosing your eeprom manually
+#define I2C_CHANNEL	5		//In Realtek design, eeprom using i2c 5, eeprom device address is 0x50
+#define EEPROM_ADDR	0x50
+//*************************************************************************************************************
+
+/*---------------If new support eeproms are added, the following if condition should be modified ----------------*/
+#if EEPROM_TYPE >= AT24C32             //new 2 bytes address mode eeprom should be put behind AT24C32
+	#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 2
+#else
+	#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#endif
+
+#if EEPROM_TYPE == AT24C01
+	#define BUFFER_SIZE 4
+#elif EEPROM_TYPE > AT24C01 && EEPROM_TYPE < AT24C04
+	#define BUFFER_SIZE 8
+#else
+	#define BUFFER_SIZE 16
+#endif
+/*-----------------------------------------------------------------------------------------------------------------*/
+
+
 /* ------------------------------------------------------------------------- */
 
 #if defined(CONFIG_CMD_EEPROM)
diff --git a/common/cmd_fastboot.c b/common/cmd_fastboot.c
index d52ccfb310..c8d8992322 100644
--- a/common/cmd_fastboot.c
+++ b/common/cmd_fastboot.c
@@ -11,10 +11,18 @@
 #include <command.h>
 #include <g_dnl.h>
 
+#ifdef CONFIG_USB_GADGET_RTK
+extern void udc_usb_dev_init(void);
+#endif
+
 static int do_fastboot(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
 	int ret;
 
+#ifdef CONFIG_USB_GADGET_RTK
+	udc_usb_dev_init();
+#endif
+
 	g_dnl_clear_detach();
 	ret = g_dnl_register("usb_dnl_fastboot");
 	if (ret)
diff --git a/common/cmd_fdt.c b/common/cmd_fdt.c
index 682b655395..8259e65d73 100644
--- a/common/cmd_fdt.c
+++ b/common/cmd_fdt.c
@@ -29,10 +29,10 @@
  */
 DECLARE_GLOBAL_DATA_PTR;
 
-static int fdt_valid(struct fdt_header **blobp);
-static int fdt_parse_prop(char *const*newval, int count, char *data, int *len);
-static int fdt_print(const char *pathp, char *prop, int depth);
-static int is_printable_string(const void *data, int len);
+/*static*/ int fdt_valid(struct fdt_header **blobp);
+/*static*/ int fdt_parse_prop(char *const*newval, int count, char *data, int *len);
+/*static*/ int fdt_print(const char *pathp, char *prop, int depth);
+/*static*/ int is_printable_string(const void *data, int len);
 
 /*
  * The working_fdt points to our working flattened device tree.
@@ -601,7 +601,7 @@ static int do_fdt(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 			initrd_end = simple_strtoul(argv[3], NULL, 16);
 		}
 
-		fdt_chosen(working_fdt);
+		fdt_chosen(working_fdt, 1);
 		fdt_initrd(working_fdt, initrd_start, initrd_end);
 
 #if defined(CONFIG_FIT_SIGNATURE)
@@ -659,7 +659,7 @@ static int do_fdt(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
  * @blobp: Pointer to FDT pointer
  * @return 1 if OK, 0 if bad (in which case *blobp is set to NULL)
  */
-static int fdt_valid(struct fdt_header **blobp)
+/*static*/ int fdt_valid(struct fdt_header **blobp)
 {
 	const void *blob = *blobp;
 	int err;
@@ -715,7 +715,7 @@ static int fdt_valid(struct fdt_header **blobp)
  * data: A bytestream to be placed in the property
  * len: The length of the resulting bytestream
  */
-static int fdt_parse_prop(char * const *newval, int count, char *data, int *len)
+/*static*/ int fdt_parse_prop(char * const *newval, int count, char *data, int *len)
 {
 	char *cp;		/* temporary char pointer */
 	char *newp;		/* temporary newval char pointer */
@@ -804,7 +804,7 @@ static int fdt_parse_prop(char * const *newval, int count, char *data, int *len)
  * Heuristic to guess if this is a string or concatenated strings.
  */
 
-static int is_printable_string(const void *data, int len)
+/*static*/ int is_printable_string(const void *data, int len)
 {
 	const char *s = data;
 
@@ -904,7 +904,7 @@ static void print_data(const void *data, int len)
  * Recursively print (a portion of) the working_fdt.  The depth parameter
  * determines how deeply nested the fdt is printed.
  */
-static int fdt_print(const char *pathp, char *prop, int depth)
+/*static*/ int fdt_print(const char *pathp, char *prop, int depth)
 {
 	static char tabs[MAX_LEVEL+1] =
 		"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"
diff --git a/common/cmd_gpt.c b/common/cmd_gpt.c
index c56fe15d3b..0679fef2e0 100644
--- a/common/cmd_gpt.c
+++ b/common/cmd_gpt.c
@@ -317,7 +317,7 @@ static int do_gpt(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	char *ep;
 	block_dev_desc_t *blk_dev_desc;
 
-	if (argc < 5)
+	if (argc < 4)
 		return CMD_RET_USAGE;
 
 	/* command: 'write' */
@@ -344,6 +344,22 @@ static int do_gpt(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 			puts("error!\n");
 			return CMD_RET_FAILURE;
 		}
+	} else if ((strncmp(argv[1], "print", 5) == 0) && (argc == 4)) {
+        dev = (int)simple_strtoul(argv[3], &ep, 10);
+        if (!ep || ep[0] != '\0') {
+            printf("'%s' is not a number\n", argv[3]);
+            return CMD_RET_USAGE;
+        }
+
+        blk_dev_desc = get_dev(argv[2], dev);
+        if (!blk_dev_desc) {
+            printf("%s: %s dev %d NOT available\n",
+                   __func__, argv[2], dev);
+            return CMD_RET_FAILURE;
+        }
+        puts("Printing GPT: ");
+        print_part(blk_dev_desc);
+        return CMD_RET_SUCCESS;
 	} else {
 		return CMD_RET_USAGE;
 	}
@@ -356,4 +372,7 @@ U_BOOT_CMD(gpt, CONFIG_SYS_MAXARGS, 1, do_gpt,
 	" - GUID partition table restoration\n"
 	" Restore GPT information on a device connected\n"
 	" to interface\n"
+    " command:\n"
+    " - write: generate GPT partition table\n"
+    " - print: dump GPT partition table\n"
 );
diff --git a/common/cmd_mmc.c b/common/cmd_mmc.c
index 1335e3d344..93bbab1b86 100644
--- a/common/cmd_mmc.c
+++ b/common/cmd_mmc.c
@@ -75,14 +75,14 @@ static void print_mmcinfo(struct mmc *mmc)
 {
 	int i;
 
-	printf("Device: %s\n", mmc->cfg->name);
+	printf("Device: %s\n", mmc->name);
 	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
 	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
 	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
 			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
 			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);
 
-	printf("Tran Speed: %d\n", mmc->tran_speed);
+	printf("Tran Speed: %lld\n", mmc->tran_speed);
 	printf("Rd Block Len: %d\n", mmc->read_bl_len);
 
 	printf("%s version %d.%d", IS_SD(mmc) ? "SD" : "MMC",
@@ -377,11 +377,12 @@ static int do_mmc_write(cmd_tbl_t *cmdtp, int flag,
 
 	printf("\nMMC write: dev # %d, block # %d, count %d ... ",
 	       curr_device, blk, cnt);
-
+#if 0
 	if (mmc_getwp(mmc) == 1) {
 		printf("Error: card is write protected!\n");
 		return CMD_RET_FAILURE;
 	}
+#endif
 	n = mmc->block_dev.block_write(curr_device, blk, cnt, addr);
 	printf("%d blocks written: %s\n", n, (n == cnt) ? "OK" : "ERROR");
 
@@ -845,11 +846,12 @@ U_BOOT_CMD(
 	"info - display info of the current MMC device\n"
 	"mmc read addr blk# cnt\n"
 	"mmc write addr blk# cnt\n"
-	"mmc erase blk# cnt\n"
+	"mmc erase blk(Reminder: the device will ignore the start <addr> and round the start address to erase_group_size boundary and then erase the erase_group_size instead of #cnt)# cnt\n"
 	"mmc rescan\n"
 	"mmc part - lists available partition on current mmc device\n"
 	"mmc dev [dev] [part] - show or set current mmc device [partition]\n"
 	"mmc list - lists available devices\n"
+#if 0
 	"mmc hwpartition [args...] - does hardware partitioning\n"
 	"  arguments (sizes in 512-byte blocks):\n"
 	"    [user [enh start cnt] [wrrel {on|off}]] - sets user data area attributes\n"
@@ -857,6 +859,7 @@ U_BOOT_CMD(
 	"    [check|set|complete] - mode, complete set partitioning completed\n"
 	"  WARNING: Partitioning is a write-once setting once it is set to complete.\n"
 	"  Power cycling is required to initialize partitions after set to complete.\n"
+#endif
 #ifdef CONFIG_SUPPORT_EMMC_BOOT
 	"mmc bootbus dev boot_bus_width reset_boot_bus_width boot_mode\n"
 	" - Set the BOOT_BUS_WIDTH field of the specified device\n"
@@ -874,7 +877,9 @@ U_BOOT_CMD(
 	"mmc rpmb key <address of auth-key> - program the RPMB authentication key.\n"
 	"mmc rpmb counter - read the value of the write counter\n"
 #endif
+#if 0
 	"mmc setdsr <value> - set DSR register value\n"
+#endif
 	);
 
 /* Old command kept for compatibility. Same as 'mmc info' */
diff --git a/common/cmd_net.c b/common/cmd_net.c
index b2f3c7b709..7098763932 100644
--- a/common/cmd_net.c
+++ b/common/cmd_net.c
@@ -35,11 +35,19 @@ int do_tftpb(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	return ret;
 }
 
+#if 0 // hack by yh
 U_BOOT_CMD(
 	tftpboot,	3,	1,	do_tftpb,
 	"boot image via network using TFTP protocol",
 	"[loadAddress] [[hostIPaddr:]bootfilename]"
 );
+#else
+U_BOOT_CMD(
+	tftp,	3,	1,	do_tftpb,
+	"download image from TFTP server",
+	"address filename"
+);
+#endif
 
 #ifdef CONFIG_CMD_TFTPPUT
 int do_tftpput(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
@@ -187,6 +195,9 @@ static int netboot_common(enum proto_t proto, cmd_tbl_t *cmdtp, int argc,
 
 	switch (argc) {
 	case 1:
+#if 1 // hack by yh
+		return CMD_RET_USAGE;
+#endif
 		break;
 
 	case 2:	/*
diff --git a/common/cmd_nvedit.c b/common/cmd_nvedit.c
index f4c2523f2f..c26d1cb376 100644
--- a/common/cmd_nvedit.c
+++ b/common/cmd_nvedit.c
@@ -36,6 +36,7 @@
 #include <linux/stddef.h>
 #include <asm/byteorder.h>
 #include <asm/io.h>
+#include <stdlib.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -745,6 +746,7 @@ static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
 			  int argc, char * const argv[])
 {
 	int all = 0, flag = 0;
+	char  *value, tmp_value[50];
 
 	debug("Initial value for argc=%d\n", argc);
 	while (--argc > 0 && **++argv == '-') {
@@ -767,6 +769,13 @@ static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
 	if (all && (argc == 0)) {
 		/* Reset the whole environment */
 		set_default_env("## Resetting to default environment\n");
+		
+		srand(get_ticks());
+		sprintf(tmp_value, "00:10:20:30:%02x:%02x", rand() % 256, rand() % 256);
+		value = tmp_value;
+		setenv("ethaddr", value);
+		/*MAC address will be changed every time when setting default values.*/
+		
 		return 0;
 	}
 	if (!all && (argc > 0)) {
diff --git a/common/cmd_pxe.c b/common/cmd_pxe.c
index abf0941b57..080b3760de 100644
--- a/common/cmd_pxe.c
+++ b/common/cmd_pxe.c
@@ -793,8 +793,12 @@ static int label_boot(cmd_tbl_t *cmdtp, struct pxe_label *label)
 	/* Try bootm for legacy and FIT format image */
 	if (genimg_get_format(buf) != IMAGE_FORMAT_INVALID)
 		do_bootm(cmdtp, 0, bootm_argc, bootm_argv);
-#ifdef CONFIG_CMD_BOOTZ
-	/* Try booting a zImage */
+#ifdef CONFIG_CMD_BOOTI
+	/* Try booting an AArch64 Linux kernel image */
+	else
+		do_booti(cmdtp, 0, bootm_argc, bootm_argv);
+#elif defined(CONFIG_CMD_BOOTZ)
+	/* Try booting a Image */
 	else
 		do_bootz(cmdtp, 0, bootm_argc, bootm_argv);
 #endif
diff --git a/common/cmd_sata.c b/common/cmd_sata.c
index 51f67033ae..3f706b53b3 100644
--- a/common/cmd_sata.c
+++ b/common/cmd_sata.c
@@ -15,7 +15,7 @@
 #include <part.h>
 #include <sata.h>
 
-static int sata_curr_device = -1;
+int sata_curr_device = -1;
 block_dev_desc_t sata_dev_desc[CONFIG_SYS_SATA_MAX_DEVICE];
 
 int __sata_initialize(void)
@@ -24,6 +24,11 @@ int __sata_initialize(void)
 	int i;
 
 	for (i = 0; i < CONFIG_SYS_SATA_MAX_DEVICE; i++) {
+
+#if defined(CONFIG_RTK_AHSATA)
+		extern void sata_init(int port);
+		sata_init(i);
+#endif
 		memset(&sata_dev_desc[i], 0, sizeof(struct block_dev_desc));
 		sata_dev_desc[i].if_type = IF_TYPE_SATA;
 		sata_dev_desc[i].dev = i;
@@ -39,8 +44,9 @@ int __sata_initialize(void)
 		if (!rc) {
 			rc = scan_sata(i);
 			if (!rc && (sata_dev_desc[i].lba > 0) &&
-				(sata_dev_desc[i].blksz > 0))
+				(sata_dev_desc[i].blksz > 0)) {
 				init_part(&sata_dev_desc[i]);
+			}
 		}
 	}
 	sata_curr_device = 0;
@@ -73,20 +79,26 @@ static int do_sata(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	int rc = 0;
 
-	if (argc == 2 && strcmp(argv[1], "stop") == 0)
-		return sata_stop();
+	if (argc == 2 && strcmp(argv[1], "stop") == 0) {
+		if (sata_curr_device != -1) {
+			return sata_stop();
+		}
+		return 1;
+	}
 
 	if (argc == 2 && strcmp(argv[1], "init") == 0) {
-		if (sata_curr_device != -1)
+		if (sata_curr_device != -1) {
 			sata_stop();
-
+		}
 		return sata_initialize();
 	}
 
 	/* If the user has not yet run `sata init`, do it now */
-	if (sata_curr_device == -1)
-		if (sata_initialize())
+	if (sata_curr_device == -1) {
+		if (sata_initialize()) {
 			return 1;
+		}
+	}
 
 	switch (argc) {
 	case 0:
diff --git a/common/cmd_usb.c b/common/cmd_usb.c
index eab55cd674..ddc7b6973f 100644
--- a/common/cmd_usb.c
+++ b/common/cmd_usb.c
@@ -801,6 +801,34 @@ static int do_usb(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		}
 		return 0;
 	}
+#if defined(CONFIG_PARTITION_UUIDS) && defined(NAS_ENABLE)
+	if (strncmp(argv[1], "uuid", 3) == 0) {
+		if (argc == 4) {
+			int dev = (int)simple_strtoul(argv[2], NULL, 10);
+			int part = (int)simple_strtoul(argv[3], NULL, 10);
+			stor_dev = usb_stor_get_dev(dev);
+			if (stor_dev == NULL ||
+			    stor_dev->type == DEV_TYPE_UNKNOWN) {
+				return 1;
+			}
+	/* Support MBR partition only */
+#ifdef CONFIG_DOS_PARTITION
+			disk_partition_t info;
+			if (stor_dev->part_type != PART_TYPE_DOS ||
+			    get_partition_info_dos(stor_dev,part,&info) != 0)
+#endif
+			return 1;
+
+                        // 0x0bda
+			if(strncmp(info.uuid, RT_NAS_MAGIC, 4))
+				return 1;
+			printf("NAS boot: dev(%d), part(%d), uuid(%.37s)\n",
+                          dev, part, info.uuid);
+			setenv("nas_boot_uuid", info.uuid);
+			return 0;
+		}
+	}
+#endif
 #endif /* CONFIG_USB_STORAGE */
 	return CMD_RET_USAGE;
 }
diff --git a/common/cmd_version.c b/common/cmd_version.c
index 1be0667f09..8573633fa1 100644
--- a/common/cmd_version.c
+++ b/common/cmd_version.c
@@ -13,7 +13,18 @@
 #include <asm/arch/sysinfo.h>
 #endif
 
+#if defined(CONFIG_BOARD_WD_MONARCH) || defined(CONFIG_BOARD_WD_PELICAN)
+/**
+  4.1.0 New implementation for firmware upate
+  4.1.1 Added code to boot into golden image
+  4.1.2 KAM-12726 SATA Init failed in uboot
+  4.1.3 Reset the bootstate after update_cbr has failed.
+  4.1.4 Changed the default FAN speed to 20%
+**/
+const char __weak version_string[] = "4.1.4";
+#else
 const char __weak version_string[] = U_BOOT_VERSION_STRING;
+#endif
 
 static int do_version(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
diff --git a/common/env_common.c b/common/env_common.c
index af59c72e1f..3a6fe661ce 100644
--- a/common/env_common.c
+++ b/common/env_common.c
@@ -15,6 +15,8 @@
 #include <search.h>
 #include <errno.h>
 #include <malloc.h>
+#include <asm/arch/system.h>
+#include <asm/arch/factorylib.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -125,6 +127,34 @@ void set_default_env(const char *s)
 	gd->flags |= GD_FLG_ENV_READY;
 }
 
+int check_default_env(const char *s)
+{
+		int flags = 0;
+
+	if (sizeof(default_environment) > ENV_SIZE) {
+		puts("*** Error - default environment is too large\n\n");
+		return 0;
+	}
+
+	if (s) {
+		if (*s == '!') {
+			printf("*** Warning - %s, "
+				"using default environment\n\n",
+				s + 1);
+		} else {
+			flags = H_INTERACTIVE;
+			puts(s);
+		}
+	} else {
+		puts("Using default environment\n\n");
+	}
+
+	return h_detect_r(&env_htab, (char *)default_environment,
+			sizeof(default_environment), '\0', flags, 0,
+			0, NULL);
+		
+}
+
 
 /* [re]set individual variables to their value in the default environment */
 int set_default_vars(int nvars, char * const vars[])
@@ -262,6 +292,37 @@ void env_relocate(void)
 #else
 		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);
 		set_default_env("!bad CRC");
+#ifdef NAS_ENABLE
+#ifdef CONFIG_SYS_FACTORY
+	ssize_t	len;
+	char	*res;
+	env_t *env_new = NULL;
+
+	env_new = (env_t *)TEMP_BUFFER_FOR_FLASH_DATA_ADDR;
+
+	res = (char *)&env_new->data;
+	len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, 0, NULL);
+	if (len > 0) {
+            env_new->crc = crc32(0, &env_new->data[0], ENV_SIZE);
+
+            printf("[ENV] Writing to Factory... \n");
+
+	    int ret = 0;
+            ret = factory_write(FACTORY_HEADER_FILE_NAME"env.txt", (char *)env_new, CONFIG_ENV_SIZE);
+            if (ret != 0) { // failed case
+                    printf("[ENV] write_env failed\n");
+            }
+            else {
+                    factory_save(); // sync data to flash
+            }
+	}
+        else{
+            error("Cannot export environment: errno = %d\n", errno);
+        }
+#else
+	printf("[ENV][WARN] CONFIG_SYS_FACTORY is not defined.\n");
+#endif
+#endif // NAS_ENABLE
 #endif
 	} else {
 		env_relocate_spec();
diff --git a/common/fdt_support.c b/common/fdt_support.c
index 10648b5a4a..6c320af291 100644
--- a/common/fdt_support.c
+++ b/common/fdt_support.c
@@ -16,6 +16,7 @@
 #include <libfdt.h>
 #include <fdt_support.h>
 #include <exports.h>
+#include <asm/arch/cpu.h>
 
 /**
  * fdt_getprop_u32_default_node - Return a node's property or a default
@@ -280,33 +281,121 @@ int fdt_initrd(void *fdt, ulong initrd_start, ulong initrd_end)
 	return 0;
 }
 
-int fdt_chosen(void *fdt)
+int fdt_chosen(void *fdt, int force)
 {
 	int   nodeoffset;
 	int   err;
 	char  *str;		/* used to set string properties */
+	const char *path;
 
 	err = fdt_check_header(fdt);
 	if (err < 0) {
 		printf("fdt_chosen: %s\n", fdt_strerror(err));
 		return err;
 	}
+	
+	/*
+	 * The order of resume-entry-addr in kernl is 34 12 78 56, if original address is 0x12345678.
+	 * The order of resume-entry-addr setting by fdt_setprop is 56 78 12 34, if original address is 0x12345678.
+	 * For fitting this order,  resume_addr is adjusted to 78 56 34 12.
+	 * resume_addr is saving resuming address when the system return from S1 sleep. 
+	 */
+#ifdef CONFIG_TARGET_RTD1295
+	int slave_cpu_offset = fdt_path_offset (fdt, "/rtk_boot");
+	unsigned int resume_addr = (CONFIG_SYS_TEXT_BASE << 24) | (CONFIG_SYS_TEXT_BASE << 8 & 0x00ff0000) 
+						| (CONFIG_SYS_TEXT_BASE >> 8 & 0x0000ff00) | (CONFIG_SYS_TEXT_BASE >> 24 & 0xff);
+	if (resume_addr) {
+		path = fdt_getprop(fdt, slave_cpu_offset, "resume-entry-addr", NULL);
+		if ((path == NULL) || force) {
+			err = fdt_setprop(fdt, slave_cpu_offset,
+				"resume-entry-addr", &resume_addr, sizeof(unsigned int));
+			if (err < 0)
+				printf("WARNING: could not set resume-entry-addr %s.\n",
+					fdt_strerror(err));
+		}
+	}
+#endif
+	
+	/*
+	 * Find the "chosen" node.
+	 */
+	nodeoffset = fdt_path_offset (fdt, "/chosen");
 
-	/* find or create "/chosen" node. */
-	nodeoffset = fdt_find_or_add_subnode(fdt, 0, "chosen");
-	if (nodeoffset < 0)
-		return nodeoffset;
+	/*
+	 * If there is no "chosen" node in the blob, create it.
+	 */
+	if (nodeoffset < 0) {
+		/*
+		 * Create a new node "/chosen" (offset 0 is root level)
+		 */
+		nodeoffset = fdt_add_subnode(fdt, 0, "chosen");
+		if (nodeoffset < 0) {
+			printf("WARNING: could not create /chosen %s.\n",
+				fdt_strerror(nodeoffset));
+			return nodeoffset;
+		}
+	}
+	
+	/*
+	 *  Set the reserved address information for boot logo in device tree.
+	 */
+	err = fdt_setprop_u32(fdt, nodeoffset, "logo-area", getenv_ulong("blue_logo_loadaddr", 16, BOOT_LOGO_ADDR));
+	if (err < 0)
+			printf("WARNING: could not set logo-area %s.\n",
+				fdt_strerror(err));
+	err = fdt_appendprop_u32(fdt, nodeoffset, "logo-area", BOOT_LOGO_SIZE);
+	if (err < 0)
+			printf("WARNING: could not set logo-area size %s.\n",
+				fdt_strerror(err));
 
+	/*
+	 * Create /chosen properites that don't exist in the fdt.
+	 * If the property exists, update it only if the "force" parameter
+	 * is true.
+	 */
 	str = getenv("bootargs");
-	if (str) {
-		err = fdt_setprop(fdt, nodeoffset, "bootargs", str,
-				  strlen(str) + 1);
-		if (err < 0) {
-			printf("WARNING: could not set bootargs %s.\n",
-			       fdt_strerror(err));
-			return err;
+	if (str != NULL) {
+		path = fdt_getprop(fdt, nodeoffset, "bootargs", NULL);
+		if ((path == NULL) || force) {
+			err = fdt_setprop(fdt, nodeoffset,
+				"bootargs", str, strlen(str)+1);
+			if (err < 0)
+				printf("WARNING: could not set bootargs %s.\n",
+					fdt_strerror(err));
+		}
+	}
+	
+#ifdef CONFIG_OF_STDOUT_VIA_ALIAS
+	path = fdt_getprop(fdt, nodeoffset, "linux,stdout-path", NULL);
+	if ((path == NULL) || force)
+		err = fdt_fixup_stdout(fdt, nodeoffset);
+#endif
+
+#ifdef OF_STDOUT_PATH
+	path = fdt_getprop(fdt, nodeoffset, "linux,stdout-path", NULL);
+	if ((path == NULL) || force) {
+		err = fdt_setprop(fdt, nodeoffset,
+			"linux,stdout-path", OF_STDOUT_PATH, strlen(OF_STDOUT_PATH)+1);
+		if (err < 0)
+			printf("WARNING: could not set linux,stdout-path %s.\n",
+				fdt_strerror(err));
+	}
+#endif
+
+#ifdef NAS_ENABLE
+	str = getenv("nasargs");
+	if (str != NULL) {
+		path = fdt_getprop(fdt, nodeoffset, "nasargs", NULL);
+		if ((path == NULL) || force) {
+			err = fdt_setprop(fdt, nodeoffset,
+				"nasargs", str, strlen(str)+1);
+			if (err < 0)
+				printf("WARNING: could not set nasargs %s.\n",
+					fdt_strerror(err));
 		}
 	}
+#endif
+
 
 	return fdt_fixup_stdout(fdt, nodeoffset);
 }
@@ -493,6 +582,45 @@ void fdt_fixup_ethernet(void *fdt)
 		strcpy(mac, "ethaddr");
 	}
 
+#if defined(CONFIG_RTD1295) || defined(CONFIG_RTD1395)
+	(void)enet;
+	(void)i;
+	/* add MAC address */
+	if ((tmp = getenv(mac)) != NULL) {
+		printf("[FDT] mac = %s\n", tmp);
+		for (j = 0; j < 6; j++) {
+			mac_addr[j] = tmp ? simple_strtoul(tmp, &end, 16) : 0;
+			if (tmp)
+				tmp = (*end) ? end+1 : end;
+		}
+
+		/* ETN */
+		path = "/gmac@98016000";
+		do_fixup_by_path(fdt, path, "local-mac-address",
+				&mac_addr, 6, 1);
+#if defined(CONFIG_RTD1295)
+		/* NAT */
+		path = "/gmac@0x98060000";
+		do_fixup_by_path(fdt, path, "local-mac-address",
+				&mac_addr, 6, 1);
+#endif /* CONFIG_RTD1295 */
+		printf("[FDT] update MAC address\n");
+	}
+
+#if defined(CONFIG_RTD1395)
+	/* ETN */
+	node = fdt_path_offset(fdt, "/gmac@98016000");
+	if (node > 0) {
+		const void *ptr;
+		ptr = fdt_getprop(fdt, node, "output-mode", NULL);
+		if (ptr && *(uint32_t *)ptr == 0) {
+			fdt_setprop_u32(fdt, node, "force-Gb-off", 1);
+		}
+	}
+#endif /* CONFIG_RTD1395 */
+
+#else /* others */
+
 	i = 0;
 	while ((tmp = getenv(mac)) != NULL) {
 		sprintf(enet, "ethernet%d", i);
@@ -515,6 +643,7 @@ void fdt_fixup_ethernet(void *fdt)
 
 		sprintf(mac, "eth%daddr", ++i);
 	}
+#endif /* CONFIG_RTD1295 | CONFIG_RTD1395 */
 }
 
 /* Resize the fdt to its actual size + a bit of padding */
diff --git a/common/image-fdt.c b/common/image-fdt.c
index 80e3e63805..949f19dbe4 100644
--- a/common/image-fdt.c
+++ b/common/image-fdt.c
@@ -112,11 +112,11 @@ void boot_fdt_add_mem_rsv_regions(struct lmb *lmb, void *fdt_blob)
 int boot_relocate_fdt(struct lmb *lmb, char **of_flat_tree, ulong *of_size)
 {
 	void	*fdt_blob = *of_flat_tree;
-	void	*of_start = NULL;
+	void	*of_start = fdt_blob;
 	char	*fdt_high;
 	ulong	of_len = 0;
 	int	err;
-	int	disable_relocation = 0;
+	int	disable_relocation = 1;
 
 	/* nothing to do */
 	if (*of_size == 0)
@@ -153,11 +153,13 @@ int boot_relocate_fdt(struct lmb *lmb, char **of_flat_tree, ulong *of_size)
 			of_start =
 			    (void *)(ulong) lmb_alloc(lmb, of_len, 0x1000);
 		}
-	} else {
+	} else if (!disable_relocation) {
 		of_start =
 		    (void *)(ulong) lmb_alloc_base(lmb, of_len, 0x1000,
 						   getenv_bootm_mapsize()
 						   + getenv_bootm_low());
+	} else {
+		lmb_reserve(lmb, (ulong)of_start, of_len);
 	}
 
 	if (of_start == NULL) {
@@ -475,14 +477,16 @@ int image_setup_libfdt(bootm_headers_t *images, void *blob,
 		printf("ERROR: root node setup failed\n");
 		goto err;
 	}
-	if (fdt_chosen(blob) < 0) {
+	if (fdt_chosen(blob, 1) < 0) {
 		printf("ERROR: /chosen node create failed\n");
 		goto err;
 	}
+#ifndef CONFIG_BSP_REALTEK
 	if (arch_fixup_fdt(blob) < 0) {
 		printf("ERROR: arch-specific fdt fixup failed\n");
 		goto err;
 	}
+#endif
 	if (IMAGE_OF_BOARD_SETUP) {
 		fdt_ret = ft_board_setup(blob, gd->bd);
 		if (fdt_ret) {
diff --git a/common/main.c b/common/main.c
index 2979fbed63..d98afd8980 100644
--- a/common/main.c
+++ b/common/main.c
@@ -2,43 +2,785 @@
  * (C) Copyright 2000
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * Add to readline cmdline-editing by
+ * (C) Copyright 2005
+ * JinHua Luo, GuangDong Linux Center, <luo.jinhua@gd-linux.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 /* #define	DEBUG	*/
 
 #include <common.h>
-#include <autoboot.h>
-#include <cli.h>
+#include <watchdog.h>
+#include <command.h>
+#include <malloc.h>
 #include <version.h>
+#ifdef CONFIG_MODEM_SUPPORT
+#include <malloc.h>		/* for free() prototype */
+#endif
+#include <asm/arch/fw_info.h>
+//#include "../drivers/gpio/rt_gpio.h"
+#include <asm/arch/platform_lib/board/gpio.h>
+
+#include <asm/arch/pwm.h>
+#include <environment.h>
+
+#ifdef CONFIG_SYS_HUSH_PARSER
+#include <hush.h>
+#endif
+#ifndef NAS_DUAL
+#define CONFIG_ANDROID_RECOVERY 1
+#endif
+#include <post.h>
+#include <linux/ctype.h>
+#include <menu.h>
+#include <customized.h>
+
+#if CONFIG_ANDROID_RECOVERY
+#include <asm/arch/factorylib.h>
+#define BOOT_RECOVERY_FILE_NAME	FACTORY_HEADER_FILE_NAME"recovery"
+
+#ifdef CONFIG_FT_TEST
+#include <ft_test.h>
+#endif
+
+typedef struct _bootloader_message {
+    char command[32];
+    char status[32];
+    char recovery[1024];
+} bootloader_message;
+#endif
 
+#if defined(CONFIG_SILENT_CONSOLE) || defined(CONFIG_POST) || defined(CONFIG_CMDLINE_EDITING)
 DECLARE_GLOBAL_DATA_PTR;
+#endif
 
+#if defined(CONFIG_SYS_IR_SUPPORT)
+#include <asm/arch/rbus/iso_reg.h>
+#include <asm/arch/system.h>
+#include <linux/input.h>
+#endif
 /*
  * Board-specific Platform code can reimplement show_boot_progress () if needed
  */
 __weak void show_boot_progress(int val) {}
+int readline_into_buffer(const char *const prompt, char *buffer, int timeout);
+
+#if defined(CONFIG_UPDATE_TFTP)
+int update_tftp (ulong addr);
+#endif /* CONFIG_UPDATE_TFTP */
+
+#define MAX_DELAY_STOP_STR 32
+
+#undef DEBUG_PARSER
+
+//char        console_buffer[CONFIG_SYS_CBSIZE + 1];	/* console I/O buffer	*/
+
+static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen);
+static const char erase_seq[] = "\b \b";		/* erase sequence	*/
+static const char   tab_seq[] = "        ";		/* used to expand TABs	*/
+
+#ifdef CONFIG_BOOT_RETRY_TIME
+static uint64_t endtime = 0;  /* must be set, default is instant timeout */
+static int      retry_time = -1; /* -1 so can call readline before main_loop */
+#endif
+
+#define	endtick(seconds) (get_ticks() + (uint64_t)(seconds) * get_tbclk())
+
+#ifndef CONFIG_BOOT_RETRY_MIN
+#define CONFIG_BOOT_RETRY_MIN CONFIG_BOOT_RETRY_TIME
+#endif
 
-static void modem_init(void)
-{
 #ifdef CONFIG_MODEM_SUPPORT
-	debug("DEBUG: main_loop:   gd->do_mdm_init=%lu\n", gd->do_mdm_init);
-	if (gd->do_mdm_init) {
-		char *str = getenv("mdm_cmd");
+int do_mdm_init = 0;
+extern void mdm_init(void); /* defined in board.c */
+#endif
 
-		setenv("preboot", str);  /* set or delete definition */
-		mdm_init(); /* wait for modem connection */
+extern uchar boot_ac_on;
+extern int check_usb_update(const char *install_file_name, uchar bBootcode, uchar bUsb_need_init);
+
+/*
+ * Define the ASCII encoding
+ */
+#define _TAB			0x09
+#define _ENTER			0x0D
+#define _ESC			0x1B
+#define _SPACE			0x20
+
+#ifdef CONFIG_CMD_SATA
+int sata_boot_debug = 0;
+#endif
+
+#ifdef CONFIG_CUSTOMIZE_BOOTFLOW_1
+int normal_boot = 1;
+#endif
+
+//static BOOT_MODE boot_mode = BOOT_NORMAL_MODE; // Modify for fixing Rescue Kernel stop at 8051 standby
+BOOT_MODE boot_mode = BOOT_NORMAL_MODE;
+
+/***************************************************************************
+ * Watch for 'delay' seconds for autoboot stop or autoboot delay string.
+ * returns: 0 -  no key string, allow autoboot 1 - got key string, abort
+ */
+#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
+# if defined(CONFIG_AUTOBOOT_KEYED)
+#ifndef CONFIG_MENU
+// cklai mark this line to prevent parsing failed in source insight.
+// static inline
+#endif
+int abortboot(int bootdelay)
+{
+	int abort = 0;
+	uint64_t etime = endtick(bootdelay);
+	struct {
+		char* str;
+		u_int len;
+		int retry;
 	}
-#endif  /* CONFIG_MODEM_SUPPORT */
+	delaykey [] = {
+		{ str: getenv ("bootdelaykey"),  retry: 1 },
+		{ str: getenv ("bootdelaykey2"), retry: 1 },
+		{ str: getenv ("bootstopkey"),   retry: 0 },
+		{ str: getenv ("bootstopkey2"),  retry: 0 },
+	};
+
+	char presskey [MAX_DELAY_STOP_STR];
+	u_int presskey_len = 0;
+	u_int presskey_max = 0;
+	u_int i;
+
+#ifndef CONFIG_ZERO_BOOTDELAY_CHECK
+	if (bootdelay == 0)
+		return 0;
+#endif
+
+#  ifdef CONFIG_AUTOBOOT_PROMPT
+	printf(CONFIG_AUTOBOOT_PROMPT);
+#  endif
+
+#  ifdef CONFIG_AUTOBOOT_DELAY_STR
+	if (delaykey[0].str == NULL)
+		delaykey[0].str = CONFIG_AUTOBOOT_DELAY_STR;
+#  endif
+#  ifdef CONFIG_AUTOBOOT_DELAY_STR2
+	if (delaykey[1].str == NULL)
+		delaykey[1].str = CONFIG_AUTOBOOT_DELAY_STR2;
+#  endif
+#  ifdef CONFIG_AUTOBOOT_STOP_STR
+	if (delaykey[2].str == NULL)
+		delaykey[2].str = CONFIG_AUTOBOOT_STOP_STR;
+#  endif
+#  ifdef CONFIG_AUTOBOOT_STOP_STR2
+	if (delaykey[3].str == NULL)
+		delaykey[3].str = CONFIG_AUTOBOOT_STOP_STR2;
+#  endif
+
+	for (i = 0; i < sizeof(delaykey) / sizeof(delaykey[0]); i ++) {
+		delaykey[i].len = delaykey[i].str == NULL ?
+				    0 : strlen (delaykey[i].str);
+		delaykey[i].len = delaykey[i].len > MAX_DELAY_STOP_STR ?
+				    MAX_DELAY_STOP_STR : delaykey[i].len;
+
+		presskey_max = presskey_max > delaykey[i].len ?
+				    presskey_max : delaykey[i].len;
+
+#  if DEBUG_BOOTKEYS
+		printf("%s key:<%s>\n",
+		       delaykey[i].retry ? "delay" : "stop",
+		       delaykey[i].str ? delaykey[i].str : "NULL");
+#  endif
+	}
+
+	/* In order to keep up with incoming data, check timeout only
+	 * when catch up.
+	 */
+	do {
+		if (tstc()) {
+			if (presskey_len < presskey_max) {
+				presskey [presskey_len ++] = getc();
+			}
+			else {
+				for (i = 0; i < presskey_max - 1; i ++)
+					presskey [i] = presskey [i + 1];
+
+				presskey [i] = getc();
+			}
+		}
+
+		for (i = 0; i < sizeof(delaykey) / sizeof(delaykey[0]); i ++) {
+			if (delaykey[i].len > 0 &&
+			    presskey_len >= delaykey[i].len &&
+			    memcmp (presskey + presskey_len - delaykey[i].len,
+				    delaykey[i].str,
+				    delaykey[i].len) == 0) {
+#  if DEBUG_BOOTKEYS
+				printf("got %skey\n",
+				       delaykey[i].retry ? "delay" : "stop");
+#  endif
+
+#  ifdef CONFIG_BOOT_RETRY_TIME
+				/* don't retry auto boot */
+				if (! delaykey[i].retry)
+					retry_time = -1;
+#  endif
+				abort = 1;
+			}
+		}
+	} while (!abort && get_ticks() <= etime);
+
+#  if DEBUG_BOOTKEYS
+	if (!abort)
+		puts("key timeout\n");
+#  endif
+
+#ifdef CONFIG_SILENT_CONSOLE
+	if (abort)
+		gd->flags &= ~GD_FLG_SILENT;
+#endif
+
+	return abort;
 }
 
-static void run_preboot_environment_command(void)
+# else	/* !defined(CONFIG_AUTOBOOT_KEYED) */
+
+#ifdef CONFIG_MENUKEY
+static int menukey = 0;
+#endif
+
+#ifndef CONFIG_MENU
+// cklai mark this following line to prevent parsing failed in source insight.
+// static inline
+#endif
+int abortboot(int bootdelay)
 {
+	int abort = 0;
+#ifdef CONFIG_MENUPROMPT
+	printf(CONFIG_MENUPROMPT);
+#else
+#ifdef CONFIG_BSP_REALTEK
+	printf("Hit Esc or Tab key to enter console mode or rescue linux: %2d ", bootdelay);
+#else
+	printf("Hit any key to stop autoboot: %2d ", bootdelay);
+#endif /* CONFIG_BSP_REALTEK */
+#endif
+
+#if defined CONFIG_ZERO_BOOTDELAY_CHECK
+	/*
+	 * Check if key already pressed
+	 * Don't check if bootdelay < 0
+	 */
+	if (bootdelay >= 0) {
+		if (tstc()) {	/* we got a key press	*/
+			(void) getc();  /* consume input	*/
+			puts ("\b\b\b 0");
+			abort = 1;	/* don't auto boot	*/
+		}
+	}
+#endif
+
+#ifdef CONFIG_RUN_FLASH_WRITER
+	abort=1;
+	boot_mode=BOOT_FLASH_WRITER_MODE;
+
+	return abort;
+#endif
+#if CONFIG_ANDROID_RECOVERY
+    char *dst_addr;
+    int dst_length;
+    int  bEnterRecovery = 0;
+    if (factory_read(BOOT_RECOVERY_FILE_NAME, &dst_addr, &dst_length)) {
+        printf("\n------------can't find %s\n", BOOT_RECOVERY_FILE_NAME);
+    } else {
+        //bootloader_message* pBootMsg = (bootloader_message*)dst_addr;
+        //if (strcmp("boot-recovery", pBootMsg->command) == 0) {
+            printf("\n------------We will Enter Recovery Rescue\n");
+            bEnterRecovery = 1;
+        //}
+    }
+
+#endif
+/*
+ **********************************************************
+ * Realtek Patch:
+ *     Detect specific key from UART or LSADC,
+ *         and execute the coresponding action.
+ *
+ * 	_ESC	: Enter console mode
+ * 	_TAB	: Enter rescue mode
+ * 	_SPACE	: Enter normal mode but user needs to execute boot command manually
+ * 	No key	: Enter normal mode
+ **********************************************************
+ */
+#ifdef CONFIG_BSP_REALTEK
+	int console_key = 0;
+	int lsadc_key = 0;
+#define DETECT_KEY_RETRY_COUNT 10
+
+	boot_mode = BOOT_NORMAL_MODE;
+
+	ulong start;
+#ifdef CONFIG_SYS_IR_SUPPORT
+	ulong delay = (CONFIG_IR_DELAY*3)/2 ;
+	int ir_flag=0;
+	ulong count;
+  unsigned int key=0;
+#else
+	ulong delay = 2;
+#endif
+
+#ifdef CONFIG_FT_TEST
+	ft_init_gpio();
+#endif
+start = get_timer(0);
+	//for (loop_i = 0;loop_i < DETECT_KEY_RETRY_COUNT && (!abort);loop_i++) {
+	while (get_timer(start) < delay && (!abort)){
+		if (tstc()) {	/* we got a key press from UART */
+			console_key = getc();
+		}
+
+		if (0) {	/* we got a key press from LSADC */
+			lsadc_key = 0;
+		}
+				
+		switch (console_key) {
+			case _ESC:
+				printf("\nPress Esc Key\n");						
+				boot_mode = BOOT_CONSOLE_MODE;
+				abort = 1; /* don't auto boot	*/
+				break;
+
+			case _TAB:
+				printf("\nPress Tab Key\n");
+				setenv("rescue_cmd", "go r");
+				boot_mode = BOOT_RESCUE_MODE;
+				abort = 1; /* don't auto boot	*/
+				break;
+
+			case _SPACE:
+				printf("\nPress Space Key\n");
+				boot_mode = BOOT_MANUAL_MODE;
+				abort = 1; /* don't auto boot	*/
+				break;
+
+			case _ENTER:
+			default:
+				debug("Press Key is %c\n", console_key);
+				/* do nothing */
+				break;
+		}
+
+		switch (lsadc_key) {
+			case 0:
+			default:
+				/* do nothing */
+				break;
+		}
+#ifdef CONFIG_INSTALL_GPIO_NUM
+		if(!getGPIO(CONFIG_INSTALL_GPIO_NUM)){		
+			printf("\nPress Install Button\n");
+			setenv("rescue_cmd", "go r");
+			boot_mode = BOOT_RESCUE_MODE;
+			abort = 1; // don't auto boot
+		}
+#endif
+
+#if defined(CONFIG_BOARD_WD_MONARCH)||defined(CONFIG_BOARD_WD_PELICAN)
+        /**
+           @WD_Changes_begin
+           Power On reset to force the device enter
+           Image Recover Mode which booting the device
+           from USB stick
+         **/
+        if(!getISOGPIO(FACTORY_RST_BTN)) { // check if the reset button is pressed
+            printf("\nPress USB-Install Button\n"); // print the message
+#if defined(CONFIG_RTD129X_PWM)
+            //            rtd129x_pwm_init();
+            pwm_set_freq(SYS_LED_PWM_PORT_NUM, 1);  // set the frequency to 1 HZ
+            pwm_set_duty_rate(SYS_LED_PWM_PORT_NUM, 50);
+            pwm_enable(SYS_LED_PWM_PORT_NUM, 1);
+#endif /* CONFIG_RTD129X_PWM */
+            setenv("rescue_cmd", "go ru"); //set the environment variable rescue_cmd=go ru
+            boot_mode = BOOT_RESCUE_MODE; // set the boot_mode
+            abort = 1; // don't auto boot
+        }
+#endif /* CONFIG_BOARD_WD_MONARCH */ /* CONFIG_BOARD_WD_PELICAN) */
+
+#if 0//defined(CONFIG_SYS_IR_SUPPORT)		
+//		if( rtd_readbits(IR_SR_reg, _BIT0)){	
+//            printf("\nGet IR\n");			
+//			rtd_setbits(IR_SR_reg, _BIT0);		
+//			ir_flag=1;
+//			break;	
+//		}
+		if (IR_Get_irdvf()) {
+			printf("\nGet IR\n");
+			IR_Set_irdvf(_BIT0);
+			ir_flag = 1;
+			break;
+		}
+#endif
+	}	
+#if defined(CONFIG_SYS_IR_SUPPORT)
+
+    int bKeyLeft = 0;
+    int bKeyRight = 0;
+    int bKeyVolumeUp = 0;
+    int bKeyVolumeDown = 0;
+    int bKeyOption = 0;
+
+    int ret = 0;
+    bootloader_message *boot = NULL;
+
+    if (!abort) {
+        printf("Please Enter IR Key\n");
+        key = 0;
+        count = get_timer(0);
+        while (get_timer(count) < CONFIG_IR_DELAY*20 && !key) {          
+            if (IR_Get_irdvf()) {
+                IR_Set_irdvf(_BIT0);
+                key = IR_Parsing_key();
+                //printf("Press Key:%d\n",key);
+
+                if (key == KEY_POWER) {
+                    key = 0;
+                }
+            }
+        }
+        
+        switch (key) {
+            case KEY_OPTION:
+                bKeyOption = 1;
+                break;
+                
+            case KEY_LEFT:
+                bKeyLeft = 1;
+                //printf("Detect Other IR Key\n");
+                while (get_timer(count) < CONFIG_IR_DELAY*20) {
+                    if (IR_Get_irdvf()) {
+                        IR_Set_irdvf(_BIT0);
+                        key = IR_Parsing_key();
+                        //printf("Press Key:%d\n",key);
+                    }
+
+                    if (key == KEY_RIGHT) {
+                        bKeyRight = 1;
+                        break;
+                    }
+                }
+                break;
+                
+            case KEY_RIGHT:
+                bKeyRight = 1;
+                //printf("Detect Other IR Key\n");
+                while (get_timer(count) < CONFIG_IR_DELAY*20) {
+                    if (IR_Get_irdvf()) {
+                        IR_Set_irdvf(_BIT0);
+                        key = IR_Parsing_key();
+                        //printf("Press Key:%d\n",key);
+                    }
+
+                    if (key == KEY_LEFT) {
+                        bKeyLeft = 1;
+                        break;
+                    }
+                }
+                break;
+#if 0
+            case KEY_VOLUMEUP:
+                bKeyVolumeUp = 1;
+                printf("Detect Other IR Key\n");
+                while (get_timer(count) < CONFIG_IR_DELAY*20) {
+                    if (IR_Get_irdvf()) {
+                        IR_Set_irdvf(_BIT0);
+                        key = IR_Parsing_key();
+                        printf("Press Key:%d\n",key);
+                    }
+
+                    if (key == KEY_VOLUMEDOWN) {
+                        bKeyVolumeDown = 1;
+                        break;
+                    }
+                }
+                break;
+
+            case KEY_VOLUMEDOWN:
+                bKeyVolumeDown = 1;
+                printf("Detect Other IR Key\n");
+                while (get_timer(count) < CONFIG_IR_DELAY*20) {
+                    if (IR_Get_irdvf()) {
+                        IR_Set_irdvf(_BIT0);
+                        key = IR_Parsing_key();
+                        printf("Press Key:%d\n",key);
+                    }
+
+                    if (key == KEY_VOLUMEUP) {
+                        bKeyVolumeUp = 1;
+                        break;
+                    }
+                }
+                break;
+#endif                
+            default:
+                break;
+        }
+
+
+        if (bKeyOption) {      
+            printf("menu : usb update \n");
+
+            boot = (bootloader_message *)BACKUP_DESCRIPTION_RECOVERY_ADDR;
+			memset(boot, 0, sizeof(bootloader_message));
+			memset(boot->command, '\0', sizeof(boot->command));
+			memset(boot->recovery, '\0', sizeof(boot->recovery));
+			sprintf(boot->command, "boot-recovery");
+			sprintf(boot->recovery, "recovery\n--update_package=USB:update.zip\n--locale=en_GB");
+
+			ret = factory_write(BOOT_RECOVERY_FILE_NAME, (char *)boot, CONFIG_RECOVERY_SIZE);
+			if (ret != 0) { 
+			    // failed case
+				printf("[ENV] write_recovery failed\n");
+		    }
+			else
+				factory_save();
+
+            bEnterRecovery = 1;
+        }
+        else if (bKeyLeft && bKeyRight) {
+            printf("<- + -> : backup update \n");
+
+            boot = (bootloader_message *)BACKUP_DESCRIPTION_RECOVERY_ADDR;
+			memset(boot, 0, sizeof(bootloader_message));
+			memset(boot->command, '\0', sizeof(boot->command));
+			memset(boot->recovery, '\0', sizeof(boot->recovery));
+			sprintf(boot->command, "boot-recovery");
+			sprintf(boot->recovery, "recovery\n--update_package=BACKUP:update.zip\n--locale=en_GB");
+
+			ret = factory_write(BOOT_RECOVERY_FILE_NAME, (char *)boot, CONFIG_RECOVERY_SIZE);
+			if (ret != 0) { 
+			    // failed case
+				printf("[ENV] write_recovery failed\n");
+		    }
+			else
+				factory_save();
+
+            bEnterRecovery = 1;
+        }
+#if 0
+        else if (bKeyLeft) {
+            printf("<- : recovery default setting \n");
+
+            boot = (bootloader_message *)BACKUP_DESCRIPTION_RECOVERY_ADDR;
+			memset(boot, 0, sizeof(bootloader_message));
+			memset(boot->command, '\0', sizeof(boot->command));
+			memset(boot->recovery, '\0', sizeof(boot->recovery));
+			sprintf(boot->command, "boot-recovery");
+			sprintf(boot->recovery, "recovery\n--wipe_data");
+
+			ret = factory_write(BOOT_RECOVERY_FILE_NAME, (char *)boot, CONFIG_RECOVERY_SIZE);
+			if (ret != 0) { 
+			    // failed case
+				printf("[ENV] write_recovery failed\n");
+		    }
+			else
+				factory_save();
+
+            bEnterRecovery = 1;
+        }
+        else if (bKeyVolumeUp && bKeyVolumeDown) {
+            printf("VolumeUp + VolumeDown : backup update \n");
+
+            boot = (bootloader_message *)BACKUP_DESCRIPTION_RECOVERY_ADDR;
+			memset(boot, 0, sizeof(bootloader_message));
+			memset(boot->command, '\0', sizeof(boot->command));
+			memset(boot->recovery, '\0', sizeof(boot->recovery));
+			sprintf(boot->command, "boot-recovery");
+			sprintf(boot->recovery, "recovery\n--update_package=BACKUP:update.zip\n--locale=en_GB");
+
+			ret = factory_write(BOOT_RECOVERY_FILE_NAME, (char *)boot, CONFIG_RECOVERY_SIZE);
+			if (ret != 0) { 
+			    // failed case
+				printf("[ENV] write_recovery failed\n");
+		    }
+			else
+				factory_save();
+
+            bEnterRecovery = 1;
+        }
+#endif    
+    }
+#endif					
+#if CONFIG_ANDROID_RECOVERY
+        if (!abort) {
+                printf("======== Checking into android recovery ====\n");							
+                if (bEnterRecovery == 1) {                    		     	                				
+                    setenv("rescue_cmd", "go ra");
+                    boot_mode = BOOT_ANDROID_MODE;                    
+                    abort = 1;
+                    return abort;
+                }
+        }
+#endif
+#ifdef CONFIG_USB_UPDATE_WHEN_AC_ON
+	if (!abort) {
+
+		if (boot_ac_on == 1)
+		{
+			uchar bUsb_need_init = 1;
+
+			printf("\nboot_ac_on=%d\n", boot_ac_on);
+
+#ifdef CONFIG_USB_UPDATE_UBOOT_WHEN_AC_ON
+			// check dvrboot.exe.bin from usb
+			if (check_usb_update("dvrboot.exe.bin", 1, bUsb_need_init))
+			{
+				run_command_list("go 0x1500000 nocache", -1, 0);
+
+				boot_mode = BOOT_CONSOLE_MODE;
+				abort = 1; /* don't auto boot	*/
+			}
+			bUsb_need_init = 0;
+#endif /* CONFIG_USB_UPDATE_UBOOT_WHEN_AC_ON */
+
+			// check install.img from usb
+			if (check_usb_update("install.img", 0, bUsb_need_init))
+			{
+#ifdef CONFIG_USB_UPDATE_READ_RESCUE_FROM_FLASH
+				setenv("rescue_cmd", "go r");
+#else
+				setenv("rescue_cmd", "go k");
+#endif
+				boot_mode = BOOT_RESCUE_MODE;
+				abort = 1; /* don't auto boot	*/
+			}
+		}
+
+	}
+#endif /* CONFIG_USB_UPDATE_WHEN_AC_ON */
+
+#endif	/* CONFIG_BSP_REALTEK */
+
+
+	while ((bootdelay > 0) && (!abort)) {
+		int i;
+
+		--bootdelay;
+		/* delay 100 * 10ms */
+		for (i=0; !abort && i<100; ++i) {
+			if (tstc()) {	/* we got a key press	*/
+				abort  = 1;	/* don't auto boot	*/
+				bootdelay = 0;	/* no more delay	*/
+# ifdef CONFIG_MENUKEY
+				menukey = getc();
+# else
+				(void) getc();  /* consume input	*/
+# endif
+				break;
+			}
+			udelay(10000);
+		}
+
+		printf("\b\b\b%2d ", bootdelay);
+	}
+
+	putc('\n');
+
+#ifdef CONFIG_SILENT_CONSOLE
+	if (abort)
+		gd->flags &= ~GD_FLG_SILENT;
+#endif
+
+	return abort;
+}
+# endif	/* CONFIG_AUTOBOOT_KEYED */
+#endif	/* CONFIG_BOOTDELAY >= 0  */
+
+/****************************************************************************/
+
+void main_loop (void)
+{
+#ifndef CONFIG_SYS_HUSH_PARSER
+	static char lastcommand[CONFIG_SYS_CBSIZE] = { 0, };
+	int len;
+	int rc = 1;
+	int flag;
+#endif
+
+#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
+	char *s;
+	int bootdelay;
+#endif
 #ifdef CONFIG_PREBOOT
 	char *p;
+#endif
+#ifdef CONFIG_BOOTCOUNT_LIMIT
+	unsigned long bootcount = 0;
+	unsigned long bootlimit = 0;
+	char *bcs;
+	char bcs_set[16];
+#endif /* CONFIG_BOOTCOUNT_LIMIT */
+	
+	int check_default_var;
+	check_default_var = check_default_env("Checking default environment\n");
+	if (!check_default_var)
+		run_command_list("env save", -1, 0);
+
+#ifdef CONFIG_BOOTCOUNT_LIMIT
+	bootcount = bootcount_load();
+	bootcount++;
+	bootcount_store (bootcount);
+	sprintf (bcs_set, "%lu", bootcount);
+	setenv ("bootcount", bcs_set);
+	bcs = getenv ("bootlimit");
+	bootlimit = bcs ? simple_strtoul (bcs, NULL, 10) : 0;
+#endif /* CONFIG_BOOTCOUNT_LIMIT */
+
+#ifdef CONFIG_MODEM_SUPPORT
+	debug ("DEBUG: main_loop:   do_mdm_init=%d\n", do_mdm_init);
+	if (do_mdm_init) {
+		char *str = strdup(getenv("mdm_cmd"));
+		setenv ("preboot", str);  /* set or delete definition */
+		if (str != NULL)
+			free (str);
+		mdm_init(); /* wait for modem connection */
+	}
+#endif  /* CONFIG_MODEM_SUPPORT */
+
+#ifdef CONFIG_VERSION_VARIABLE
+	{
+		setenv ("ver", version_string);  /* set version variable */
+	}
+#endif /* CONFIG_VERSION_VARIABLE */
 
-	p = getenv("preboot");
-	if (p != NULL) {
+        WATCHDOG_KICK();
+
+
+#ifdef CONFIG_SYS_HUSH_PARSER
+	u_boot_hush_start ();
+#endif
+
+#if defined(CONFIG_HUSH_INIT_VAR)
+	hush_init_var ();
+#endif
+
+#ifdef CONFIG_PREBOOT
+	if ((p = getenv ("preboot")) != NULL) {
 # ifdef CONFIG_AUTOBOOT_KEYED
 		int prev = disable_ctrlc(1);	/* disable Control C checking */
 # endif
@@ -50,39 +792,1230 @@ static void run_preboot_environment_command(void)
 # endif
 	}
 #endif /* CONFIG_PREBOOT */
+
+#if defined(CONFIG_UPDATE_TFTP)
+	update_tftp (0UL);
+#endif /* CONFIG_UPDATE_TFTP */
+
+#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
+	s = getenv ("bootdelay");
+	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
+
+	debug ("### main_loop entered: bootdelay=%d\n\n", bootdelay);
+
+#if defined(CONFIG_MENU_SHOW)
+	bootdelay = menu_show(bootdelay);
+#endif
+# ifdef CONFIG_BOOT_RETRY_TIME
+	init_cmd_timeout ();
+# endif	/* CONFIG_BOOT_RETRY_TIME */
+
+#ifdef CONFIG_POST
+	if (gd->flags & GD_FLG_POSTFAIL) {
+		s = getenv("failbootcmd");
+	}
+	else
+#endif /* CONFIG_POST */
+#ifdef CONFIG_BOOTCOUNT_LIMIT
+	if (bootlimit && (bootcount > bootlimit)) {
+		printf ("Warning: Bootlimit (%u) exceeded. Using altbootcmd.\n",
+		        (unsigned)bootlimit);
+		s = getenv ("altbootcmd");
+	}
+	else
+#endif /* CONFIG_BOOTCOUNT_LIMIT */
+		s = getenv ("bootcmd");
+
+#ifdef CONFIG_QC_VERIFY
+	s = NULL;
+	boot_mode = BOOT_QC_VERIFY_MODE;
+#else
+	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
+#endif
+#ifdef CONFIG_MODULE_TEST
+    char mt_test[8] = "test\0";
+    s = mt_test;
+#endif
+
+	if (s == NULL) {
+		printf("[WARN] bootcmd in env is NULL.\n");
+		printf("[WARN] you need to execute \"env default -f\" to reset env.\n");
+	}
+
+	if (bootdelay >= 0 && s && !abortboot (bootdelay)) {
+#ifdef CONFIG_CUSTOMIZE_BOOTFLOW_1
+		normal_boot = customize_check_normal_boot();
+#endif
+#ifdef CONFIG_AUTOBOOT_KEYED
+		int prev = disable_ctrlc(1);	/* disable Control C checking */
+#endif
+#ifdef CONFIG_AUTO_RUN_BOOTLOADER
+	    printf("Load bootcode2\n");
+	    WATCHDOG_DISABLE();
+	    run_command_list("bcldr", -1, 0);
+	    printf("!!!Load bootcode2 fail!!!\n");
+#endif
+#ifdef CONFIG_CUSTOMIZE_ACCELERATE_BOOT_BLUE_LOGO
+#if !defined(NAS_DUAL) && !defined(CONFIG_BOOT_FROM_SPI)
+		/*Accelerate boot blue logo with bootr f*/
+		run_command_list("bootr f", -1, 0);
+		run_command_list("go a", -1, 0);
+#ifdef NAS_ENABLE
+		mdelay(100); /* wait audio fw log print out */
+#endif
+#endif
+#endif
+		run_command_list(s, -1, 0);
+
+		/* enter rescue mode because of booting failed or other reasons */
+		boot_mode = BOOT_RESCUE_MODE;
+
+# ifdef CONFIG_AUTOBOOT_KEYED
+		disable_ctrlc(prev);	/* restore Control C checking */
+# endif
+	}
+	
+	//printf("######## PK boot_mode:[%d] [%s]\n", boot_mode, getenv("rescue_cmd"));
+/***********************************************************
+ * Realtek Patch
+ ***********************************************************/
+#ifdef CONFIG_BSP_REALTEK
+	if (boot_mode == BOOT_RESCUE_MODE || boot_mode == BOOT_ANDROID_MODE) {	/* Enter rescue linux */
+#ifdef CONFIG_REALTEK_WATCHDOG
+                WATCHDOG_KICK();
+#else
+                WATCHDOG_DISABLE();
+#endif
+		s = getenv ("rescue_cmd");
+		if (s)
+			run_command_list(s, -1, 0);
+		boot_mode = BOOT_CONSOLE_MODE;
+	}
+	else if (boot_mode == BOOT_MANUAL_MODE) {	/* Load images but boot manually */
+             WATCHDOG_DISABLE();
+		run_command_list("bootr m", -1, 0);
+	}
+	else if (boot_mode == BOOT_QC_VERIFY_MODE) {	/* For QC code */
+             WATCHDOG_DISABLE();
+		run_command_list("qc", -1, 0);
+	}
+#ifdef CONFIG_RUN_FLASH_WRITER
+	else if (boot_mode == BOOT_FLASH_WRITER_MODE) {	/* For Flash Writer */
+             WATCHDOG_DISABLE();
+		run_command_list("go 0x1500000", -1, 0);
+	}
+#endif
+
+#endif /* CONFIG_BSP_REALTEK */
+
+# ifdef CONFIG_MENUKEY
+	if (menukey == CONFIG_MENUKEY) {
+		s = getenv("menucmd");
+		if (s)
+			run_command_list(s, -1, 0);
+	}
+#endif /* CONFIG_MENUKEY */
+#endif /* CONFIG_BOOTDELAY */
+
+	/*
+	 * Main Loop for Monitor Command Processing
+	 */
+#ifdef CONFIG_SYS_HUSH_PARSER
+	WATCHDOG_DISABLE();
+	puts("Enter console mode, disable watchdog ...\n\n");
+	parse_file_outer();
+	/* This point is never reached */
+
+	for (;;);
+
+#else
+	for (;;) {
+#ifdef CONFIG_BOOT_RETRY_TIME
+		if (rc >= 0) {
+			/* Saw enough of a valid command to
+			 * restart the timeout.
+			 */
+			reset_cmd_timeout();
+		}
+#endif
+		len = readline (CONFIG_SYS_PROMPT);
+
+		flag = 0;	/* assume no special flags for now */
+		if (len > 0)
+			strcpy (lastcommand, console_buffer);
+		else if (len == 0)
+			flag |= CMD_FLAG_REPEAT;
+#ifdef CONFIG_BOOT_RETRY_TIME
+		else if (len == -2) {
+			/* -2 means timed out, retry autoboot
+			 */
+			puts ("\nTimed out waiting for command\n");
+# ifdef CONFIG_RESET_TO_RETRY
+			/* Reinit board to run initialization code again */
+			do_reset (NULL, 0, 0, NULL);
+# else
+			return;		/* retry autoboot */
+# endif
+		}
+#endif
+
+		if (len == -1)
+			puts ("<INTERRUPT>\n");
+		else
+			rc = run_command(lastcommand, flag);
+
+		if (rc <= 0) {
+			/* invalid command or not repeatable, forget it */
+			lastcommand[0] = 0;
+		}
+	}
+#endif /*CONFIG_SYS_HUSH_PARSER*/
 }
 
-/* We come here after U-Boot is initialised and ready to process commands */
-void main_loop(void)
+#ifdef CONFIG_BOOT_RETRY_TIME
+/***************************************************************************
+ * initialize command line timeout
+ */
+void init_cmd_timeout(void)
 {
-	const char *s;
+	char *s = getenv ("bootretry");
+
+	if (s != NULL)
+		retry_time = (int)simple_strtol(s, NULL, 10);
+	else
+		retry_time =  CONFIG_BOOT_RETRY_TIME;
 
-	bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, "main_loop");
+	if (retry_time >= 0 && retry_time < CONFIG_BOOT_RETRY_MIN)
+		retry_time = CONFIG_BOOT_RETRY_MIN;
+}
 
-#ifndef CONFIG_SYS_GENERIC_BOARD
-	puts("Warning: Your board does not use generic board. Please read\n");
-	puts("doc/README.generic-board and take action. Boards not\n");
-	puts("upgraded by the late 2014 may break or be removed.\n");
+/***************************************************************************
+ * reset command line timeout to retry_time seconds
+ */
+void reset_cmd_timeout(void)
+{
+	endtime = endtick(retry_time);
+}
 #endif
 
-	modem_init();
-#ifdef CONFIG_VERSION_VARIABLE
-	setenv("ver", version_string);  /* set version variable */
-#endif /* CONFIG_VERSION_VARIABLE */
+#ifdef CONFIG_CMDLINE_EDITING
+
+/*
+ * cmdline-editing related codes from vivi.
+ * Author: Janghoon Lyu <nandy@mizi.com>
+ */
 
-	cli_init();
+#define putnstr(str,n)	do {			\
+		printf ("%.*s", (int)n, str);	\
+	} while (0)
 
-	run_preboot_environment_command();
+#define CTL_CH(c)		((c) - 'a' + 1)
+#define CTL_BACKSPACE		('\b')
+#define DEL			((char)255)
+#define DEL7			((char)127)
+#define CREAD_HIST_CHAR		('!')
 
-#if defined(CONFIG_UPDATE_TFTP)
-	update_tftp(0UL);
-#endif /* CONFIG_UPDATE_TFTP */
+#define getcmd_putch(ch)	putc(ch)
+#define getcmd_getch()		getc()
+#define getcmd_cbeep()		getcmd_putch('\a')
 
-	s = bootdelay_process();
-	if (cli_process_fdt(&s))
-		cli_secure_boot_cmd(s);
+#define HIST_MAX		20
+#define HIST_SIZE		CONFIG_SYS_CBSIZE
 
-	autoboot_command(s);
+static int hist_max = 0;
+static int hist_add_idx = 0;
+static int hist_cur = -1;
+unsigned hist_num = 0;
 
-	cli_loop();
+char* hist_list[HIST_MAX];
+char hist_lines[HIST_MAX][HIST_SIZE + 1];	 /* Save room for NULL */
+
+#define add_idx_minus_one() ((hist_add_idx == 0) ? hist_max : hist_add_idx-1)
+
+static void hist_init(void)
+{
+	int i;
+
+	hist_max = 0;
+	hist_add_idx = 0;
+	hist_cur = -1;
+	hist_num = 0;
+
+	for (i = 0; i < HIST_MAX; i++) {
+		hist_list[i] = hist_lines[i];
+		hist_list[i][0] = '\0';
+	}
+}
+
+static void cread_add_to_hist(char *line)
+{
+	strcpy(hist_list[hist_add_idx], line);
+
+	if (++hist_add_idx >= HIST_MAX)
+		hist_add_idx = 0;
+
+	if (hist_add_idx > hist_max)
+		hist_max = hist_add_idx;
+
+	hist_num++;
+}
+
+static char* hist_prev(void)
+{
+	char *ret;
+	int old_cur;
+
+	if (hist_cur < 0)
+		return NULL;
+
+	old_cur = hist_cur;
+	if (--hist_cur < 0)
+		hist_cur = hist_max;
+
+	if (hist_cur == hist_add_idx) {
+		hist_cur = old_cur;
+		ret = NULL;
+	} else
+		ret = hist_list[hist_cur];
+
+	return (ret);
+}
+
+static char* hist_next(void)
+{
+	char *ret;
+
+	if (hist_cur < 0)
+		return NULL;
+
+	if (hist_cur == hist_add_idx)
+		return NULL;
+
+	if (++hist_cur > hist_max)
+		hist_cur = 0;
+
+	if (hist_cur == hist_add_idx) {
+		ret = "";
+	} else
+		ret = hist_list[hist_cur];
+
+	return (ret);
+}
+
+#ifndef CONFIG_CMDLINE_EDITING
+static void cread_print_hist_list(void)
+{
+	int i;
+	unsigned long n;
+
+	n = hist_num - hist_max;
+
+	i = hist_add_idx + 1;
+	while (1) {
+		if (i > hist_max)
+			i = 0;
+		if (i == hist_add_idx)
+			break;
+		printf("%s\n", hist_list[i]);
+		n++;
+		i++;
+	}
+}
+#endif /* CONFIG_CMDLINE_EDITING */
+
+#define BEGINNING_OF_LINE() {			\
+	while (num) {				\
+		getcmd_putch(CTL_BACKSPACE);	\
+		num--;				\
+	}					\
+}
+
+#define ERASE_TO_EOL() {				\
+	if (num < eol_num) {				\
+		printf("%*s", (int)(eol_num - num), ""); \
+		do {					\
+			getcmd_putch(CTL_BACKSPACE);	\
+		} while (--eol_num > num);		\
+	}						\
+}
+
+#define REFRESH_TO_EOL() {			\
+	if (num < eol_num) {			\
+		wlen = eol_num - num;		\
+		putnstr(buf + num, wlen);	\
+		num = eol_num;			\
+	}					\
+}
+
+static void cread_add_char(char ichar, int insert, unsigned long *num,
+	       unsigned long *eol_num, char *buf, unsigned long len)
+{
+	unsigned long wlen;
+
+	/* room ??? */
+	if (insert || *num == *eol_num) {
+		if (*eol_num > len - 1) {
+			getcmd_cbeep();
+			return;
+		}
+		(*eol_num)++;
+	}
+
+	if (insert) {
+		wlen = *eol_num - *num;
+		if (wlen > 1) {
+			memmove(&buf[*num+1], &buf[*num], wlen-1);
+		}
+
+		buf[*num] = ichar;
+		putnstr(buf + *num, wlen);
+		(*num)++;
+		while (--wlen) {
+			getcmd_putch(CTL_BACKSPACE);
+		}
+	} else {
+		/* echo the character */
+		wlen = 1;
+		buf[*num] = ichar;
+		putnstr(buf + *num, wlen);
+		(*num)++;
+	}
+}
+
+static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
+	      unsigned long *eol_num, char *buf, unsigned long len)
+{
+	while (strsize--) {
+		cread_add_char(*str, insert, num, eol_num, buf, len);
+		str++;
+	}
+}
+
+static int cread_line(const char *const prompt, char *buf, unsigned int *len,
+		int timeout)
+{
+	unsigned long num = 0;
+	unsigned long eol_num = 0;
+	unsigned long wlen;
+	char ichar;
+	int insert = 1;
+	int esc_len = 0;
+	char esc_save[8];
+	int init_len = strlen(buf);
+	int first = 1;
+
+	if (init_len)		
+		cread_add_str(buf, init_len, 1, &num, &eol_num, buf, *len);
+		
+	while (1) {
+#ifdef CONFIG_BOOT_RETRY_TIME
+		while (!tstc()) {	/* while no incoming data */
+			if (retry_time >= 0 && get_ticks() > endtime)
+				return (-2);	/* timed out */
+			WATCHDOG_RESET();
+		}
+#endif
+		if (first && timeout) {
+			uint64_t etime = endtick(timeout);
+
+			while (!tstc()) {	/* while no incoming data */
+				if (get_ticks() >= etime)
+					return -2;	/* timed out */
+				WATCHDOG_RESET();
+			}
+			first = 0;
+		}
+
+		ichar = getcmd_getch();
+
+		if ((ichar == '\n') || (ichar == '\r')) {
+			putc('\n');
+			break;
+		}
+
+		/*
+		 * handle standard linux xterm esc sequences for arrow key, etc.
+		 */
+		if (esc_len != 0) {
+			if (esc_len == 1) {
+				if (ichar == '[') {
+					esc_save[esc_len] = ichar;
+					esc_len = 2;
+				} else {
+					cread_add_str(esc_save, esc_len, insert,
+						      &num, &eol_num, buf, *len);
+					esc_len = 0;
+				}
+				continue;
+			}
+
+			switch (ichar) {
+
+			case 'D':	/* <- key */
+				ichar = CTL_CH('b');
+				esc_len = 0;
+				break;
+			case 'C':	/* -> key */
+				ichar = CTL_CH('f');
+				esc_len = 0;
+				break;	/* pass off to ^F handler */
+			case 'H':	/* Home key */
+				ichar = CTL_CH('a');
+				esc_len = 0;
+				break;	/* pass off to ^A handler */
+			case 'A':	/* up arrow */
+				ichar = CTL_CH('p');
+				esc_len = 0;
+				break;	/* pass off to ^P handler */
+			case 'B':	/* down arrow */
+				ichar = CTL_CH('n');
+				esc_len = 0;
+				break;	/* pass off to ^N handler */
+			default:
+				esc_save[esc_len++] = ichar;
+				cread_add_str(esc_save, esc_len, insert,
+					      &num, &eol_num, buf, *len);
+				esc_len = 0;
+				continue;
+			}
+		}
+
+		switch (ichar) {
+		case 0x1b:
+			if (esc_len == 0) {
+				esc_save[esc_len] = ichar;
+				esc_len = 1;
+			} else {
+				puts("impossible condition #876\n");
+				esc_len = 0;
+			}
+			break;
+
+		case CTL_CH('a'):
+			BEGINNING_OF_LINE();
+			break;
+		case CTL_CH('c'):	/* ^C - break */
+			*buf = '\0';	/* discard input */
+			return (-1);
+		case CTL_CH('f'):
+			if (num < eol_num) {
+				getcmd_putch(buf[num]);
+				num++;
+			}
+			break;
+		case CTL_CH('b'):
+			if (num) {
+				getcmd_putch(CTL_BACKSPACE);
+				num--;
+			}
+			break;
+		case CTL_CH('d'):
+			if (num < eol_num) {
+				wlen = eol_num - num - 1;
+				if (wlen) {
+					memmove(&buf[num], &buf[num+1], wlen);
+					putnstr(buf + num, wlen);
+				}
+
+				getcmd_putch(' ');
+				do {
+					getcmd_putch(CTL_BACKSPACE);
+				} while (wlen--);
+				eol_num--;
+			}
+			 break;
+		case CTL_CH('k'):
+			ERASE_TO_EOL();
+			break;
+		case CTL_CH('e'):
+			REFRESH_TO_EOL();
+			break;
+		case CTL_CH('o'):
+			insert = !insert;
+			break;
+		case CTL_CH('x'):
+		case CTL_CH('u'):
+			BEGINNING_OF_LINE();
+			ERASE_TO_EOL();
+			break;
+		case DEL:
+		case DEL7:
+		case 8:
+			if (num) {
+				wlen = eol_num - num;
+				num--;
+				memmove(&buf[num], &buf[num+1], wlen);
+				getcmd_putch(CTL_BACKSPACE);
+				putnstr(buf + num, wlen);
+				getcmd_putch(' ');
+				do {
+					getcmd_putch(CTL_BACKSPACE);
+				} while (wlen--);
+				eol_num--;
+			}
+			break;
+		case CTL_CH('p'):
+		case CTL_CH('n'):
+		{
+			char * hline;
+
+			esc_len = 0;
+
+			if (ichar == CTL_CH('p'))
+				hline = hist_prev();
+			else
+				hline = hist_next();
+
+			if (!hline) {
+				getcmd_cbeep();
+				continue;
+			}
+
+			/* nuke the current line */
+			/* first, go home */
+			BEGINNING_OF_LINE();
+
+			/* erase to end of line */
+			ERASE_TO_EOL();
+
+			/* copy new line into place and display */
+			strcpy(buf, hline);
+			eol_num = strlen(buf);
+			REFRESH_TO_EOL();
+			continue;
+		}
+#ifdef CONFIG_AUTO_COMPLETE
+		case '\t': {
+			int num2, col;
+						
+			/* do not autocomplete at beginning */
+			if(num==0){
+				ERASE_TO_EOL();
+				break;
+			}
+			/* do not autocomplete when in the middle */
+			if (num < eol_num) {
+				getcmd_cbeep();
+				break;
+			}
+
+			buf[num] = '\0';
+			col = strlen(prompt) + eol_num;
+			num2 = num;
+			if (cmd_auto_complete(prompt, buf, &num2, &col)) {
+				col = num2 - num;
+				num += col;
+				eol_num += col;
+			}
+			break;
+		}
+#endif
+		default:
+			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
+			break;
+		}
+	}
+	*len = eol_num;
+	buf[eol_num] = '\0';	/* lose the newline */
+
+	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
+		cread_add_to_hist(buf);
+	hist_cur = hist_add_idx;
+
+	return 0;
+}
+
+#endif /* CONFIG_CMDLINE_EDITING */
+
+/****************************************************************************/
+
+/*
+ * Prompt for input and read a line.
+ * If  CONFIG_BOOT_RETRY_TIME is defined and retry_time >= 0,
+ * time out when time goes past endtime (timebase time in ticks).
+ * Return:	number of read characters
+ *		-1 if break
+ *		-2 if timed out
+ */
+int readline (const char *const prompt)
+{
+	/*
+	 * If console_buffer isn't 0-length the user will be prompted to modify
+	 * it instead of entering it from scratch as desired.
+	 */
+	console_buffer[0] = '\0';
+
+	return readline_into_buffer(prompt, console_buffer, 0);
+}
+
+
+int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
+{
+	char *p = buffer;
+#ifdef CONFIG_CMDLINE_EDITING
+	unsigned int len = CONFIG_SYS_CBSIZE;
+	int rc;
+	static int initted = 0;
+
+	/*
+	 * History uses a global array which is not
+	 * writable until after relocation to RAM.
+	 * Revert to non-history version if still
+	 * running from flash.
+	 */
+	if (gd->flags & GD_FLG_RELOC) {
+		if (!initted) {
+			hist_init();
+			initted = 1;
+		}
+
+		if (prompt){
+            puts (prompt);
+#ifdef CONFIG_MODULE_TEST
+            if(gd->flags & GD_FLG_MTMODE)
+                printf("\nModule Test Command:");
+#endif
+        }
+
+		rc = cread_line(prompt, p, &len, timeout);
+		return rc < 0 ? rc : len;
+
+	} else {
+#endif	/* CONFIG_CMDLINE_EDITING */
+	char * p_buf = p;
+	int	n = 0;				/* buffer index		*/
+	int	plen = 0;			/* prompt length	*/
+	int	col;				/* output column cnt	*/
+	char c;
+
+	/* print prompt */
+	if (prompt) {
+		plen = strlen (prompt);
+		puts (prompt);
+	}
+	col = plen;
+
+	for (;;) {
+#ifdef CONFIG_BOOT_RETRY_TIME
+		while (!tstc()) {	/* while no incoming data */
+			if (retry_time >= 0 && get_ticks() > endtime)
+				return (-2);	/* timed out */
+			WATCHDOG_RESET();
+		}
+#endif
+		WATCHDOG_RESET();		/* Trigger watchdog, if needed */
+
+#ifdef CONFIG_SHOW_ACTIVITY
+		while (!tstc()) {
+			show_activity(0);
+			WATCHDOG_RESET();
+		}
+#endif
+		c = getc();
+
+		/*
+		 * Special character handling
+		 */
+		switch (c) {
+		case '\r':				/* Enter		*/
+		case '\n':
+			*p = '\0';
+			puts ("\r\n");
+			return (p - p_buf);
+
+		case '\0':				/* nul			*/
+			continue;
+
+		case 0x03:				/* ^C - break		*/
+			p_buf[0] = '\0';	/* discard input */
+			return (-1);
+
+		case 0x15:				/* ^U - erase line	*/
+			while (col > plen) {
+				puts (erase_seq);
+				--col;
+			}
+			p = p_buf;
+			n = 0;
+			continue;
+
+		case 0x17:				/* ^W - erase word	*/
+			p=delete_char(p_buf, p, &col, &n, plen);
+			while ((n > 0) && (*p != ' ')) {
+				p=delete_char(p_buf, p, &col, &n, plen);
+			}
+			continue;
+
+		case 0x08:				/* ^H  - backspace	*/
+		case 0x7F:				/* DEL - backspace	*/
+			p=delete_char(p_buf, p, &col, &n, plen);
+			continue;
+
+		default:
+			/*
+			 * Must be a normal character then
+			 */
+			if (n < CONFIG_SYS_CBSIZE-2) {
+				if (c == '\t') {	/* expand TABs		*/
+#ifdef CONFIG_AUTO_COMPLETE
+					/* if auto completion triggered just continue */
+					*p = '\0';
+					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
+						p = p_buf + n;	/* reset */
+						continue;
+					}
+#endif
+					puts (tab_seq+(col&07));
+					col += 8 - (col&07);
+				} else {
+					++col;		/* echo input		*/
+					putc (c);
+				}
+				*p++ = c;
+				++n;
+			} else {			/* Buffer full		*/
+				putc ('\a');
+			}
+		}
+	}
+#ifdef CONFIG_CMDLINE_EDITING
+	}
+#endif
 }
+
+/****************************************************************************/
+
+static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
+{
+	char *s;
+
+	if (*np == 0) {
+		return (p);
+	}
+
+	if (*(--p) == '\t') {			/* will retype the whole line	*/
+		while (*colp > plen) {
+			puts (erase_seq);
+			(*colp)--;
+		}
+		for (s=buffer; s<p; ++s) {
+			if (*s == '\t') {
+				puts (tab_seq+((*colp) & 07));
+				*colp += 8 - ((*colp) & 07);
+			} else {
+				++(*colp);
+				putc (*s);
+			}
+		}
+	} else {
+		puts (erase_seq);
+		(*colp)--;
+	}
+	(*np)--;
+	return (p);
+}
+
+/****************************************************************************/
+
+int parse_line (char *line, char *argv[])
+{
+	int nargs = 0;
+
+#ifdef DEBUG_PARSER
+	printf ("parse_line: \"%s\"\n", line);
+#endif
+	while (nargs < CONFIG_SYS_MAXARGS) {
+
+		/* skip any white space */
+		while (isblank(*line))
+			++line;
+
+		if (*line == '\0') {	/* end of line, no more args	*/
+			argv[nargs] = NULL;
+#ifdef DEBUG_PARSER
+		printf ("parse_line: nargs=%d\n", nargs);
+#endif
+			return (nargs);
+		}
+
+		argv[nargs++] = line;	/* begin of argument string	*/
+
+		/* find end of string */
+		while (*line && !isblank(*line))
+			++line;
+
+		if (*line == '\0') {	/* end of line, no more args	*/
+			argv[nargs] = NULL;
+#ifdef DEBUG_PARSER
+		printf ("parse_line: nargs=%d\n", nargs);
+#endif
+			return (nargs);
+		}
+
+		*line++ = '\0';		/* terminate current arg	 */
+	}
+
+	printf ("** Too many args (max. %d) **\n", CONFIG_SYS_MAXARGS);
+
+#ifdef DEBUG_PARSER
+	printf ("parse_line: nargs=%d\n", nargs);
+#endif
+	return (nargs);
+}
+
+/****************************************************************************/
+
+#ifndef CONFIG_SYS_HUSH_PARSER
+static void process_macros (const char *input, char *output)
+{
+	char c, prev;
+	const char *varname_start = NULL;
+	int inputcnt = strlen (input);
+	int outputcnt = CONFIG_SYS_CBSIZE;
+	int state = 0;		/* 0 = waiting for '$'  */
+
+	/* 1 = waiting for '(' or '{' */
+	/* 2 = waiting for ')' or '}' */
+	/* 3 = waiting for '''  */
+#ifdef DEBUG_PARSER
+	char *output_start = output;
+
+	printf ("[PROCESS_MACROS] INPUT len %d: \"%s\"\n", strlen (input),
+		input);
+#endif
+
+	prev = '\0';		/* previous character   */
+
+	while (inputcnt && outputcnt) {
+		c = *input++;
+		inputcnt--;
+
+		if (state != 3) {
+			/* remove one level of escape characters */
+			if ((c == '\\') && (prev != '\\')) {
+				if (inputcnt-- == 0)
+					break;
+				prev = c;
+				c = *input++;
+			}
+		}
+
+		switch (state) {
+		case 0:	/* Waiting for (unescaped) $    */
+			if ((c == '\'') && (prev != '\\')) {
+				state = 3;
+				break;
+			}
+			if ((c == '$') && (prev != '\\')) {
+				state++;
+			} else {
+				*(output++) = c;
+				outputcnt--;
+			}
+			break;
+		case 1:	/* Waiting for (        */
+			if (c == '(' || c == '{') {
+				state++;
+				varname_start = input;
+			} else {
+				state = 0;
+				*(output++) = '$';
+				outputcnt--;
+
+				if (outputcnt) {
+					*(output++) = c;
+					outputcnt--;
+				}
+			}
+			break;
+		case 2:	/* Waiting for )        */
+			if (c == ')' || c == '}') {
+				int i;
+				char envname[CONFIG_SYS_CBSIZE], *envval;
+				int envcnt = input - varname_start - 1;	/* Varname # of chars */
+
+				/* Get the varname */
+				for (i = 0; i < envcnt; i++) {
+					envname[i] = varname_start[i];
+				}
+				envname[i] = 0;
+
+				/* Get its value */
+				envval = getenv (envname);
+
+				/* Copy into the line if it exists */
+				if (envval != NULL)
+					while ((*envval) && outputcnt) {
+						*(output++) = *(envval++);
+						outputcnt--;
+					}
+				/* Look for another '$' */
+				state = 0;
+			}
+			break;
+		case 3:	/* Waiting for '        */
+			if ((c == '\'') && (prev != '\\')) {
+				state = 0;
+			} else {
+				*(output++) = c;
+				outputcnt--;
+			}
+			break;
+		}
+		prev = c;
+	}
+
+	if (outputcnt)
+		*output = 0;
+	else
+		*(output - 1) = 0;
+
+#ifdef DEBUG_PARSER
+	printf ("[PROCESS_MACROS] OUTPUT len %d: \"%s\"\n",
+		strlen (output_start), output_start);
+#endif
+}
+
+/****************************************************************************
+ * returns:
+ *	1  - command executed, repeatable
+ *	0  - command executed but not repeatable, interrupted commands are
+ *	     always considered not repeatable
+ *	-1 - not executed (unrecognized, bootd recursion or too many args)
+ *           (If cmd is NULL or "" or longer than CONFIG_SYS_CBSIZE-1 it is
+ *           considered unrecognized)
+ *
+ * WARNING:
+ *
+ * We must create a temporary copy of the command since the command we get
+ * may be the result from getenv(), which returns a pointer directly to
+ * the environment data, which may change magicly when the command we run
+ * creates or modifies environment variables (like "bootp" does).
+ */
+static int builtin_run_command(const char *cmd, int flag)
+{
+	char cmdbuf[CONFIG_SYS_CBSIZE];	/* working copy of cmd		*/
+	char *token;			/* start of token in cmdbuf	*/
+	char *sep;			/* end of token (separator) in cmdbuf */
+	char finaltoken[CONFIG_SYS_CBSIZE];
+	char *str = cmdbuf;
+	char *argv[CONFIG_SYS_MAXARGS + 1];	/* NULL terminated	*/
+	int argc, inquotes;
+	int repeatable = 1;
+	int rc = 0;
+
+#ifdef DEBUG_PARSER
+	printf ("[RUN_COMMAND] cmd[%p]=\"", cmd);
+	puts (cmd ? cmd : "NULL");	/* use puts - string may be loooong */
+	puts ("\"\n");
+#endif
+
+	clear_ctrlc();		/* forget any previous Control C */
+
+	if (!cmd || !*cmd) {
+		return -1;	/* empty command */
+	}
+
+	if (strlen(cmd) >= CONFIG_SYS_CBSIZE) {
+		puts ("## Command too long!\n");
+		return -1;
+	}
+
+	strcpy (cmdbuf, cmd);
+
+	/* Process separators and check for invalid
+	 * repeatable commands
+	 */
+
+#ifdef DEBUG_PARSER
+	printf ("[PROCESS_SEPARATORS] %s\n", cmd);
+#endif
+	while (*str) {
+
+		/*
+		 * Find separator, or string end
+		 * Allow simple escape of ';' by writing "\;"
+		 */
+		for (inquotes = 0, sep = str; *sep; sep++) {
+			if ((*sep=='\'') &&
+			    (*(sep-1) != '\\'))
+				inquotes=!inquotes;
+
+			if (!inquotes &&
+			    (*sep == ';') &&	/* separator		*/
+			    ( sep != str) &&	/* past string start	*/
+			    (*(sep-1) != '\\'))	/* and NOT escaped	*/
+				break;
+		}
+
+		/*
+		 * Limit the token to data between separators
+		 */
+		token = str;
+		if (*sep) {
+			str = sep + 1;	/* start of command for next pass */
+			*sep = '\0';
+		}
+		else
+			str = sep;	/* no more commands for next pass */
+#ifdef DEBUG_PARSER
+		printf ("token: \"%s\"\n", token);
+#endif
+
+		/* find macros in this token and replace them */
+		process_macros (token, finaltoken);
+
+		/* Extract arguments */
+		if ((argc = parse_line (finaltoken, argv)) == 0) {
+			rc = -1;	/* no command at all */
+			continue;
+		}
+
+		if (cmd_process(flag, argc, argv, &repeatable))
+			rc = -1;
+
+		/* Did the user stop this? */
+		if (had_ctrlc ())
+			return -1;	/* if stopped then not repeatable */
+	}
+
+	return rc ? rc : repeatable;
+}
+#endif
+
+/*
+ * Run a command using the selected parser.
+ *
+ * @param cmd	Command to run
+ * @param flag	Execution flags (CMD_FLAG_...)
+ * @return 0 on success, or != 0 on error.
+ */
+int run_command(const char *cmd, int flag)
+{
+#ifndef CONFIG_SYS_HUSH_PARSER
+	/*
+	 * builtin_run_command can return 0 or 1 for success, so clean up
+	 * its result.
+	 */
+	if (builtin_run_command(cmd, flag) == -1)
+		return 1;
+
+	return 0;
+#else
+	return parse_string_outer(cmd,
+			FLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOP);
+#endif
+}
+
+#ifndef CONFIG_SYS_HUSH_PARSER
+/**
+ * Execute a list of command separated by ; or \n using the built-in parser.
+ *
+ * This function cannot take a const char * for the command, since if it
+ * finds newlines in the string, it replaces them with \0.
+ *
+ * @param cmd	String containing list of commands
+ * @param flag	Execution flags (CMD_FLAG_...)
+ * @return 0 on success, or != 0 on error.
+ */
+static int builtin_run_command_list(char *cmd, int flag)
+{
+	char *line, *next;
+	int rcode = 0;
+
+	/*
+	 * Break into individual lines, and execute each line; terminate on
+	 * error.
+	 */
+	line = next = cmd;
+	while (*next) {
+		if (*next == '\n') {
+			*next = '\0';
+			/* run only non-empty commands */
+			if (*line) {
+				debug("** exec: \"%s\"\n", line);
+				if (builtin_run_command(line, 0) < 0) {
+					rcode = 1;
+					break;
+				}
+			}
+			line = next + 1;
+		}
+		++next;
+	}
+	if (rcode == 0 && *line)
+		rcode = (builtin_run_command(line, 0) >= 0);
+
+	return rcode;
+}
+#endif
+
+int run_command_list(const char *cmd, int len, int flag)
+{
+	int need_buff = 1;
+	char *buff = (char *)cmd;	/* cast away const */
+	int rcode = 0;
+
+	if (len == -1) {
+		len = strlen(cmd);
+#ifdef CONFIG_SYS_HUSH_PARSER
+		/* hush will never change our string */
+		need_buff = 0;
+#else
+		/* the built-in parser will change our string if it sees \n */
+		need_buff = strchr(cmd, '\n') != NULL;
+#endif
+	}
+	if (need_buff) {
+		buff = malloc(len + 1);
+		if (!buff)
+			return 1;
+		memcpy(buff, cmd, len);
+		buff[len] = '\0';
+	}	
+	
+#ifdef CONFIG_SYS_HUSH_PARSER
+
+	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
+		
+#else
+	/*
+	 * This function will overwrite any \n it sees with a \0, which
+	 * is why it can't work with a const char *. Here we are making
+	 * using of internal knowledge of this function, to avoid always
+	 * doing a malloc() which is actually required only in a case that
+	 * is pretty rare.
+	 */ 
+	rcode = builtin_run_command_list(buff, flag);
+		
+	if (need_buff)
+		free(buff);
+#endif
+
+	return rcode;
+}
+
+/****************************************************************************/
+
+#if defined(CONFIG_CMD_RUN)
+int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	int i;
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	for (i=1; i<argc; ++i) {
+		char *arg;
+
+		if ((arg = getenv (argv[i])) == NULL) {
+			printf ("## Error: \"%s\" not defined\n", argv[i]);
+			return 1;
+		}
+
+		if (run_command(arg, flag) != 0)
+			return 1;
+	}
+	return 0;
+}
+#endif
diff --git a/common/usb.c b/common/usb.c
index 7ff8ac5df3..531dd3bd43 100644
--- a/common/usb.c
+++ b/common/usb.c
@@ -26,6 +26,7 @@
  *
  * For each transfer (except "Interrupt") we wait for completion.
  */
+
 #include <common.h>
 #include <command.h>
 #include <dm.h>
@@ -36,6 +37,8 @@
 #include <asm/unaligned.h>
 #include <errno.h>
 #include <usb.h>
+#include <asm/arch/usb.h>
+#include <asm/arch/platform_lib/board/gpio.h>
 #ifdef CONFIG_4xx
 #include <asm/4xx_pci.h>
 #endif
@@ -53,6 +56,180 @@ static int dev_index;
 #define CONFIG_USB_MAX_CONTROLLER_COUNT 1
 #endif
 
+
+// CRT_SOFT_RESET1 usb part
+#define rstn_usb_phy1 		(0x1 << 9)
+#define rstn_usb_phy0 		(0x1 << 8)
+#define rstn_usb 			(0x1 << 6)
+#define rstn_usb3_p0_mdio 	(0x1 << 4)
+#define rstn_usb3_phy0_pow 	(0x1 << 2)
+// CRT_SOFT_RESET2 usb part
+#define rstn_usb3_p1_mdio 	(0x1 << 5)
+#define rstn_usb3_phy1_pow 	(0x1 << 4)
+#define rstn_usb_phy2 		(0x1 << 3)
+#define rstn_usb_phy3 		(0x1 << 2)
+// CRT_CLOCK_ENABLE1 usb part
+#define clk_en_usb 			(0x1 << 4)
+
+#if 0
+static int usb_clk_enable(void) {
+	static int enabled = 0;
+	void *reset1 = (void *)(uintptr_t)RTD1295_CRT_BASE + 0x0;
+	void *reset2 = (void *)(uintptr_t)RTD1295_CRT_BASE + 0x4;
+	void *clk_en1 = (void *)(uintptr_t)RTD1295_CRT_BASE + 0xC;
+
+	int reset1_pll_flag = rstn_usb_phy1 | rstn_usb_phy0 | rstn_usb3_phy0_pow;
+	int reset2_pll_flag = rstn_usb_phy2;// | rstn_usb_phy3 | rstn_usb3_phy1_pow;
+	int reset1_usb_flag = rstn_usb3_p0_mdio | rstn_usb;
+	int reset2_usb_flag = 0;// rstn_usb3_p1_mdio;
+
+	if (enabled == 1) {
+		debug("Realtek-usb clock Enabled\n");
+		return 0;
+	}
+
+	if (get_cpu_id() == RTK1296_CPU_ID) {
+		debug("Realtek-usb 1296 u3host clock\n");
+		if (get_rtd129x_cpu_revision() == RTD129x_CHIP_REVISION_A00) {
+			__raw_writel(0x00000F05, 0x98007FA0);
+			debug("Realtek-usb 1296 A00 enabled power\n");
+		}
+		reset2_pll_flag = rstn_usb_phy2 | rstn_usb_phy3 | rstn_usb3_phy1_pow;
+		reset2_usb_flag = rstn_usb3_p1_mdio;
+	}
+
+	debug("Realtek-usb Start ....\n");
+	debug("Realtek-usb init start soft_reset1=%x, soft_reset2=%x, clock_enable1=%x\n",
+		(uint32_t)(__raw_readl((volatile u32*)reset1)),
+		(uint32_t)(__raw_readl((volatile u32*)reset2)),
+		(uint32_t)(__raw_readl((volatile u32*)clk_en1)));
+
+	//Enable PLL
+	__raw_writel(reset1_pll_flag | __raw_readl((volatile u32*)reset1), (volatile u32*) reset1);
+	__raw_writel(reset2_pll_flag | __raw_readl((volatile u32*)reset2), (volatile u32*) reset2);
+
+	mdelay(200);
+	debug("Realtek-usb: Enable PLL soft_reset1=%x, soft_reset2=%x, clock_enable1=%x\n",
+		(uint32_t)(__raw_readl((volatile u32*)reset1)),
+		(uint32_t)(__raw_readl((volatile u32*)reset2)),
+		(uint32_t)(__raw_readl((volatile u32*)clk_en1)));
+
+	//Reset USB
+	//__raw_writel(0x354 | __raw_readl((volatile u32*)reset1), (volatile u32*) reset1);
+	//mdelay(10);
+
+	//Turn on USB clk
+	__raw_writel(clk_en_usb | __raw_readl((volatile u32*)clk_en1), (volatile u32*) clk_en1);
+	__raw_writel(~clk_en_usb & __raw_readl((volatile u32*)clk_en1), (volatile u32*) clk_en1);
+	mdelay(10);
+
+	debug("Realtek-usb: trigger bit4 CLK_EN_USB soft_reset1=%x, soft_reset2=%x, clock_enable1=%x\n",
+		(uint32_t)(__raw_readl((volatile u32*)reset1)),
+		(uint32_t)(__raw_readl((volatile u32*)reset2)),
+		(uint32_t)(__raw_readl((volatile u32*)clk_en1)));
+
+	__raw_writel(reset1_usb_flag | __raw_readl((volatile u32*)reset1), (volatile u32*) reset1);
+	__raw_writel(reset2_usb_flag | __raw_readl((volatile u32*)reset2), (volatile u32*) reset2);
+	mdelay(10);
+	debug("Realtek-usn: Turn on all RSTN_USB soft_reset1=%x, soft_reset2=%x, clock_enable1=%x\n",
+		(uint32_t)(__raw_readl((volatile u32*)reset1)),
+		(uint32_t)(__raw_readl((volatile u32*)reset2)),
+		(uint32_t)(__raw_readl((volatile u32*)clk_en1)));
+
+	__raw_writel(clk_en_usb | __raw_readl((volatile u32*)clk_en1), (volatile u32*) clk_en1);
+	mdelay(10);
+	debug("Realtek-usb: Turn on CLK_EN_USB soft_reset1=%x, soft_reset2=%x, clock_enable1=%x\n",
+		(uint32_t)(__raw_readl((volatile u32*)reset1)),
+		(uint32_t)(__raw_readl((volatile u32*)reset2)),
+		(uint32_t)(__raw_readl((volatile u32*)clk_en1)));
+
+	enabled = 1;
+	return 0;
+}
+
+static int usb_power_enable(void) {
+	int check, type_c_have_device = 0;
+
+	if (get_cpu_id() == RTK1294_CPU_ID) {
+		debug("Realtek-usb: Turn on 1294 usb port0 power\n");
+		setISOGPIO(1, 1);
+	} else {
+		if (get_rtd129x_cpu_revision() == RTD129x_CHIP_REVISION_A00) {
+			__raw_writel(0x00000200, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC1_1);
+			__raw_writel(0x00000300, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC2_1);
+		} else {
+			__raw_writel(0x00000400, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC1_1);
+			__raw_writel(0x00000500, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC2_1);
+		}
+		setISOGPIO(34, 0);
+
+		__raw_writel(0x00000001, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC1_0);
+		__raw_writel(0x00000001, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC2_0);
+
+		mdelay(1);
+
+		check = __raw_readl((volatile u32*)RTD1295_USB_TYPEC_STS);
+			debug("Realtek-usb: type_c cc status=0x%x\n", check);
+		if ((check & 0x7) != 0x0) {
+			debug("Realtek-usb: cc1 detect type_c have power\n");
+			goto out;
+		} else if ((check & 0x38) != 0x0) {
+			debug("Realtek-usb: cc2 detect type_c have power\n");
+			goto out;
+		}
+
+		if (get_rtd129x_cpu_revision() == RTD129x_CHIP_REVISION_A00) {
+			__raw_writel(0x00040200, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC1_1);
+			__raw_writel(0x00040300, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC2_1);
+			__raw_writel(0x02400071, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC1_0);
+			__raw_writel(0x00800071, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC2_0);
+		} else {
+			__raw_writel(0x080c0400, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC1_1);
+			__raw_writel(0x080c0500, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC2_1);
+			__raw_writel(0x02c00071, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC1_0);
+			__raw_writel(0x03000071, (volatile u32*) RTD1295_USB_TYPEC_CTRL_CC2_0);
+		}
+
+		/* set type c rd gpio */
+		setISOGPIO(34, 1);
+
+		mdelay(1);
+
+		check = __raw_readl((volatile u32*)RTD1295_USB_TYPEC_STS);
+		if ((check & 0x7) != 0x7) {
+			debug("Realtek-usb: cc1 detect\n");
+			type_c_have_device = 1;
+		} else if ((check & 0x38) != 0x38) {
+			debug("Realtek-usb: cc2 detect\n");
+			type_c_have_device = 1;
+		}
+
+		//Type C 5V
+		if (type_c_have_device) {
+			debug("Realtek-usb: Turn on port 0 power\n");
+			setISOGPIO(1, 1);
+		} else {
+			debug("Realtek-usb: Type C port no device, turn off port 0 power\n");
+			setISOGPIO(1, 0);
+		}
+	}
+
+out:
+	//Usb2 5V
+	// for 1294, 1295, 1296 QA board
+	setGPIO(19, 1);
+
+	if (get_cpu_id() == RTK1296_CPU_ID) {
+		debug("Realtek-usb: Turn on 1296 usb port1 and port2 power\n");
+		setISOGPIO(31, 1);
+		debug("Realtek-usb: Turn on 1296 usb port3 power\n");
+		setISOGPIO(32, 1);
+	}
+	return 0;
+
+}
+#endif
+
 /***************************************************************************
  * Init USB Device
  */
@@ -63,6 +240,9 @@ int usb_init(void)
 	int i, start_index = 0;
 	int controllers_initialized = 0;
 	int ret;
+#ifdef CONFIG_USB_RTK
+	int usb_max_controller_count = 0;
+#endif
 
 	dev_index = 0;
 	asynch_allowed = 1;
@@ -74,8 +254,16 @@ int usb_init(void)
 		usb_dev[i].devnum = -1;
 	}
 
+#ifdef CONFIG_USB_RTK
+	usb_max_controller_count = usb_host_controller_init();
+#endif
+
 	/* init low_level USB */
+#ifdef CONFIG_USB_RTK
+	for (i = 0; i < usb_max_controller_count; i++) {
+#else
 	for (i = 0; i < CONFIG_USB_MAX_CONTROLLER_COUNT; i++) {
+#endif
 		/* init low_level USB */
 		printf("USB%d:   ", i);
 		ret = usb_lowlevel_init(i, USB_INIT_HOST, &ctrl);
@@ -132,17 +320,24 @@ int usb_init(void)
  */
 int usb_stop(void)
 {
+#ifndef CONFIG_USB_RTK
 	int i;
+#endif
 
 	if (usb_started) {
 		asynch_allowed = 1;
 		usb_started = 0;
 		usb_hub_reset();
 
+#ifdef CONFIG_USB_RTK
+	if (usb_lowlevel_stop_all())
+		printf("failed to stop USB controller\n");
+#else
 		for (i = 0; i < CONFIG_USB_MAX_CONTROLLER_COUNT; i++) {
 			if (usb_lowlevel_stop(i))
 				printf("failed to stop USB controller %d\n", i);
 		}
+#endif
 	}
 
 	return 0;
@@ -217,7 +412,7 @@ int usb_control_msg(struct usb_device *dev, unsigned int pipe,
 			unsigned short value, unsigned short index,
 			void *data, unsigned short size, int timeout)
 {
-	ALLOC_CACHE_ALIGN_BUFFER(struct devrequest, setup_packet, 1);
+	ALLOC_CACHE_ALIGN_BUFFER(struct devrequest, setup_packet, 1024);
 	int err;
 
 	if ((timeout == 0) && (!asynch_allowed)) {
@@ -235,6 +430,7 @@ int usb_control_msg(struct usb_device *dev, unsigned int pipe,
 	      "value 0x%X index 0x%X length 0x%X\n",
 	      request, requesttype, value, index, size);
 	dev->status = USB_ST_NOT_PROC; /*not yet processed */
+	
 
 	err = submit_control_msg(dev, pipe, data, size, setup_packet);
 	if (err < 0)
@@ -264,6 +460,7 @@ int usb_control_msg(struct usb_device *dev, unsigned int pipe,
  * negative if Error.
  * synchronous behavior
  */
+ 
 int usb_bulk_msg(struct usb_device *dev, unsigned int pipe,
 			void *data, int len, int *actual_length, int timeout)
 {
@@ -396,11 +593,21 @@ static int usb_parse_config(struct usb_device *dev,
 	memcpy(&dev->config, head, USB_DT_CONFIG_SIZE);
 	dev->config.no_of_if = 0;
 
+	//printf("@@@ bLength %d, bDescriptorType %d, wTotalLength %d\n", dev->config.desc.bLength, dev->config.desc.bDescriptorType, dev->config.desc.wTotalLength);
+
 	index = dev->config.desc.bLength;
 	/* Ok the first entry must be a configuration entry,
 	 * now process the others */
 	head = (struct usb_descriptor_header *) &buffer[index];
 	while (index + 1 < dev->config.desc.wTotalLength && head->bLength) {
+			{
+				//unsigned char *ch = (unsigned char *)head;
+				//int i;
+
+				//for (i = 0; i < head->bLength; i++)
+				//	printf("%02X ", *ch++);
+				//printf("\n\n\n");
+			}
 		switch (head->bDescriptorType) {
 		case USB_DT_INTERFACE:
 			if (head->bLength != USB_DT_INTERFACE_SIZE) {
@@ -437,6 +644,7 @@ static int usb_parse_config(struct usb_device *dev,
 					if_desc->num_altsetting++;
 				}
 			}
+			//printf("index %d if %d#########\n", index, ifno);
 			break;
 		case USB_DT_ENDPOINT:
 			if (head->bLength != USB_DT_ENDPOINT_SIZE) {
@@ -473,7 +681,7 @@ static int usb_parse_config(struct usb_device *dev,
 					if_desc[ifno].\
 					ep_desc[epno].\
 					wMaxPacketSize);
-			debug("if %d, ep %d\n", ifno, epno);
+			//printf("index %d if %d, ep %d\n", index, ifno, epno);
 			break;
 		case USB_DT_SS_ENDPOINT_COMP:
 			if (head->bLength != USB_DT_SS_EP_COMP_SIZE) {
@@ -493,12 +701,13 @@ static int usb_parse_config(struct usb_device *dev,
 			if_desc = &dev->config.if_desc[ifno];
 			memcpy(&if_desc->ss_ep_comp_desc[epno], head,
 				USB_DT_SS_EP_COMP_SIZE);
+			//printf("index %d if %d, ep %d USB_DT_SS_ENDPOINT_COMP\n", index, ifno, epno);
 			break;
 		default:
 			if (head->bLength == 0)
 				return -EINVAL;
 
-			debug("unknown Description Type : %x\n",
+			printf("unknown Description Type : %x\n",
 			      head->bDescriptorType);
 
 #ifdef DEBUG
@@ -594,7 +803,7 @@ int usb_get_configuration_no(struct usb_device *dev,
 	}
 
 	result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno, buffer, length);
-	debug("get_conf_no %d Result %d, wLength %d\n", cfgno, result, length);
+	//printf("get_conf_no %d Result %d, wLength %d\n", cfgno, result, length);
 	config->wTotalLength = length; /* validated, with CPU byte order */
 
 	return result;
@@ -925,6 +1134,7 @@ int usb_legacy_port_reset(struct usb_device *hub, int portnr)
 			return err;
 		}
 	} else {
+		//hub->route =0; /* hcy added */
 		usb_reset_root_port();
 	}
 
@@ -1053,6 +1263,8 @@ static int usb_prepare_device(struct usb_device *dev, int addr, bool do_read,
 	err = usb_legacy_port_reset(parent, portnr);
 	if (err)
 		return err;
+	if (!parent)
+		dev->route =0; /* hcy added */
 
 	dev->devnum = addr;
 
@@ -1073,6 +1285,8 @@ int usb_select_config(struct usb_device *dev)
 {
 	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, tmpbuf, USB_BUFSIZ);
 	int err;
+	
+	memset(tmpbuf, 0, USB_BUFSIZ* sizeof(unsigned char));  /*Added by yh*/
 
 	err = get_descriptor_len(dev, USB_DT_DEVICE_SIZE, USB_DT_DEVICE_SIZE);
 	if (err)
@@ -1083,6 +1297,7 @@ int usb_select_config(struct usb_device *dev)
 	le16_to_cpus(&dev->descriptor.idVendor);
 	le16_to_cpus(&dev->descriptor.idProduct);
 	le16_to_cpus(&dev->descriptor.bcdDevice);
+	
 
 	/* only support for one config for now */
 	err = usb_get_configuration_no(dev, tmpbuf, 0);
@@ -1157,6 +1372,7 @@ int usb_new_device(struct usb_device *dev)
 {
 	bool do_read = true;
 	int err;
+	
 
 	/*
 	 * XHCI needs to issue a Address device command to setup
@@ -1165,7 +1381,10 @@ int usb_new_device(struct usb_device *dev)
 	 * of that is done for XHCI unlike EHCI.
 	 */
 #ifdef CONFIG_USB_XHCI
-	do_read = false;
+	int ctrl_type = ((struct controller *) dev->controller)->ctrl_type;
+	if (ctrl_type == CTRL_TYPE_XHCI) {
+		do_read = false;
+	}
 #endif
 	err = usb_setup_device(dev, do_read, dev->parent, dev->portnr);
 	if (err)
diff --git a/common/usb_hub.c b/common/usb_hub.c
index be01f4f257..98fdf8c1ec 100644
--- a/common/usb_hub.c
+++ b/common/usb_hub.c
@@ -51,11 +51,29 @@ __weak void usb_hub_reset_devices(int port)
 	return;
 }
 
+#define USB_HUB_PR_SS 3 //hcy  added
 static int usb_get_hub_descriptor(struct usb_device *dev, void *data, int size)
 {
+	/* hcy added below */
+	unsigned short dtype;
+	int is_xhci_roothub = 0;
+	int ctrl_type = ((struct controller *) dev->controller)->ctrl_type;
+	if (ctrl_type == CTRL_TYPE_XHCI) {
+		is_xhci_roothub = (dev->parent == NULL);
+		debug("is_xhci_roothub=%d, dev->parent=%p\n",
+				is_xhci_roothub, dev->parent);
+	}
+	if (dev->descriptor.bDeviceProtocol == USB_HUB_PR_SS && is_xhci_roothub != 1)
+		dtype = USB_DT_SS_HUB;
+	else
+		dtype = USB_DT_HUB;
+
+	/* hcy added above */
+	
+	
 	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 		USB_REQ_GET_DESCRIPTOR, USB_DIR_IN | USB_RT_HUB,
-		USB_DT_HUB << 8, 0, data, size, USB_CNTL_TIMEOUT);
+		dtype /*USB_DT_HUB*/ << 8, 0, data, size, USB_CNTL_TIMEOUT);
 }
 
 static int usb_clear_port_feature(struct usb_device *dev, int port, int feature)
@@ -277,6 +295,10 @@ int usb_hub_port_connect_change(struct usb_device *dev, int port)
 	}
 
 	mdelay(200);
+	/* hcy added below */
+
+	usb_clear_port_feature(dev, port + 1, USB_PORT_FEAT_C_CONNECTION);
+	/* hcy added above */
 
 	switch (portstatus & USB_PORT_STAT_SPEED_MASK) {
 	case USB_PORT_STAT_SUPER_SPEED:
@@ -286,7 +308,22 @@ int usb_hub_port_connect_change(struct usb_device *dev, int port)
 		speed = USB_SPEED_HIGH;
 		break;
 	case USB_PORT_STAT_LOW_SPEED:
-		speed = USB_SPEED_LOW;
+		if (dev->descriptor.bDeviceProtocol == USB_HUB_PR_SS)
+		{		 //hcy test added
+			speed = USB_SPEED_SUPER;
+			/* hcy added below */
+			usb_clear_port_feature(dev, port + 1, USB_SS_PORT_FEAT_C_BH_RESET );
+			usb_clear_port_feature(dev, port + 1, USB_SS_PORT_FEAT_C_LINK_STATE);
+			/* hcy added above */
+
+			debug("USB_SPEED_SUPER\n");//hcy added
+
+		}
+		else
+  			{
+			speed = USB_SPEED_LOW;
+			debug("USB_SPEED_LOW\n");//hcy added
+		}
 		break;
 	default:
 		speed = USB_SPEED_FULL;
@@ -310,6 +347,19 @@ int usb_hub_port_connect_change(struct usb_device *dev, int port)
 	usb->speed = speed;
 	usb->parent = dev;
 	usb->portnr = port + 1;
+	
+	/* hcy adde below */
+	usb->level = dev->level + 1;
+	
+	if (dev->level != 0) {
+		if (port < 15) {
+			usb->route = dev->route + ((port+1) << (( dev->level-1)*4));   
+		} else {
+			usb->route = dev->route + (15 << (( dev->level-1)*4));
+		}
+	}
+	/* hcy added above */
+	
 	/* Run it through the hoops (find a driver, etc) */
 	ret = usb_new_device(usb);
 	if (ret < 0) {
@@ -338,6 +388,9 @@ static int usb_hub_configure(struct usb_device *dev)
 	__maybe_unused struct usb_hub_status *hubsts;
 	int ret;
 
+
+	dev->route = 0;   /* hcy added */
+
 	/* "allocate" Hub device */
 	hub = usb_hub_allocate();
 	if (hub == NULL)
@@ -450,6 +503,13 @@ static int usb_hub_configure(struct usb_device *dev)
 	debug("%sover-current condition exists\n",
 	      (le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_OVERCURRENT) ? \
 	      "" : "no ");
+		  
+	/* HUB_SET_DEPTH hcy added */
+	if (dev->speed == USB_SPEED_SUPER)  
+		usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+        	                      HUB_SET_DEPTH , USB_RT_HUB, 0,    
+                	                0, NULL, 0, USB_CNTL_TIMEOUT);	  
+		  
 	usb_hub_power_on(hub);
 
 	/*
diff --git a/common/usb_storage.c b/common/usb_storage.c
index cc9b3e37a1..1c3f910974 100644
--- a/common/usb_storage.c
+++ b/common/usb_storage.c
@@ -49,6 +49,8 @@
 #undef BBB_COMDAT_TRACE
 #undef BBB_XPORT_TRACE
 
+#include <../drivers/usb/host/xhci.h>
+
 #include <scsi.h>
 /* direction table -- this indicates the direction of the data
  * transfer for each command code -- a 1 indicates input
@@ -67,7 +69,7 @@ static __u32 CBWTag;
 #define USB_MAX_STOR_DEV 5
 static int usb_max_devs; /* number of highest available usb device */
 
-static block_dev_desc_t usb_dev_desc[USB_MAX_STOR_DEV];
+block_dev_desc_t usb_dev_desc[USB_MAX_STOR_DEV];
 
 struct us_data;
 typedef int (*trans_cmnd)(ccb *cb, struct us_data *data);
@@ -103,11 +105,15 @@ struct us_data {
  * enough free heap space left, but the SCSI READ(10) and WRITE(10) commands are
  * limited to 65535 blocks.
  */
-#define USB_MAX_XFER_BLK	65535
+//#define USB_MAX_XFER_BLK	65535
 #else
-#define USB_MAX_XFER_BLK	20
+//#define USB_MAX_XFER_BLK	20
 #endif
 
+#define USB_MAX_XFER_BLK_EHCI	65535
+#define USB_MAX_XFER_BLK_XHCI	128*20
+#define USB_MAX_XFER_BLK	20
+
 static struct us_data usb_stor[USB_MAX_STOR_DEV];
 
 #define USB_STOR_TRANSPORT_GOOD	   0
@@ -469,7 +475,8 @@ static int usb_stor_BBB_comdat(ccb *srb, struct us_data *us)
 	int actlen;
 	int dir_in;
 	unsigned int pipe;
-	ALLOC_CACHE_ALIGN_BUFFER(struct umass_bbb_cbw, cbw, 1);
+	ALLOC_CACHE_ALIGN_BUFFER(struct umass_bbb_cbw, cbw, 1024);
+	
 
 	dir_in = US_DIRECTION(srb->cmd[0]);
 
@@ -500,8 +507,10 @@ static int usb_stor_BBB_comdat(ccb *srb, struct us_data *us)
 	cbw->bCDBLength = srb->cmdlen;
 	/* copy the command data into the CBW command data buffer */
 	/* DST SRC LEN!!! */
-
+	memset(cbw->CBWCDB, 0, CBWCDBLENGTH);
 	memcpy(cbw->CBWCDB, srb->cmd, srb->cmdlen);
+	
+	
 	result = usb_bulk_msg(us->pusb_dev, pipe, cbw, UMASS_BBB_CBW_SIZE,
 			      &actlen, USB_CNTL_TIMEOUT * 5);
 	if (result < 0)
@@ -645,7 +654,7 @@ static int usb_stor_BBB_transport(ccb *srb, struct us_data *us)
 	int dir_in;
 	int actlen, data_actlen;
 	unsigned int pipe, pipein, pipeout;
-	ALLOC_CACHE_ALIGN_BUFFER(struct umass_bbb_csw, csw, 1);
+	ALLOC_CACHE_ALIGN_BUFFER(struct umass_bbb_csw, csw, 1024);
 #ifdef BBB_XPORT_TRACE
 	unsigned char *ptr;
 	int index;
@@ -666,6 +675,22 @@ static int usb_stor_BBB_transport(ccb *srb, struct us_data *us)
 		mdelay(5);
 	pipein = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
 	pipeout = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
+#ifdef BBB_XPORT_TRACE
+#if 0 // add by cfyeh
+	for (index = 0; index < srb->cmdlen; index++)
+		printf("cmd[%d] %#x ", index, srb->cmd[index]);
+	printf("\n");
+#else
+	for (index = 0; index < srb->cmdlen; index++) {
+		if(index % 16 == 0)
+			printf("0x%.8x : ", index);
+		printf("%.2x ", srb->cmd[index]);
+		if(index % 16 == 15)
+			printf("\n");
+	}
+	printf("\n");
+#endif
+#endif
 	/* DATA phase + error handling */
 	data_actlen = 0;
 	/* no data, go immediately to the STATUS phase */
@@ -683,8 +708,13 @@ static int usb_stor_BBB_transport(ccb *srb, struct us_data *us)
 	if ((result < 0) && (us->pusb_dev->status & USB_ST_STALLED)) {
 		debug("DATA:stall\n");
 		/* clear the STALL on the endpoint */
+#if 0 // add by cfyeh
 		result = usb_stor_BBB_clear_endpt_stall(us,
 					dir_in ? us->ep_in : us->ep_out);
+#else
+		result = usb_stor_BBB_clear_endpt_stall(us,
+					dir_in ? (us->ep_in | USB_ENDPOINT_DIR_MASK) : us->ep_out);
+#endif
 		if (result >= 0)
 			/* continue on to STATUS phase */
 			goto st;
@@ -696,15 +726,29 @@ static int usb_stor_BBB_transport(ccb *srb, struct us_data *us)
 		return USB_STOR_TRANSPORT_FAILED;
 	}
 #ifdef BBB_XPORT_TRACE
+#if 0
+#if 0 // add by cfyeh
 	for (index = 0; index < data_actlen; index++)
 		printf("pdata[%d] %#x ", index, srb->pdata[index]);
 	printf("\n");
+#else
+	for (index = 0; index < data_actlen; index++) {
+		if(index % 16 == 0)
+			printf("0x%.8x : ", index);
+		printf("%.2x ", srb->pdata[index]);
+		if(index % 16 == 15)
+			printf("\n");
+	}
+	printf("\n");
+#endif
+#endif
 #endif
 	/* STATUS phase + error handling */
 st:
 	retry = 0;
 again:
 	debug("STATUS phase\n");
+	memset(csw, 0, UMASS_BBB_CSW_SIZE); // add by cfyeh
 	result = usb_bulk_msg(us->pusb_dev, pipein, csw, UMASS_BBB_CSW_SIZE,
 				&actlen, USB_CNTL_TIMEOUT*5);
 
@@ -713,7 +757,11 @@ again:
 	    (us->pusb_dev->status & USB_ST_STALLED)) {
 		debug("STATUS:stall\n");
 		/* clear the STALL on the endpoint */
+#if 0 // add by cfyeh
 		result = usb_stor_BBB_clear_endpt_stall(us, us->ep_in);
+#else
+		result = usb_stor_BBB_clear_endpt_stall(us, us->ep_in | USB_ENDPOINT_DIR_MASK);
+#endif
 		if (result >= 0 && (retry++ < 1))
 			/* do a retry */
 			goto again;
@@ -725,10 +773,22 @@ again:
 		return USB_STOR_TRANSPORT_FAILED;
 	}
 #ifdef BBB_XPORT_TRACE
+#if 0 // add by cfyeh
 	ptr = (unsigned char *)csw;
 	for (index = 0; index < UMASS_BBB_CSW_SIZE; index++)
 		printf("ptr[%d] %#x ", index, ptr[index]);
 	printf("\n");
+#else
+	ptr = (unsigned char *)csw;
+	for (index = 0; index < UMASS_BBB_CSW_SIZE; index++) {
+		if(index % 16 == 0)
+			printf("0x%.8x : ", index);
+		printf("%.2x ", ptr[index]);
+		if(index % 16 == 15)
+			printf("\n");
+	}
+	printf("\n");
+#endif
 #endif
 	/* misuse pipe to get the residue */
 	pipe = le32_to_cpu(csw->dCSWDataResidue);
@@ -971,6 +1031,7 @@ static int usb_read_capacity(ccb *srb, struct us_data *ss)
 static int usb_read_10(ccb *srb, struct us_data *ss, unsigned long start,
 		       unsigned short blocks)
 {
+	
 	memset(&srb->cmd[0], 0, 12);
 	srb->cmd[0] = SCSI_READ10;
 	srb->cmd[1] = srb->lun << 5;
@@ -980,7 +1041,12 @@ static int usb_read_10(ccb *srb, struct us_data *ss, unsigned long start,
 	srb->cmd[5] = ((unsigned char) (start)) & 0xff;
 	srb->cmd[7] = ((unsigned char) (blocks >> 8)) & 0xff;
 	srb->cmd[8] = (unsigned char) blocks & 0xff;
+#if 0 // add by cfyeh
 	srb->cmdlen = 12;
+#else
+	srb->cmdlen = 10;
+#endif
+
 	debug("read10: start %lx blocks %x\n", start, blocks);
 	return ss->transport(srb, ss);
 }
@@ -997,7 +1063,11 @@ static int usb_write_10(ccb *srb, struct us_data *ss, unsigned long start,
 	srb->cmd[5] = ((unsigned char) (start)) & 0xff;
 	srb->cmd[7] = ((unsigned char) (blocks >> 8)) & 0xff;
 	srb->cmd[8] = (unsigned char) blocks & 0xff;
+#if 0 // add by cfyeh
 	srb->cmdlen = 12;
+#else
+	srb->cmdlen = 10;
+#endif
 	debug("write10: start %lx blocks %x\n", start, blocks);
 	return ss->transport(srb, ss);
 }
@@ -1034,42 +1104,56 @@ unsigned long usb_stor_read(int device, lbaint_t blknr,
 	unsigned short smallblks;
 	struct usb_device *dev;
 	struct us_data *ss;
-	int retry;
+	int retry, i;
 	ccb *srb = &usb_ccb;
+	int ctrl_type;
+	int usb_max_xfer_blk;
 
 	if (blkcnt == 0)
 		return 0;
 
 	device &= 0xff;
 	/* Setup  device */
-	debug("\nusb_read: dev %d\n", device);
-	dev = usb_dev_desc[device].priv;
-	if (!dev) {
-		debug("%s: No device\n", __func__);
-		return 0;
-	}
+	debug("\nusb_read: dev %d \n", device);
+	dev = NULL;
+	for (i = 0; i < USB_MAX_DEVICE; i++) {
+		dev = usb_get_dev_index(i);
+		if (dev == NULL)
+			return 0;
+		if (dev->devnum == usb_dev_desc[device].target)
+			break;
+	}	
 	ss = (struct us_data *)dev->privptr;
+	ctrl_type = ((struct controller*) dev->controller)->ctrl_type;		
+	if (ctrl_type == CTRL_TYPE_EHCI)
+		usb_max_xfer_blk = USB_MAX_XFER_BLK_EHCI;
+	else if (ctrl_type == CTRL_TYPE_XHCI)
+		usb_max_xfer_blk = USB_MAX_XFER_BLK_XHCI;
+	else
+		usb_max_xfer_blk = USB_MAX_XFER_BLK;
 
 	usb_disable_asynch(1); /* asynch transfer not allowed */
 	srb->lun = usb_dev_desc[device].lun;
 	buf_addr = (uintptr_t)buffer;
 	start = blknr;
 	blks = blkcnt;
+	
 
 	debug("\nusb_read: dev %d startblk " LBAF ", blccnt " LBAF
-	      " buffer %" PRIxPTR "\n", device, start, blks, buf_addr);
+	      " buffer %lx (usb_max_xfer_blk=%d)\n", device, start, blks, buf_addr, usb_max_xfer_blk);
 
 	do {
 		/* XXX need some comment here */
 		retry = 2;
 		srb->pdata = (unsigned char *)buf_addr;
-		if (blks > USB_MAX_XFER_BLK)
-			smallblks = USB_MAX_XFER_BLK;
+		if (blks > usb_max_xfer_blk/*USB_MAX_XFER_BLK*/)
+			smallblks = usb_max_xfer_blk/*USB_MAX_XFER_BLK*/;
 		else
 			smallblks = (unsigned short) blks;
 retry_it:
-		if (smallblks == USB_MAX_XFER_BLK)
+		if (smallblks == usb_max_xfer_blk/*USB_MAX_XFER_BLK*/)
 			usb_show_progress();
+		
 		srb->datalen = usb_dev_desc[device].blksz * smallblks;
 		srb->pdata = (unsigned char *)buf_addr;
 		if (usb_read_10(srb, ss, start, smallblks)) {
@@ -1080,18 +1164,19 @@ retry_it:
 			blkcnt -= blks;
 			break;
 		}
+		
 		start += smallblks;
 		blks -= smallblks;
 		buf_addr += srb->datalen;
 	} while (blks != 0);
-	ss->flags &= ~USB_READY;
+	ss->flags &= ~USB_READY;	
 
 	debug("usb_read: end startblk " LBAF
 	      ", blccnt %x buffer %" PRIxPTR "\n",
 	      start, smallblks, buf_addr);
 
 	usb_disable_asynch(0); /* asynch transfer allowed */
-	if (blkcnt >= USB_MAX_XFER_BLK)
+	if (blkcnt >= usb_max_xfer_blk/*USB_MAX_XFER_BLK*/)
 		debug("\n");
 	return blkcnt;
 }
@@ -1106,6 +1191,7 @@ unsigned long usb_stor_write(int device, lbaint_t blknr,
 	struct us_data *ss;
 	int retry;
 	ccb *srb = &usb_ccb;
+	int ctrl_type, usb_max_xfer_blk;
 
 	if (blkcnt == 0)
 		return 0;
@@ -1117,6 +1203,14 @@ unsigned long usb_stor_write(int device, lbaint_t blknr,
 	if (!dev)
 		return 0;
 	ss = (struct us_data *)dev->privptr;
+	
+	ctrl_type = ((struct controller*) dev->controller)->ctrl_type;
+	if (ctrl_type == CTRL_TYPE_EHCI)
+		usb_max_xfer_blk = USB_MAX_XFER_BLK_EHCI;
+	else if (ctrl_type == CTRL_TYPE_XHCI)
+		usb_max_xfer_blk = USB_MAX_XFER_BLK_XHCI;
+	else
+		usb_max_xfer_blk = USB_MAX_XFER_BLK;
 
 	usb_disable_asynch(1); /* asynch transfer not allowed */
 
@@ -1126,7 +1220,7 @@ unsigned long usb_stor_write(int device, lbaint_t blknr,
 	blks = blkcnt;
 
 	debug("\nusb_write: dev %d startblk " LBAF ", blccnt " LBAF
-	      " buffer %" PRIxPTR "\n", device, start, blks, buf_addr);
+	      " buffer %lx (usb_max_xfer_blk=%d)\n", device, start, blks, buf_addr, usb_max_xfer_blk);
 
 	do {
 		/* If write fails retry for max retry count else
@@ -1134,12 +1228,12 @@ unsigned long usb_stor_write(int device, lbaint_t blknr,
 		 */
 		retry = 2;
 		srb->pdata = (unsigned char *)buf_addr;
-		if (blks > USB_MAX_XFER_BLK)
-			smallblks = USB_MAX_XFER_BLK;
+		if (blks > usb_max_xfer_blk/*USB_MAX_XFER_BLK*/)
+			smallblks = usb_max_xfer_blk/*USB_MAX_XFER_BLK*/;
 		else
 			smallblks = (unsigned short) blks;
 retry_it:
-		if (smallblks == USB_MAX_XFER_BLK)
+		if (smallblks == usb_max_xfer_blk/*USB_MAX_XFER_BLK*/)
 			usb_show_progress();
 		srb->datalen = usb_dev_desc[device].blksz * smallblks;
 		srb->pdata = (unsigned char *)buf_addr;
@@ -1161,7 +1255,7 @@ retry_it:
 	      PRIxPTR "\n", start, smallblks, buf_addr);
 
 	usb_disable_asynch(0); /* asynch transfer allowed */
-	if (blkcnt >= USB_MAX_XFER_BLK)
+	if (blkcnt >= usb_max_xfer_blk/*USB_MAX_XFER_BLK*/)
 		debug("\n");
 	return blkcnt;
 
@@ -1324,7 +1418,7 @@ int usb_stor_get_info(struct usb_device *dev, struct us_data *ss,
 
 	dev_desc->target = dev->devnum;
 	pccb->lun = dev_desc->lun;
-	debug(" address %d\n", dev_desc->target);
+	printf(" address %d\n", dev_desc->target);
 
 	if (usb_inquiry(pccb, ss)) {
 		debug("%s: usb_inquiry() failed\n", __func__);
@@ -1389,7 +1483,7 @@ int usb_stor_get_info(struct usb_device *dev, struct us_data *ss,
 	capacity = be32_to_cpu(cap[0]) + 1;
 	blksz = be32_to_cpu(cap[1]);
 
-	debug("Capacity = 0x%08x, blocksz = 0x%08x\n", capacity, blksz);
+	debug("dev_desc %p, Capacity = 0x%08x, blocksz = 0x%08x\n", dev_desc, capacity, blksz);
 	dev_desc->lba = capacity;
 	dev_desc->blksz = blksz;
 	dev_desc->log2blksz = LOG2(dev_desc->blksz);
diff --git a/disk/part.c b/disk/part.c
index 43485c9148..358521af03 100644
--- a/disk/part.c
+++ b/disk/part.c
@@ -30,7 +30,10 @@ static const struct block_drvr block_drvr[] = {
 	{ .name = "ide", .get_dev = ide_get_dev, },
 #endif
 #if defined(CONFIG_CMD_SATA)
-	{.name = "sata", .get_dev = sata_get_dev, },
+	{ .name = "sata", .get_dev = sata_get_dev, },
+#endif
+#if defined(CONFIG_CMD_SD)
+	{ .name = "sd", .get_dev = sd_get_dev, },
 #endif
 #if defined(CONFIG_CMD_SCSI)
 	{ .name = "scsi", .get_dev = scsi_get_dev, },
@@ -38,7 +41,7 @@ static const struct block_drvr block_drvr[] = {
 #if defined(CONFIG_CMD_USB) && defined(CONFIG_USB_STORAGE)
 	{ .name = "usb", .get_dev = usb_stor_get_dev, },
 #endif
-#if defined(CONFIG_MMC)
+#if defined(CONFIG_CMD_MMC)
 	{
 		.name = "mmc",
 		.get_dev = mmc_get_dev,
@@ -84,15 +87,20 @@ static block_dev_desc_t *get_dev_hwpart(const char *ifname, int dev, int hwpart)
 #endif
 		if (strncmp(ifname, name, strlen(name)) == 0) {
 			block_dev_desc_t *dev_desc = reloc_get_dev(dev);
-			if (!dev_desc)
+			if (!dev_desc) {
 				return NULL;
-			if (hwpart == 0 && !select_hwpart)
+			}
+			if (hwpart == 0 && !select_hwpart) {
 				return dev_desc;
-			if (!select_hwpart)
+			}
+			if (!select_hwpart) {
 				return NULL;
+			}
 			ret = select_hwpart(dev_desc->dev, hwpart);
-			if (ret < 0)
+			if (ret < 0) {
+
 				return NULL;
+			}
 			return dev_desc;
 		}
 		drvr++;
@@ -306,6 +314,9 @@ static void print_part_header(const char *type, block_dev_desc_t *dev_desc)
 	case IF_TYPE_SATA:
 		puts ("SATA");
 		break;
+	case IF_TYPE_SD:
+		puts ("SD");
+		break;
 	case IF_TYPE_SCSI:
 		puts ("SCSI");
 		break;
@@ -596,7 +607,12 @@ int get_device_and_partition(const char *ifname, const char *dev_part_str,
 		if ((part > 0) || (!allow_whole_dev)) {
 			printf("** No partition table - %s %s **\n", ifname,
 			       dev_str);
-			goto cleanup;
+			printf("*No partition table, try part 0 again!\n*");
+			if ( part != 1){
+				printf("** Partition %d not valid on device %d **\n",
+						part, (*dev_desc)->dev);
+				goto cleanup;
+			}
 		}
 
 		(*dev_desc)->log2blksz = LOG2((*dev_desc)->blksz);
diff --git a/drivers/Kconfig b/drivers/Kconfig
index c7e526cc8a..14edb87910 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -54,6 +54,8 @@ source "drivers/crypto/Kconfig"
 
 source "drivers/thermal/Kconfig"
 
+source "drivers/pcb_mgr/Kconfig"
+
 endmenu
 
 config PHYS_TO_BUS
diff --git a/drivers/Makefile b/drivers/Makefile
index 405b64b268..38a04c4e54 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -24,3 +24,5 @@ obj-y += input/
 # SOC specific infrastructure drivers.
 obj-y += soc/
 obj-y += thermal/
+obj-y += logo_disp/
+
diff --git a/drivers/block/Makefile b/drivers/block/Makefile
index 8697da4262..9bfc450297 100644
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -21,3 +21,4 @@ obj-$(CONFIG_IDE_SIL680) += sil680.o
 obj-$(CONFIG_SANDBOX) += sandbox.o
 obj-$(CONFIG_SCSI_SYM53C8XX) += sym53c8xx.o
 obj-$(CONFIG_SYSTEMACE) += systemace.o
+obj-$(CONFIG_RTK_AHSATA) += rtk_ahsata.o
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 586485055d..8495b8b7a0 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -46,3 +46,11 @@ obj-$(CONFIG_LPC32XX_GPIO)	+= lpc32xx_gpio.o
 obj-$(CONFIG_STM32_GPIO)	+= stm32_gpio.o
 obj-$(CONFIG_ZYNQ_GPIO)		+= zynq_gpio.o
 obj-$(CONFIG_VYBRID_GPIO)	+= vybrid_gpio.o
+
+ifdef CONFIG_RTD1295
+obj-y += rt_gpio.o
+endif
+
+ifdef CONFIG_RTD1395
+obj-y += rt_gpio_139x.o
+endif
\ No newline at end of file
diff --git a/drivers/i2c/Makefile b/drivers/i2c/Makefile
index d9e912f786..4bbc4de2bc 100644
--- a/drivers/i2c/Makefile
+++ b/drivers/i2c/Makefile
@@ -37,3 +37,8 @@ obj-$(CONFIG_SYS_I2C_TEGRA) += tegra_i2c.o
 obj-$(CONFIG_SYS_I2C_UNIPHIER) += i2c-uniphier.o
 obj-$(CONFIG_SYS_I2C_UNIPHIER_F) += i2c-uniphier-f.o
 obj-$(CONFIG_SYS_I2C_ZYNQ) += zynq_i2c.o
+
+obj-y += rtk_i2c-pow.o
+obj-y += rtk_i2c-lib.o
+obj-y += rtk_i2c.o
+
diff --git a/drivers/mmc/Kconfig b/drivers/mmc/Kconfig
index 7ba85a2b62..3dc0f09ae3 100644
--- a/drivers/mmc/Kconfig
+++ b/drivers/mmc/Kconfig
@@ -5,5 +5,15 @@ config SH_SDHI
 	depends on RMOBILE
 	help
 	  Support for the on-chip SDHI host controller on SuperH/Renesas ARM SoCs platform
+	  
+config RTK_MMC_DRIVER
+	bool "open and build the RTK_MMC"
+	help
+	  Support for the build the RTK EMMC
+
+config RTK_SD_DRIVER
+	bool "open and build the RTK_SD"
+	help
+	  Support for the build the RTK SD
 
 endmenu
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index ed73687735..18635eb83e 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -36,10 +36,19 @@ obj-$(CONFIG_SOCFPGA_DWMMC) += socfpga_dw_mmc.o
 obj-$(CONFIG_SPEAR_SDHCI) += spear_sdhci.o
 obj-$(CONFIG_TEGRA_MMC) += tegra_mmc.o
 obj-$(CONFIG_ZYNQ_SDHCI) += zynq_sdhci.o
+ifdef CONFIG_RTD1295
+obj-$(CONFIG_RTK_MMC_DRIVER) += mmc.o rtkemmc.o rtkemmc_generic.o
+endif
+ifdef CONFIG_RTD1395
+obj-$(CONFIG_RTK_MMC_DRIVER) += mmc.o rtkemmc_rtd1395.o rtkemmc_generic.o
+endif
+obj-$(CONFIG_RTK_SD_DRIVER) += mmc.o sd.o rtksdmmc.o
+
+
 
 ifdef CONFIG_SPL_BUILD
 obj-$(CONFIG_SPL_MMC_BOOT) += fsl_esdhc_spl.o
-else
-obj-$(CONFIG_GENERIC_MMC) += mmc_write.o
+#else
+#obj-$(CONFIG_GENERIC_MMC) += mmc_write.o
 endif
 
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index 79e6feeb13..79d312c745 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -16,10 +16,15 @@
 #include <malloc.h>
 #include <linux/list.h>
 #include <div64.h>
-#include "mmc_private.h"
+#include <asm/arch/rtkemmc.h>
 
-static struct list_head mmc_devices;
-static int cur_dev_num = -1;
+#define SUPPORT_HS200
+#define SUPPORT_WRITE_PROT
+//#define MMC_DEBUG
+struct list_head mmc_devices;
+int cur_dev_num = -1;
+void mmc_set_mode_select(struct mmc *mmc, uint mode);
+int mmc_select_hs200(struct mmc *mmc,char* ext_csd);
 
 __weak int board_mmc_getwp(struct mmc *mmc)
 {
@@ -33,9 +38,11 @@ int mmc_getwp(struct mmc *mmc)
 	wp = board_mmc_getwp(mmc);
 
 	if (wp < 0) {
+#if 0
 		if (mmc->cfg->ops->getwp)
 			wp = mmc->cfg->ops->getwp(mmc);
 		else
+#endif
 			wp = 0;
 	}
 
@@ -57,7 +64,8 @@ int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
 
 	printf("CMD_SEND:%d\n", cmd->cmdidx);
 	printf("\t\tARG\t\t\t 0x%08X\n", cmd->cmdarg);
-	ret = mmc->cfg->ops->send_cmd(mmc, cmd, data);
+	//ret = mmc->cfg->ops->send_cmd(mmc, cmd, data);
+	ret = mmc->request(mmc, cmd, data);
 	switch (cmd->resp_type) {
 		case MMC_RSP_NONE:
 			printf("\t\tMMC_RSP_NONE\n");
@@ -100,7 +108,8 @@ int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
 			break;
 	}
 #else
-	ret = mmc->cfg->ops->send_cmd(mmc, cmd, data);
+	//ret = mmc->cfg->ops->send_cmd(mmc, cmd, data);
+	ret = mmc->request(mmc, cmd, data);
 #endif
 	return ret;
 }
@@ -159,6 +168,7 @@ int mmc_send_status(struct mmc *mmc, int timeout)
 
 int mmc_set_blocklen(struct mmc *mmc, int len)
 {
+	return 0;	//in realtek platform, we do not need this command
 	struct mmc_cmd cmd;
 
 	if (mmc->ddr_mode)
@@ -201,11 +211,12 @@ static int mmc_read_blocks(struct mmc *mmc, void *dst, lbaint_t start,
 	else
 		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
 
-	if (mmc->high_capacity)
+/*	if (mmc->high_capacity)
 		cmd.cmdarg = start;
 	else
 		cmd.cmdarg = start * mmc->read_bl_len;
-
+*/
+	cmd.cmdarg = start;
 	cmd.resp_type = MMC_RSP_R1;
 
 	data.dest = dst;
@@ -213,9 +224,11 @@ static int mmc_read_blocks(struct mmc *mmc, void *dst, lbaint_t start,
 	data.blocksize = mmc->read_bl_len;
 	data.flags = MMC_DATA_READ;
 
-	if (mmc_send_cmd(mmc, &cmd, &data))
+	if (mmc_send_cmd(mmc, &cmd, &data) != blkcnt) {
+		printf("mmc read fail...\n");
 		return 0;
-
+	}
+#ifndef CONFIG_SYS_RTK_EMMC_FLASH
 	if (blkcnt > 1) {
 		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
 		cmd.cmdarg = 0;
@@ -227,7 +240,7 @@ static int mmc_read_blocks(struct mmc *mmc, void *dst, lbaint_t start,
 			return 0;
 		}
 	}
-
+#endif
 	return blkcnt;
 }
 
@@ -254,8 +267,10 @@ static ulong mmc_bread(int dev_num, lbaint_t start, lbaint_t blkcnt, void *dst)
 		return 0;
 
 	do {
-		cur = (blocks_todo > mmc->cfg->b_max) ?
-			mmc->cfg->b_max : blocks_todo;
+		//cur = (blocks_todo > mmc->cfg->b_max) ?
+		//	mmc->cfg->b_max : blocks_todo;
+		cur = (blocks_todo > mmc->b_max) ?
+			mmc->b_max : blocks_todo;
 		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
 			return 0;
 		blocks_todo -= cur;
@@ -287,73 +302,178 @@ static int mmc_go_idle(struct mmc *mmc)
 	return 0;
 }
 
-static int sd_send_op_cond(struct mmc *mmc)
+//*********************************************************************************
+static ulong
+mmc_write_blocks(struct mmc *mmc, ulong start, lbaint_t blkcnt, const void*src)
 {
-	int timeout = 1000;
-	int err;
 	struct mmc_cmd cmd;
+	struct mmc_data data;
+	int timeout = 1000;
+//	int err=0;
+	MY_CLR_ALIGN_BUFFER();
+//	MY_ALLOC_CACHE_ALIGN_BUFFER(char, ext_csd, CSD_ARRAY_SIZE);
+//	printf("Unused variable ext_csd = %s\n",ext_csd);
 
-	while (1) {
-		cmd.cmdidx = MMC_CMD_APP_CMD;
-		cmd.resp_type = MMC_RSP_R1;
-		cmd.cmdarg = 0;
+	if ((start + blkcnt) > mmc->block_dev.lba) {
+		printf("MMC: block number 0x%lx exceeds max(0x%lx)\n",
+			start + blkcnt, mmc->block_dev.lba);
+		return 0;
+	}
 
-		err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (blkcnt > 1)
+		cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
+	else
+		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;
 
-		if (err)
-			return err;
+/*	if (mmc->high_capacity)
+		cmd.cmdarg = start;
+	else
+		cmd.cmdarg = start * mmc->write_bl_len;
+*/
+	cmd.cmdarg = start;
+	cmd.resp_type = MMC_RSP_R1;
+	data.src = src;
+	data.blocks = blkcnt;
+	data.blocksize = mmc->write_bl_len;
+	data.flags = MMC_DATA_WRITE;
 
-		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
-		cmd.resp_type = MMC_RSP_R3;
+	if (mmc_send_cmd(mmc, &cmd, &data) != blkcnt) {
+		printf("mmc write failed\n");
+		return 0;
+	}
+#ifndef CONFIG_SYS_RTK_EMMC_FLASH	//in realtek eMMC IP, hardware will send the stop command
+	/* SPI multiblock writes terminate using a special
+	 * token, not a STOP_TRANSMISSION request.
+	 */
+	#ifndef CONFIG_SYS_RTK_EMMC_FLASH
+	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
+		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
+		cmd.cmdarg = 0;
+		cmd.resp_type = MMC_RSP_R1b;
+		if (mmc_send_cmd(mmc, &cmd, NULL)) {
+			printf("mmc fail to send stop cmd\n");
+			return 0;
+		}
+	}
+	#endif
+#endif
+	/* Waiting for the ready status */
+	if (mmc_send_status(mmc, timeout))
+		return 0;
 
-		/*
-		 * Most cards do not answer if some reserved bits
-		 * in the ocr are set. However, Some controller
-		 * can set bit 7 (reserved for low voltages), but
-		 * how to manage low voltages SD card is not yet
-		 * specified.
-		 */
-		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
-			(mmc->cfg->voltages & 0xff8000);
+	return blkcnt;
+}
 
-		if (mmc->version == SD_VERSION_2)
-			cmd.cmdarg |= OCR_HCS;
+static ulong
+mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
+{
+	lbaint_t cur, blocks_todo = blkcnt;
 
-		err = mmc_send_cmd(mmc, &cmd, NULL);
+	struct mmc *mmc = find_mmc_device(dev_num);
+	if (!mmc)
+		return 0;
 
-		if (err)
-			return err;
+	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
+		return 0;
 
-		if (cmd.response[0] & OCR_BUSY)
-			break;
+	do {
+		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
+		if(mmc_write_blocks(mmc, start, cur, src) != cur)
+			return 0;
+		blocks_todo -= cur;
+		start += cur;
+		src += cur * mmc->write_bl_len;
+	} while (blocks_todo > 0);
 
-		if (timeout-- <= 0)
-			return UNUSABLE_ERR;
+	return blkcnt;
+}
 
-		udelay(1000);
+static ulong mmc_erase_t(struct mmc *mmc, ulong start, lbaint_t blkcnt)
+{
+	struct mmc_cmd cmd;
+	ulong end;
+	int err, start_cmd, end_cmd;
+#if 0
+	if (mmc->high_capacity)
+		end = start + blkcnt - 1;
+	else {
+		end = (start + blkcnt - 1) * mmc->write_bl_len;
+		start *= mmc->write_bl_len;
+	}
+#endif
+	end = start + blkcnt - 1;
+	if (IS_SD(mmc)) {
+		start_cmd = SD_CMD_ERASE_WR_BLK_START;
+		end_cmd = SD_CMD_ERASE_WR_BLK_END;
+	} else {
+		start_cmd = MMC_CMD_ERASE_GROUP_START;
+		end_cmd = MMC_CMD_ERASE_GROUP_END;
 	}
+	cmd.cmdidx = start_cmd;
+	cmd.cmdarg = start;
+	cmd.resp_type = MMC_RSP_R1;
 
-	if (mmc->version != SD_VERSION_2)
-		mmc->version = SD_VERSION_1_0;
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		goto err_out;
+	cmd.cmdidx = end_cmd;
+	cmd.cmdarg = end;
 
-	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
-		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
-		cmd.resp_type = MMC_RSP_R3;
-		cmd.cmdarg = 0;
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		goto err_out;
+	cmd.cmdidx = MMC_CMD_ERASE;
+	cmd.cmdarg = SECURE_ERASE;
+	cmd.resp_type = MMC_RSP_R1B;
 
-		err = mmc_send_cmd(mmc, &cmd, NULL);
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		goto err_out;
+
+	return 0;
+
+err_out:
+	puts("mmc erase failed\n");
+	return err;
+}
+
+
+static unsigned long
+mmc_berase(int dev_num, unsigned long start, lbaint_t blkcnt)
+{
+	int err = 0;
+	struct mmc *mmc = find_mmc_device(dev_num);
+	lbaint_t blk = 0, blk_r = 0;
+	int timeout = 1000;
+
+	if (!mmc)
+		return -1;
 
+	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
+		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
+			"The erase range would be change to 0x%lx~0x%lx * <n-th group>\n\n",
+		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
+		       ((start + blkcnt + mmc->erase_grp_size)
+		       & ~(mmc->erase_grp_size - 1)) - 1);
+
+	while (blk < blkcnt) {
+		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
+			mmc->erase_grp_size : (blkcnt - blk);
+		err = mmc_erase_t(mmc, start + blk, blk_r);
 		if (err)
-			return err;
-	}
+			break;
 
-	mmc->ocr = cmd.response[0];
+		blk += blk_r;
 
-	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
-	mmc->rca = 0;
+		/* Waiting for the ready status */
+		if (mmc_send_status(mmc, timeout))
+			return 0;
+	}
 
-	return 0;
+	return blk;
 }
+//*********************************************************************************
+
 
 static int mmc_send_op_cond_iter(struct mmc *mmc, int use_arg)
 {
@@ -365,9 +485,12 @@ static int mmc_send_op_cond_iter(struct mmc *mmc, int use_arg)
 	cmd.cmdarg = 0;
 	if (use_arg && !mmc_host_is_spi(mmc))
 		cmd.cmdarg = OCR_HCS |
-			(mmc->cfg->voltages &
+			(mmc->voltages &
 			(mmc->ocr & OCR_VOLTAGE_MASK)) |
 			(mmc->ocr & OCR_ACCESS_MODE);
+			//(mmc->cfg->voltages &
+			//(mmc->ocr & OCR_VOLTAGE_MASK)) |
+			//(mmc->ocr & OCR_ACCESS_MODE);
 
 	err = mmc_send_cmd(mmc, &cmd, NULL);
 	if (err)
@@ -397,6 +520,7 @@ static int mmc_send_op_cond(struct mmc *mmc)
 	return 0;
 }
 
+
 static int mmc_complete_op_cond(struct mmc *mmc)
 {
 	struct mmc_cmd cmd;
@@ -433,14 +557,16 @@ static int mmc_complete_op_cond(struct mmc *mmc)
 	}
 
 	mmc->version = MMC_VERSION_UNKNOWN;
-
+#if 0
 	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
 	mmc->rca = 1;
-
+#else
+	mmc->high_capacity = 0;		//force byte mode on rtk 1295 platform
+	mmc->rca = 0;
+#endif
 	return 0;
 }
 
-
 static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
 {
 	struct mmc_cmd cmd;
@@ -458,7 +584,10 @@ static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
 	data.flags = MMC_DATA_READ;
 
 	err = mmc_send_cmd(mmc, &cmd, &data);
-
+#ifdef MMC_DEBUG
+	flush_cache((unsigned long)ext_csd, CSD_ARRAY_SIZE);
+	mmc_show_ext_csd(ext_csd);
+#endif
 	return err;
 }
 
@@ -473,7 +602,7 @@ static int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
 	cmd.resp_type = MMC_RSP_R1b;
 	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
 				 (index << 16) |
-				 (value << 8);
+				 (value << 8)| set;
 
 	ret = mmc_send_cmd(mmc, &cmd, NULL);
 
@@ -484,7 +613,7 @@ static int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
 	return ret;
 
 }
-
+#if 0
 static int mmc_change_freq(struct mmc *mmc)
 {
 	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
@@ -535,6 +664,92 @@ static int mmc_change_freq(struct mmc *mmc)
 
 	return 0;
 }
+#endif
+
+int mmc_change_freq(struct mmc *mmc,unsigned int mode,unsigned int chg_type)
+{
+        MY_CLR_ALIGN_BUFFER();
+        int err=0;
+        extern unsigned int gCurrentBootMode;
+
+        if (mmc_host_is_spi(mmc))
+                return -1;
+
+        /* Only version 4 supports high-speed */
+        if (mmc->version < MMC_VERSION_4)
+                return -1;
+
+        switch(mode)
+        {
+                case MODE_SD20:
+                        gCurrentBootMode = MODE_SD20;
+                        if (chg_type & CHANGE_FREQ_CARD)
+                                err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS);
+                        if (chg_type & CHANGE_FREQ_HOST)
+                                mmc_set_mode_select(mmc,MMC_MODE_HS_52MHz);
+                        sync();
+                        break;
+                case MODE_DDR:
+                        gCurrentBootMode = MODE_DDR;
+                        if (chg_type & CHANGE_FREQ_CARD)
+                        {
+                                err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS);
+                        }
+                        if (chg_type & CHANGE_FREQ_HOST)
+                                mmc_set_mode_select(mmc,MMC_MODE_HSDDR_52MHz);
+                        sync();
+                        break;
+                case MODE_SD30:
+                        gCurrentBootMode = MODE_SD30;
+                        if (chg_type & CHANGE_FREQ_CARD)
+                                err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS200);
+                        if (chg_type & CHANGE_FREQ_HOST)
+                                mmc_set_mode_select(mmc,MMC_MODE_HS200);
+                        sync();
+                        break;
+        }
+
+        if (err)
+                return err;
+        return 0;
+}
+
+int mmc_get_card_caps(struct mmc *mmc, char *crd_ext_csd)
+{
+	char cardtype;
+
+	cardtype = crd_ext_csd[EXT_CSD_CARD_TYPE] & 0xff;
+
+	#ifdef MMC_DEBUG
+	printf("[LY] cardtype=%02x\n",cardtype);
+	#endif
+
+	if (cardtype == 0)
+	{
+		mmc->card_caps = 0;
+		printf("cardtype is empty, set sdr/ddr as default\n");
+		mmc->card_caps |= MMC_MODE_HS;
+		mmc->card_caps |= MMC_MODE_HS_52MHz;
+		mmc->card_caps |= MMC_MODE_HSDDR_52MHz;
+		if (!((((mmc->cid[0] >> 24)&0xff)== MANU_ID_MICRON1) || (((mmc->cid[0] >> 24)&0xff)== MANU_ID_MICRON2)))
+			mmc->card_caps |= MMC_MODE_HS200;
+	}
+	else
+	{
+		/* High Speed is set, there are two types: 52MHz and 26MHz */
+		mmc->card_caps = 0;
+		if (cardtype & MMC_HS_26MHZ)
+			mmc->card_caps |= MMC_MODE_HS;
+		if (cardtype & MMC_HS_52MHZ)
+			mmc->card_caps |= MMC_MODE_HS_52MHz;
+		if (cardtype & MMC_HS_DDR_1_8V_52MHZ)
+			mmc->card_caps |= MMC_MODE_HSDDR_52MHz;
+		if (cardtype & MMC_HS_200_1_8V_52MHZ)
+			mmc->card_caps |= MMC_MODE_HS200;
+	}
+	printf("[LY] cardtype=%02x, mmc->card_caps=%02x\n",cardtype,mmc->card_caps);
+	return 0;
+}
 
 static int mmc_set_capacity(struct mmc *mmc, int part_num)
 {
@@ -564,6 +779,7 @@ static int mmc_set_capacity(struct mmc *mmc, int part_num)
 	return 0;
 }
 
+#ifdef CONFIG_PARTITIONS
 int mmc_select_hwpart(int dev_num, int hwpart)
 {
 	struct mmc *mmc = find_mmc_device(dev_num);
@@ -588,7 +804,7 @@ int mmc_select_hwpart(int dev_num, int hwpart)
 
 	return 0;
 }
-
+#endif //CONFIG_PARTITIONS
 
 int mmc_switch_part(int dev_num, unsigned int part_num)
 {
@@ -813,8 +1029,10 @@ int mmc_getcd(struct mmc *mmc)
 	cd = board_mmc_getcd(mmc);
 
 	if (cd < 0) {
-		if (mmc->cfg->ops->getcd)
-			cd = mmc->cfg->ops->getcd(mmc);
+		//if (mmc->cfg->ops->getcd)
+			//cd = mmc->cfg->ops->getcd(mmc);
+		if (mmc->getcd)
+			cd = mmc->getcd(mmc);
 		else
 			cd = 1;
 	}
@@ -938,8 +1156,10 @@ retry_scr:
 	 * This can avoid furthur problem when the card runs in different
 	 * mode between the host.
 	 */
-	if (!((mmc->cfg->host_caps & MMC_MODE_HS_52MHz) &&
-		(mmc->cfg->host_caps & MMC_MODE_HS)))
+	//if (!((mmc->cfg->host_caps & MMC_MODE_HS_52MHz) &&
+	//	(mmc->cfg->host_caps & MMC_MODE_HS)))
+	if (!((mmc->host_caps & MMC_MODE_HS_52MHz) &&
+		(mmc->host_caps & MMC_MODE_HS)))
 		return 0;
 
 	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (u8 *)switch_status);
@@ -984,43 +1204,82 @@ static const int multipliers[] = {
 	80,
 };
 
-static void mmc_set_ios(struct mmc *mmc)
+static void mmc_set_ios(struct mmc *mmc, unsigned int caps)
+{
+	//if (mmc->cfg->ops->set_ios)
+	//	mmc->cfg->ops->set_ios(mmc);
+	if (mmc->set_ios)
+		mmc->set_ios(mmc, caps);
+}
+
+void mmc_set_mode_select(struct mmc *mmc, uint mode)
 {
-	if (mmc->cfg->ops->set_ios)
-		mmc->cfg->ops->set_ios(mmc);
+        mmc->mode_sel= mode;
+
+        mmc_set_ios(mmc,MMC_IOS_CLK);
 }
 
 void mmc_set_clock(struct mmc *mmc, uint clock)
 {
-	if (clock > mmc->cfg->f_max)
-		clock = mmc->cfg->f_max;
+	//if (clock > mmc->cfg->f_max)
+	//	clock = mmc->cfg->f_max;
 
-	if (clock < mmc->cfg->f_min)
-		clock = mmc->cfg->f_min;
+	//if (clock < mmc->cfg->f_min)
+	//	clock = mmc->cfg->f_min;
+	
+	if (clock > mmc->f_max)
+		clock = mmc->f_max;
+
+	if (clock < mmc->f_min)
+		clock = mmc->f_min;
 
 	mmc->clock = clock;
 
-	mmc_set_ios(mmc);
+	if (mmc->block_dev.if_type == IF_TYPE_SD) {
+		if (mmc->set_ios) {
+			mmc->set_ios(mmc, MMC_IOS_CLK/*bit1*/);
+		}
+		else {
+			printf(VT100_LIGHT_RED "MMC: set clock not effective" VT100_NONE_NL);
+		}
+	}
+	else {
+		mmc_set_ios(mmc, MMC_IOS_CLK);
+	}
 }
 
-static void mmc_set_bus_width(struct mmc *mmc, uint width)
+void mmc_set_bus_width(struct mmc *mmc, uint width)
 {
 	mmc->bus_width = width;
 
-	mmc_set_ios(mmc);
+	if (mmc->block_dev.if_type == IF_TYPE_SD) {
+		if (mmc->set_ios) {
+			mmc->set_ios(mmc, MMC_IOS_BUSWIDTH/*bit2*/);
+		}
+		else {
+			printf(VT100_LIGHT_RED "MMC: set width not effective" VT100_NONE_NL);
+		}
+	}
+	else {
+		mmc_set_ios(mmc, MMC_IOS_BUSWIDTH);
+	}
 }
-
 static int mmc_startup(struct mmc *mmc)
 {
 	int err, i;
-	uint mult, freq;
-	u64 cmult, csize, capacity;
+	uint mult=0, freq=0;
+	volatile u64 cmult=0, csize=0, capacity=0;
 	struct mmc_cmd cmd;
-	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
-	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, MMC_MAX_BLOCK_LEN);
-	int timeout = 1000;
-	bool has_parts = false;
+	static volatile int cmd_retry=0,cmd_retry1=0;
+	volatile uint cid_val=0;
 	bool part_completed;
+	bool has_parts = false;
+	//struct mmc_data data;
+
+	MY_CLR_ALIGN_BUFFER();
+	MY_ALLOC_CACHE_ALIGN_BUFFER(char, ext_csd, CSD_ARRAY_SIZE);
+	MY_ALLOC_CACHE_ALIGN_BUFFER(char, g_ext_csd, CSD_ARRAY_SIZE);
+	int timeout = 1000;
 
 #ifdef CONFIG_MMC_SPI_CRC_ON
 	if (mmc_host_is_spi(mmc)) { /* enable CRC check for spi */
@@ -1033,7 +1292,10 @@ static int mmc_startup(struct mmc *mmc)
 			return err;
 	}
 #endif
+        //set initial speed
+        rtkemmc_set_wrapper_div(0);        //no wrapper divider
 
+CMD_RETRY:
 	/* Put the Card in Identify Mode */
 	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
 		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
@@ -1041,17 +1303,298 @@ static int mmc_startup(struct mmc *mmc)
 	cmd.cmdarg = 0;
 
 	err = mmc_send_cmd(mmc, &cmd, NULL);
-
 	if (err)
-		return err;
+	{
+		if (cmd_retry1++ > MAX_CMD_RETRY_COUNT)
+			return err;
+		cmd_retry=0;
+		while (cmd_retry++ < MAX_CMD_RETRY_COUNT)
+		{
+			err = mmc_send_op_cond(mmc);
+			if (err) {
+				printf("Card did not respond to voltage select!\n");
+				continue;
+			}
+			else
+				break;
+		}
+		if (cmd_retry >= MAX_CMD_RETRY_COUNT)
+			return err;
+		else
+		{
+			goto CMD_RETRY;
+		}
+	}
 
 	memcpy(mmc->cid, cmd.response, 16);
+	flush_cache((unsigned long)mmc->cid, sizeof(unsigned int)*4);
+
+	cid_val = (mmc->cid[0]>>24)&0xff;
+	printf("The cid_val is %x.\n",cid_val);
+#ifdef MMC_DEBUG
+	printf("[LY] cid[0]=0x%02x\n",mmc->cid[0]>>24);
+#endif
+#ifdef DISABLE_MICRON_AUTO_STANDBY
+	if ((((mmc->cid[0] >> 24)&0xff)== MANU_ID_MICRON1) || (((mmc->cid[0] >> 24)&0xff)== MANU_ID_MICRON2))
+	{
+		g_bMicronFlash = 1;
+		//try sdr first
+		rtkemmc_set_wrapper_div(0);        //no wrapper divider
+
+		cmd_retry=0;cmd_retry1=0;
+		memset(outBlk, 0x00, 512);
+		memset(outTwoBlk, 0x00, 1024);
+		memset(rcvBlk, 0x00, 512);
+		outBlk[0] = 0x84;
+		outTwoBlk[0] = 0x08;
+
+		MPRINTF("[LY] disable procedure start -->\n");
+		//step 1
+		/* Reset the Card */
+		err = mmc_go_idle(mmc);
+		MPRINTF("[LY] <--- cmd0 sent(%d)--->\n",err);
+		if (err)
+			return err;
+
+		//step 2.1
+		cmd.cmdidx = MMC_CMD_MICRON_63;
+		cmd.resp_type = MMC_RSP_NONE;
+		cmd.cmdarg = 0x50485349;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (err)
+			return err;
+		MPRINTF("[LY] <---cmd63 sent--->\n");
+		//step 2.2
+		cmd.cmdidx = MMC_CMD_MICRON_63;
+		cmd.resp_type = MMC_RSP_NONE;
+		cmd.cmdarg = 0x50485353;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (err)
+			return err;
+		MPRINTF("[LY] <---cmd63 sent--->\n");
+
+		//step 3
+		/* Reset the Card */
+		sync();
+		err = mmc_go_idle(mmc);
+		MPRINTF("[LY] <---cmd0 sent--->\n");
+
+		//step 4
+		cmd.cmdidx = MMC_CMD_MICRON_63;
+		cmd.resp_type = MMC_RSP_NONE;
+		cmd.cmdarg = 0x50485343;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (err)
+			return err;
+		MPRINTF("[LY] <--- cmd63 sent--->\n");
+
+		//step 5
+		//cmd 0/1
+		sync();
+		err = mmc_send_op_cond(mmc);
+		if (err) {
+			printf("Card did not respond to voltage select!\n");
+			return UNUSABLE_ERR;
+		}
+
+		/* Put the Card in Identify Mode */
+		//cmd 2
+		cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
+			MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
+		cmd.resp_type = MMC_RSP_R2;
+		cmd.cmdarg = 0;
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (err)
+			return err;
+		MPRINTF("[LY] <---cmd 0/1/2 sent--->\n");
+
+		//step 6
+		cmd.cmdidx = MMC_CMD_MICRON_62;
+		cmd.resp_type = MMC_RSP_NONE;
+		cmd.cmdarg = 0x5048534D;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (err)
+			return err;
+		MPRINTF("[LY] <---cmd62 sent--->\n");
+		sync();
+		//step 7
+		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
+		cmd.cmdarg = mmc->rca << 16;
+		cmd.resp_type = MMC_RSP_R6;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (err)
+			return err;
+		MPRINTF("[LY] <--- cmd3 sent --->\n");
+		sync();
+
+		//step 8
+		cmd.cmdidx = MMC_CMD_SELECT_CARD;
+		cmd.resp_type = MMC_RSP_R1;
+		cmd.cmdarg = mmc->rca << 16;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (err)
+			return err;
+		MPRINTF("[LY] <--- cmd7 sent--->\n");
+		sync();
+
+		mmc_set_ios(mmc,MMC_IOS_NONE_DIV);
+		udelay(1000);
+		sync();
+#if 1
+    #if 1
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
+		if (err)
+		{
+			printf("[LY] card : switch to hs fail\n");
+			return err;
+		}
+    #endif
+		mmc_getset_pad(mmc, MMC_IOS_GET_PAD_DRV);
+		udelay(1000);
+		sync();
+
+		err = mmc_Select_SDR50_Push_Sample();
+		if (err)
+		{
+			printf("[LY] host : switch to hs fail\n");
+			return err;
+		}
+		mmc_getset_pad(mmc, MMC_IOS_RESTORE_PAD_DRV);
+		udelay(1000);
+		sync();
+#endif
+		//step 9 (send blk)
+		//speed up, disable ip divider
+		cmd.cmdidx = MMC_CMD_MICRON_60;
+		cmd.cmdarg = 0x0;   //??
+		cmd.resp_type = MMC_RSP_R1;
+
+		data.src = outBlk;
+		data.blocks = 1;
+		data.blocksize = 0x200;
+		data.resp_type = MMC_DATA_WRITE;
+		MPRINTF("[LY] write blk size = %08x\n",data.blocksize);
+
+		if (mmc_send_cmd(mmc, &cmd, &data)>0) {
+			printf("mmc write failed,cmd60 fail, send stop\n");
+#if 0
+			cmd.opcode = MMC_CMD_STOP_TRANSMISSION;
+			cmd.arg = 0;
+			cmd.flags = MMC_RSP_R1b;
+			if (mmc_send_cmd(mmc, &cmd, NULL)) {
+				printf("mmc fail to send stop cmd\n");
+				goto REINIT;
+			}
+#endif
+			goto REINIT;
+		}
+		MPRINTF("[LY] <--- cmd60 sent --->\n");
+		sync();
+		//step 10 (recv blk)
+		cmd.cmdidx = MMC_CMD_MICRON_61;
+		cmd.cmdarg = 0x0;   //??
+		cmd.resp_type = MMC_RSP_R1;
+
+		data.src = rcvBlk;
+		data.blocks = 1;
+		data.blocksize = 0x200;
+		data.resp_type = MMC_DATA_READ;
+		MPRINTF("[LY] read blk size = %08x\n",data.blocksize);
+
+		if (mmc_send_cmd(mmc, &cmd, &data)>0) {
+			printf("mmc read failed,cmd61 fail\n");
+			cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
+			cmd.cmdarg = 0;
+			cmd.resp_type = MMC_RSP_R1b;
+
+			if (mmc_send_cmd(mmc, &cmd, NULL)) {
+				printf("mmc fail to send stop cmd\n");
+				goto REINIT;
+			}
+			goto REINIT;
+		}
+		MPRINTF("[LY] <--- cmd61 sent --->\n");
+		sync();
+
+		//step 11
+		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
+		cmd.cmdarg = 0;
+		cmd.resp_type = MMC_RSP_R1b;
 
+		if (mmc_send_cmd(mmc, &cmd, NULL)) {
+			printf("mmc fail to send stop cmd\n");
+			goto REINIT;
+		}
+		MPRINTF("[LY] <--- cmd12 sent --->\n");
+		sync();
+
+		/* Waiting for the ready status */
+		if (mmc_send_status(mmc, 1000))
+		{
+			printf("[LY] send status fail\n");
+			goto REINIT;
+		}
+		MPRINTF("[LY] <--- cmd13 sent --->\n");
+		sync();
+		//step 12 (send 2 blk)
+		memcpy(outTwoBlk+512, outBlk, 512);
+		outTwoBlk[512+58] = 0xff;
+		sync();
+		flush_cache(outTwoBlk, CSD_ARRAY_SIZE*2);
+		cmd.cmdidx = MMC_CMD_MICRON_60;
+		cmd.cmdarg = 0x0;   //??
+		cmd.resp_type = MMC_RSP_R1;
+
+		data.src = outTwoBlk;
+		data.blocks = 2;
+		data.blocksize = 0x200*2;
+		data.flags = MMC_DATA_WRITE;
+		MPRINTF("[LY] write 2 blk size = %08x\n",data.blocksize);
+
+		if (mmc_send_cmd(mmc, &cmd, &data)>0) {
+			printf("mmc write failed\n");
+			goto REINIT;
+		}
+		MPRINTF("[LY] <--- cmd60 sent--->\n");
+		MPRINTF("[LY] disable procedure done ------->\n");
+		sync();
+		printf("Standby : disable micron standby mode\n");
+
+REINIT:
+		//back to original startup path
+		//cmd 0/1
+		mmc_set_ios(mmc,MMC_IOS_INIT_DIV);
+		udelay(1000);
+		sync();
+		err = mmc_send_op_cond(mmc);
+		if (err) {
+			printf("Card did not respond to voltage select!\n");
+			return UNUSABLE_ERR;
+		}
+
+		/* Put the Card in Identify Mode */
+
+		cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
+			MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
+		cmd.resp_type = MMC_RSP_R2;
+		cmd.cmdarg = 0;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (err)
+			return err;
+	}
+#endif
 	/*
 	 * For MMC cards, set the Relative Address.
-	 * For SD cards, get the Relatvie Address.
-	 * This also puts the cards into Standby State
-	 */
+         * For SD cards, get the Relatvie Address.
+         * This also puts the cards into Standby State
+	*/
 	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
 		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
 		cmd.cmdarg = mmc->rca << 16;
@@ -1084,9 +1627,19 @@ static int mmc_startup(struct mmc *mmc)
 	mmc->csd[2] = cmd.response[2];
 	mmc->csd[3] = cmd.response[3];
 
+#ifdef MMC_DEBUG
+	mmc_show_csd(mmc);
+	mmc_decode_cid(mmc);
+#endif
+
+	flush_cache((unsigned long)cmd.response, sizeof(unsigned int)*4);
+	flush_cache((unsigned long)mmc->csd, sizeof(unsigned int)*4);
+
+	printf("mmc->version=0x%08x\n", mmc->version);
 	if (mmc->version == MMC_VERSION_UNKNOWN) {
 		int version = (cmd.response[0] >> 26) & 0xf;
 
+		printf("version=0x%08x\n", version);
 		switch (version) {
 			case 0:
 				mmc->version = MMC_VERSION_1_2;
@@ -1113,8 +1666,10 @@ static int mmc_startup(struct mmc *mmc)
 	freq = fbase[(cmd.response[0] & 0x7)];
 	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];
 
-	mmc->tran_speed = freq * mult;
-
+	mmc->tran_speed = (u64)(freq * mult);
+#ifdef MMC_DEBUG
+	printf("0 [LY] freq=0x%08x, mult=0x%08x,mmc->tran_speed=%lld\n",freq,mult,mmc->tran_speed);
+#endif
 	mmc->dsr_imp = ((cmd.response[1] >> 12) & 0x1);
 	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
 
@@ -1127,10 +1682,16 @@ static int mmc_startup(struct mmc *mmc)
 		csize = (mmc->csd[1] & 0x3f) << 16
 			| (mmc->csd[2] & 0xffff0000) >> 16;
 		cmult = 8;
+		#ifdef MMC_DEBUG
+		printf("1 [LY] csize=0x%lld, cmult=0x%lld\n",csize,cmult);
+		#endif
 	} else {
 		csize = (mmc->csd[1] & 0x3ff) << 2
 			| (mmc->csd[2] & 0xc0000000) >> 30;
 		cmult = (mmc->csd[2] & 0x00038000) >> 15;
+		#ifdef MMC_DEBUG
+		printf("1.1 [LY] csize=%lld, cmult=%lld\n",csize,cmult);
+		#endif
 	}
 
 	mmc->capacity_user = (csize + 1) << (cmult + 2);
@@ -1139,7 +1700,16 @@ static int mmc_startup(struct mmc *mmc)
 	mmc->capacity_rpmb = 0;
 	for (i = 0; i < 4; i++)
 		mmc->capacity_gp[i] = 0;
-
+	#ifdef MMC_DEBUG
+	printf("2 [LY] read_bl_len=0x%08x, cmd.rsp[1]=0x%08x\n",mmc->read_bl_len,(cmd.response[1]>>16)&0xf);
+	#endif
+#if 0
+        mmc->capacity = (u64)((csize + 1) << (cmult + 2));
+        mmc->capacity = ((u64)(mmc->capacity)) * ((u64)(mmc->read_bl_len));
+        #ifdef MMC_DEBUG
+        printf("3 [LY] mmc->cap=%lld\n",mmc->capacity);
+        #endif
+#endif
 	if (mmc->read_bl_len > MMC_MAX_BLOCK_LEN)
 		mmc->read_bl_len = MMC_MAX_BLOCK_LEN;
 
@@ -1167,15 +1737,29 @@ static int mmc_startup(struct mmc *mmc)
 
 	/*
 	 * For SD, its erase group is always one sector
-	 */
+	*/
+
 	mmc->erase_grp_size = 1;
 	mmc->part_config = MMCPART_NOAVAILABLE;
 	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
-		/* check  ext_csd version and capacity */
-		err = mmc_send_ext_csd(mmc, ext_csd);
+		/* check ext_csd version and capacity */
+		flush_cache((unsigned long)ext_csd, CSD_ARRAY_SIZE);
+		MMCPRINTF("[%s:%d] ext_csd = 0x%p", __FILE__, __LINE__, ext_csd);
+		err = mmc_send_ext_csd(mmc, (unsigned char *) ext_csd);
+		flush_cache((unsigned long)ext_csd, CSD_ARRAY_SIZE);
 		if (err)
-			return err;
-		if (ext_csd[EXT_CSD_REV] >= 2) {
+			return -1;
+		else
+		{
+			flush_cache((unsigned long)g_ext_csd, CSD_ARRAY_SIZE);
+			memcpy(g_ext_csd,ext_csd, CSD_ARRAY_SIZE);
+			flush_cache((unsigned long)g_ext_csd, CSD_ARRAY_SIZE);
+		}
+
+#ifdef MMC_DEBUG
+		printf("[LY] ext_csd[EXT_CSD_REV] = 0x%08x, mmc->version=%08x\n", ext_csd[EXT_CSD_REV], mmc->version);
+#endif
+		if (!err & (ext_csd[EXT_CSD_REV] >= 2)) {
 			/*
 			 * According to the JEDEC Standard, the value of
 			 * ext_csd's capacity is valid if the value is more
@@ -1187,6 +1771,7 @@ static int mmc_startup(struct mmc *mmc)
 					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
 			capacity *= MMC_MAX_BLOCK_LEN;
 			if ((capacity >> 20) > 2 * 1024)
+				//mmc->capacity = capacity;
 				mmc->capacity_user = capacity;
 		}
 
@@ -1210,12 +1795,15 @@ static int mmc_startup(struct mmc *mmc)
 			mmc->version = MMC_VERSION_5_0;
 			break;
 		}
+#ifdef MMC_DEBUG
+		printf("5 [LY] mmc->cap=%lld, cap=%lld\n",mmc->capacity,capacity);
+#endif
 
-		/* The partition data may be non-zero but it is only
-		 * effective if PARTITION_SETTING_COMPLETED is set in
-		 * EXT_CSD, so ignore any data if this bit is not set,
-		 * except for enabling the high-capacity group size
-		 * definition (see below). */
+		/*
+		 * Check whether GROUP_DEF is set, if yes, read out
+		 * group size from ext_csd directly, or calculate
+		 * the group size from the csd value.
+		 */
 		part_completed = !!(ext_csd[EXT_CSD_PARTITION_SETTING] &
 				    EXT_CSD_PARTITION_SETTING_COMPLETED);
 
@@ -1227,7 +1815,6 @@ static int mmc_startup(struct mmc *mmc)
 		if (part_completed &&
 		    (ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & ENHNCD_SUPPORT))
 			mmc->part_attr = ext_csd[EXT_CSD_PARTITIONS_ATTRIBUTE];
-
 		mmc->capacity_boot = ext_csd[EXT_CSD_BOOT_MULT] << 17;
 
 		mmc->capacity_rpmb = ext_csd[EXT_CSD_RPMB_MULT] << 17;
@@ -1272,7 +1859,7 @@ static int mmc_startup(struct mmc *mmc)
 		if (part_completed)
 			has_parts = true;
 		if ((ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & PART_SUPPORT) &&
-		    (ext_csd[EXT_CSD_PARTITIONS_ATTRIBUTE] & PART_ENH_ATTRIB))
+			(ext_csd[EXT_CSD_PARTITIONS_ATTRIBUTE] & PART_ENH_ATTRIB))
 			has_parts = true;
 		if (has_parts) {
 			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
@@ -1284,8 +1871,7 @@ static int mmc_startup(struct mmc *mmc)
 				ext_csd[EXT_CSD_ERASE_GROUP_DEF] = 1;
 		}
 
-		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF] & 0x01) {
-			/* Read out group size from ext_csd */
+		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF] & 0x01){
 			mmc->erase_grp_size =
 				ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 1024;
 			/*
@@ -1309,13 +1895,17 @@ static int mmc_startup(struct mmc *mmc)
 			mmc->erase_grp_size = (erase_gsz + 1)
 				* (erase_gmul + 1);
 		}
-
 		mmc->hc_wp_grp_size = 1024
 			* ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
 			* ext_csd[EXT_CSD_HC_WP_GRP_SIZE];
 
 		mmc->wr_rel_set = ext_csd[EXT_CSD_WR_REL_SET];
+		/* store the partition info of emmc */
+		if (ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & PART_SUPPORT)
+			mmc->part_config = ext_csd[EXT_CSD_PART_CONF];
 	}
+	else
+		printf("[LY] mmc->version < 4\n");
 
 	err = mmc_set_capacity(mmc, mmc->part_num);
 	if (err)
@@ -1324,13 +1914,13 @@ static int mmc_startup(struct mmc *mmc)
 	if (IS_SD(mmc))
 		err = sd_change_freq(mmc);
 	else
-		err = mmc_change_freq(mmc);
+		err = mmc_get_card_caps(mmc,ext_csd);
 
-	if (err)
+	if(err > 0)
 		return err;
 
 	/* Restrict card's capabilities by what the host can do */
-	mmc->card_caps &= mmc->cfg->host_caps;
+	mmc->card_caps &= mmc->host_caps;
 
 	if (IS_SD(mmc)) {
 		if (mmc->card_caps & MMC_MODE_4BIT) {
@@ -1356,7 +1946,9 @@ static int mmc_startup(struct mmc *mmc)
 			mmc->tran_speed = 50000000;
 		else
 			mmc->tran_speed = 25000000;
-	} else if (mmc->version >= MMC_VERSION_4) {
+	}
+#if 0
+	else if (mmc->version >= MMC_VERSION_4) {
 		/* Only version 4 of MMC supports wider bus widths */
 		int idx;
 
@@ -1399,7 +1991,6 @@ static int mmc_startup(struct mmc *mmc)
 				err = 0;
 				break;
 			}
-
 			/*
 			 * Check to make sure the card and controller support
 			 * these capabilities
@@ -1442,27 +2033,103 @@ static int mmc_startup(struct mmc *mmc)
 
 		if (mmc->card_caps & MMC_MODE_HS) {
 			if (mmc->card_caps & MMC_MODE_HS_52MHz)
-				mmc->tran_speed = 52000000;
+				mmc->tran_speed = 50000000;
 			else
-				mmc->tran_speed = 26000000;
+				mmc->tran_speed = 25000000;
 		}
 	}
-
+#endif
 	mmc_set_clock(mmc, mmc->tran_speed);
+	mmc->boot_caps |= MMC_MODE_HS | MMC_MODE_HS_52MHz;
 
-	/* Fix the block length for DDR mode */
-	if (mmc->ddr_mode) {
-		mmc->read_bl_len = MMC_MAX_BLOCK_LEN;
-		mmc->write_bl_len = MMC_MAX_BLOCK_LEN;
+#ifdef MMC_DEBUG
+	printf("[LY] bootcaps = %08x\n", mmc->boot_caps);
+	printf("[LY] hostcaps= %08x\n", mmc->host_caps);
+	printf("[LY] cardcaps = %08x\n", mmc->card_caps);
+	printf("[LY] freq = %08x, clk diver = %08x\n", REG32(PLL_EMMC3),REG32(CR_EMMC_CLKDIV));
+#else
+	printf("[LY] freq = %08x, clk diver = %08x\n", REG32(PLL_EMMC3),REG32(CR_EMMC_CLKDIV));
+#endif
+
+#ifdef SUPPORT_HS200
+	if (mmc->card_caps & MMC_MODE_HS200) {
+		err = mmc_select_hs200(mmc,ext_csd);
+		printf("[LY] hs200 : %d\n", err);
+		if (err)
+		{
+//1295 not support ddr50
+#if 0
+		if ((err != -4)||(err != -5)||(err != -6))
+		{
+			err = mmc_select_ddr50(mmc,ext_csd);
+			printf("[LY] ddr50 : %d\n", err);
+		}
+		if (err)
+#endif
+			{
+				err = mmc_change_freq(mmc, MODE_SD20, CHANGE_FREQ_HOST);
+				if (err)
+				{
+					printf("[LY] set spd hs200 to sdr50 fail\n");
+				}
+				mmc->tran_speed = 50000000;
+				err = mmc_select_sdr50(mmc,ext_csd);
+				printf("[LY] sdr50 : %d\n", err);
+			}
+		}
+		else mmc->tran_speed = 200000000;
+	}
+	else
+	{
+//1295 not support ddr50
+#if 0
+	err = mmc_select_ddr50(mmc,ext_csd);
+	printf("[LY] ddr50 : %d\n", err);
+	if (err)
+#endif
+		{
+			err = mmc_select_sdr50(mmc,ext_csd);
+			printf("[LY] sdr50 : %d\n", err);
+		}
 	}
+#else
+	err = mmc_select_sdr50(mmc,ext_csd);
+	printf("[LY] sdr50 : %d\n", err);
+#endif
 
+#ifdef SUPPORT_WRITE_PROT
+	if ((ext_csd[EXT_CSD_ERASE_GROUP_DEF] & 1) == 0){
+		err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+			EXT_CSD_ERASE_GROUP_DEF, 1);
+
+			flush_cache((unsigned long)ext_csd, CSD_ARRAY_SIZE);
+			err = mmc_send_ext_csd(mmc, (unsigned char *) ext_csd);
+			flush_cache((unsigned long)ext_csd, CSD_ARRAY_SIZE);
+		}
+		if (err)
+			printf("[ERR] Fail to set ERASE_GROUP_DEF ! \n");
+		else {
+			mmc->erase_grp_size =
+				ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;	//512 Kbytes x ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
+			printf("[HC] ERASE Unit Size = %u bytes\n", mmc->erase_grp_size);
+			mmc->hc_wp_grp_size = mmc->erase_grp_size * ext_csd[EXT_CSD_HC_WP_GRP_SIZE];
+			printf("[HC] WPG_SIZE = %u bytes\n", mmc->hc_wp_grp_size);
+		}
+#endif
 	/* fill in device description */
 	mmc->block_dev.lun = 0;
 	mmc->block_dev.type = 0;
 	mmc->block_dev.blksz = mmc->read_bl_len;
-	mmc->block_dev.log2blksz = LOG2(mmc->block_dev.blksz);
 	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
+#if 0
+	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
+			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
+	sprintf(mmc->block_dev.product, "%c%c%c%c%c", mmc->cid[0] & 0xff,
+			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
+			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);
+	sprintf(mmc->block_dev.revision, "%d.%d", mmc->cid[2] >> 28,
+			(mmc->cid[2] >> 24) & 0xf);
+#endif
 	sprintf(mmc->block_dev.vendor, "Man %06x Snr %04x%04x",
 		mmc->cid[0] >> 24, (mmc->cid[2] & 0xffff),
 		(mmc->cid[3] >> 16) & 0xffff);
@@ -1472,18 +2139,12 @@ static int mmc_startup(struct mmc *mmc)
 		(mmc->cid[2] >> 24) & 0xff);
 	sprintf(mmc->block_dev.revision, "%d.%d", (mmc->cid[2] >> 20) & 0xf,
 		(mmc->cid[2] >> 16) & 0xf);
-#else
-	mmc->block_dev.vendor[0] = 0;
-	mmc->block_dev.product[0] = 0;
-	mmc->block_dev.revision[0] = 0;
-#endif
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT)
 	init_part(&mmc->block_dev);
-#endif
 
 	return 0;
 }
 
+#if 0
 static int mmc_send_if_cond(struct mmc *mmc)
 {
 	struct mmc_cmd cmd;
@@ -1491,10 +2152,12 @@ static int mmc_send_if_cond(struct mmc *mmc)
 
 	cmd.cmdidx = SD_CMD_SEND_IF_COND;
 	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
-	cmd.cmdarg = ((mmc->cfg->voltages & 0xff8000) != 0) << 8 | 0xaa;
+	//cmd.cmdarg = ((mmc->cfg->voltages & 0xff8000) != 0) << 8 | 0xaa;
+	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
 	cmd.resp_type = MMC_RSP_R7;
 
 	err = mmc_send_cmd(mmc, &cmd, NULL);
+	printf("[CHECK] the error4 is %d.\n",err);
 
 	if (err)
 		return err;
@@ -1506,7 +2169,8 @@ static int mmc_send_if_cond(struct mmc *mmc)
 
 	return 0;
 }
-
+#endif
+#if 0
 /* not used any more */
 int __deprecated mmc_register(struct mmc *mmc)
 {
@@ -1515,7 +2179,31 @@ int __deprecated mmc_register(struct mmc *mmc)
 #endif
 	return -1;
 }
+#endif
+int mmc_register(struct mmc *mmc)
+{
+	/* Setup dsr related values */
+        mmc->dsr_imp = 0;
+        mmc->dsr = 0xffffffff;
+
+	/* Setup the universal parts of the block interface just once */
+	mmc->block_dev.if_type = IF_TYPE_MMC;
+	mmc->block_dev.dev = cur_dev_num++;
+	mmc->block_dev.removable = 1;
+	mmc->block_dev.block_read = mmc_bread;
+	mmc->block_dev.block_write = mmc_bwrite;
+	mmc->block_dev.block_erase = mmc_berase;
+	mmc->block_dev.part_type = PART_TYPE_UNKNOWN;;
+	if (!mmc->b_max)
+		mmc->b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
+
+	INIT_LIST_HEAD (&mmc->link);
 
+	list_add_tail (&mmc->link, &mmc_devices);
+
+	return 0;
+}
+#if 0
 struct mmc *mmc_create(const struct mmc_config *cfg, void *priv)
 {
 	struct mmc *mmc;
@@ -1533,7 +2221,7 @@ struct mmc *mmc_create(const struct mmc_config *cfg, void *priv)
 	mmc->priv = priv;
 
 	/* the following chunk was mmc_register() */
-
+	printf("Checking the MMC_CREAT!!!!!!!\n");
 	/* Setup dsr related values */
 	mmc->dsr_imp = 0;
 	mmc->dsr = 0xffffffff;
@@ -1554,7 +2242,7 @@ struct mmc *mmc_create(const struct mmc_config *cfg, void *priv)
 
 	return mmc;
 }
-
+#endif
 void mmc_destroy(struct mmc *mmc)
 {
 	/* only freeing memory for now */
@@ -1579,10 +2267,11 @@ __weak void board_mmc_power_init(void)
 
 int mmc_start_init(struct mmc *mmc)
 {
-	int err;
+	int err = 0;
 
 	/* we pretend there's no card when init is NULL */
-	if (mmc_getcd(mmc) == 0 || mmc->cfg->ops->init == NULL) {
+	//if (mmc_getcd(mmc) == 0 || mmc->cfg->ops->init == NULL) {
+	if (mmc_getcd(mmc) == 0 || mmc->init == NULL) {
 		mmc->has_init = 0;
 #if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
 		printf("MMC: no card present\n");
@@ -1598,8 +2287,10 @@ int mmc_start_init(struct mmc *mmc)
 #endif
 	board_mmc_power_init();
 
+
 	/* made sure it's not NULL earlier */
-	err = mmc->cfg->ops->init(mmc);
+	//err = mmc->cfg->ops->init(mmc);
+	mmc->init();
 
 	if (err)
 		return err;
@@ -1607,21 +2298,31 @@ int mmc_start_init(struct mmc *mmc)
 	mmc->ddr_mode = 0;
 	mmc_set_bus_width(mmc, 1);
 	mmc_set_clock(mmc, 1);
+	mmc_set_mode_select(mmc, 0);
+	
+	
+	mmc->part_num = 0;
+	err = TIMEOUT;
+
 
+#if 0
 	/* Reset the Card */
 	err = mmc_go_idle(mmc);
 
 	if (err)
 		return err;
-
+	printf("[CHECK] procedure 9!!!\n");
 	/* The internal partition reset to user partition(0) at every CMD0*/
 	mmc->part_num = 0;
 
 	/* Test for SD version 2 */
 	err = mmc_send_if_cond(mmc);
+	printf("[CHECK] the error1 is %d.\n",err);
 
 	/* Now try to get the SD card's operating condition */
 	err = sd_send_op_cond(mmc);
+	printf("[CHECK] the error2 is %d.\n",err);
+#endif
 
 	/* If the command timed out, we check for an MMC card */
 	if (err == TIMEOUT) {
@@ -1644,7 +2345,6 @@ int mmc_start_init(struct mmc *mmc)
 static int mmc_complete_init(struct mmc *mmc)
 {
 	int err = 0;
-
 	mmc->init_in_progress = 0;
 	if (mmc->op_cond_pending)
 		err = mmc_complete_op_cond(mmc);
@@ -1655,6 +2355,7 @@ static int mmc_complete_init(struct mmc *mmc)
 		mmc->has_init = 0;
 	else
 		mmc->has_init = 1;
+	
 	return err;
 }
 
@@ -1667,10 +2368,8 @@ int mmc_init(struct mmc *mmc)
 		return 0;
 
 	start = get_timer(0);
-
 	if (!mmc->init_in_progress)
 		err = mmc_start_init(mmc);
-
 	if (!err)
 		err = mmc_complete_init(mmc);
 	debug("%s: %d, time %lu\n", __func__, err, get_timer(start));
@@ -1702,16 +2401,16 @@ void print_mmc_devices(char separator)
 	struct mmc *m;
 	struct list_head *entry;
 	char *mmc_type;
-
+	
 	list_for_each(entry, &mmc_devices) {
 		m = list_entry(entry, struct mmc, link);
-
 		if (m->has_init)
 			mmc_type = IS_SD(m) ? "SD" : "eMMC";
 		else
 			mmc_type = NULL;
-
-		printf("%s: %d", m->cfg->name, m->block_dev.dev);
+		
+		printf("%s: %d", m->name, m->block_dev.dev);
+		//printf("%s: %d", m->cfg->name, m->block_dev.dev);
 		if (mmc_type)
 			printf(" (%s)", mmc_type);
 
@@ -1721,7 +2420,6 @@ void print_mmc_devices(char separator)
 				puts (" ");
 		}
 	}
-
 	printf("\n");
 }
 
@@ -1894,3 +2592,197 @@ int mmc_set_rst_n_function(struct mmc *mmc, u8 enable)
 			  enable);
 }
 #endif
+
+
+int mmc_select_sdr50(struct mmc *mmc,char* ext_csd)
+{
+	extern unsigned int gCurrentBootMode;
+	volatile int width=0;
+	volatile int err=0, ret=0;
+
+	MY_CLR_ALIGN_BUFFER();
+	MY_ALLOC_CACHE_ALIGN_BUFFER(unsigned char, test_csd, CSD_ARRAY_SIZE*2);
+
+		gCurrentBootMode = MODE_SD20;
+		mmc->boot_caps &= ~MMC_MODE_HS200;
+		//try sdr first
+		rtkemmc_set_wrapper_div(0);        //no wrapper divider
+		
+		//restore original pad value
+		//mmc_getset_pad(mmc, MMC_IOS_RESTORE_PAD_DRV);
+
+		//let card in better quality channel
+		err = mmc_change_freq(mmc,MODE_SD20, CHANGE_FREQ_CARD);
+		if (err)
+		{
+			printf("[LY] set crd to hs fail:%d\n", err);
+			return -7;
+		}
+		sync();
+		err = mmc_change_freq(mmc,MODE_SD20, CHANGE_FREQ_HOST);
+		width = BUS_WIDTH_8;
+		for (; width >= 0; width--) {
+			printf("[LY] SDR bus width=%d\n", width);
+			sync();
+			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+					EXT_CSD_BUS_WIDTH, width);
+			sync();
+			if (err)
+			{
+				if (width == BUS_WIDTH_1)
+					return -4;
+				else
+					continue;
+			}
+
+			if (!width)
+				mmc_set_bus_width(mmc, 1);
+			else
+				mmc_set_bus_width(mmc, 4 * width);
+			sync();
+
+			flush_cache((unsigned long)test_csd, CSD_ARRAY_SIZE);
+			err = mmc_send_ext_csd(mmc, (unsigned char *) test_csd);
+			#ifdef MMC_DEBUG
+    			mmc_show_ext_csd(test_csd);
+			#endif
+
+			if (!err && ext_csd[EXT_CSD_PARTITIONING_SUPPORT] \
+				    == test_csd[EXT_CSD_PARTITIONING_SUPPORT]
+				 && ext_csd[EXT_CSD_ERASE_GROUP_DEF] \
+				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
+				 && ext_csd[EXT_CSD_REV] \
+				    == test_csd[EXT_CSD_REV]
+				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
+				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
+				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
+					&test_csd[EXT_CSD_SEC_CNT], 4) == 0) {
+
+				mmc->card_caps |= width;
+				mmc->boot_caps |= (width << MMC_MODE_WIDTH_BITS_SHIFT);
+				printf("[LY] mmc->boot_caps = %02x\n",mmc->boot_caps);
+				ret=0;
+				break;
+			}
+			else {
+				if (!width) {
+					printf("MMC: set bus width 1 fail\n");
+				}
+				else {
+					printf("MMC: set bus width %d fail, try other mode\n", (4 * width));
+				}
+				ret=-2;
+			}
+		}
+
+		if (mmc->card_caps & MMC_MODE_HS) {
+			if (mmc->card_caps & MMC_MODE_HS_52MHz)
+				mmc->tran_speed = 52000000;
+			else
+				mmc->tran_speed = 26000000;
+		}
+
+	return ret;
+}
+
+int mmc_select_hs200(struct mmc *mmc,char* ext_csd)
+{
+        volatile int width=0;
+        volatile int err=0,ret=0;
+
+        MY_CLR_ALIGN_BUFFER();
+        MY_ALLOC_CACHE_ALIGN_BUFFER(char, test_csd, CSD_ARRAY_SIZE*2);
+
+        // HS-200
+        if (!IS_SD(mmc)&&((mmc->host_caps & MMC_MODE_HS200) == (mmc->card_caps & MMC_MODE_HS200)))
+        {
+                //set max pad value
+                //mmc_getset_pad(mmc, MMC_IOS_SET_PAD_DRV);
+
+                //try hs-200, 8/4 bits
+                printf("[LY] speed up emmc at HS-200 \n");
+                width = BUS_WIDTH_8;
+                sync();
+                for (; width > 0; width--) {
+                        printf("[LY] HS-200 bus width=%d\n", width);
+                        sync();
+                        err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+                                        EXT_CSD_BUS_WIDTH, width);
+                        sync();
+                        if (err)
+                        {
+                                //get the correct sample/push point at SDR mode
+                                printf("[LY] hs200 card bus switch retry result = %d\n", err);
+                                if (width == BUS_WIDTH_4)
+                                        return -6;
+                                continue;
+                        }
+                        sync();
+                        mmc_set_bus_width(mmc, 4 * width);
+                        sync();
+
+                        {
+
+                        flush_cache((unsigned long)test_csd, CSD_ARRAY_SIZE);
+                        err = mmc_send_ext_csd(mmc, (unsigned char *)test_csd);
+                        flush_cache((unsigned long)test_csd, CSD_ARRAY_SIZE);
+
+			if (!err && ext_csd[EXT_CSD_PARTITIONING_SUPPORT] \
+                                    == test_csd[EXT_CSD_PARTITIONING_SUPPORT]
+                                 && ext_csd[EXT_CSD_ERASE_GROUP_DEF] \
+                                    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
+                                 && ext_csd[EXT_CSD_REV] \
+                                    == test_csd[EXT_CSD_REV]
+                                 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
+                                    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
+                                 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
+                                        &test_csd[EXT_CSD_SEC_CNT], 4) == 0) {
+
+                                mmc->card_caps |= width;
+                                mmc->boot_caps |= (width << MMC_MODE_WIDTH_BITS_SHIFT);
+                                mmc->boot_caps |= MMC_MODE_HS200;
+                                printf("[LY] mmc->boot_caps = %02x\n",mmc->boot_caps);
+                                ret = 0;
+                                break;
+                        }
+                        else {
+                                if (!width) {
+                                        printf("MMC: set hs200 bus width 1 fail\n");
+                                }
+                                else {
+                                        printf("MMC: set hs200 bus width %d fail, try other mode\n", (4 * width));
+                                }
+                                ret = -2;
+                        }
+                        }
+                }
+
+        }
+        else
+                return -1;
+
+	err = mmc_change_freq(mmc, MODE_SD30, CHANGE_FREQ_CARD);
+        if (err)
+        {
+                printf("[LY] hs200 card cmd fail = %d\n", err);
+                return -5;
+        }
+        sync();
+        err = mmc_change_freq(mmc, MODE_SD30, CHANGE_FREQ_HOST);
+        if (err)
+        {
+                printf("[LY] set host hs200 speed fail = %d\n", err);
+                return -4;
+        }
+        //get the correct sample/push point at DDR mode
+        err = mmc_Tuning_HS200();
+        if (err)
+        {
+                printf("[LY] hs200 tuning fail(%d)\n",err);
+                return err;
+        }
+
+        //hs200 at 100Mhz
+        mmc->tran_speed = 100000000;
+        return ret;
+}
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 347ea62e0b..d01610256d 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -5,6 +5,8 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+obj-$(CONFIG_MTD_NAND_RTK) += rtk_nand.o nand_base_rtk.o
+
 ifdef CONFIG_SPL_BUILD
 
 ifdef CONFIG_SPL_NAND_DRIVERS
diff --git a/drivers/mtd/nand/nand.c b/drivers/mtd/nand/nand.c
index 4cf4c1c707..e3c30d752e 100644
--- a/drivers/mtd/nand/nand.c
+++ b/drivers/mtd/nand/nand.c
@@ -75,6 +75,9 @@ int nand_register(int devnum)
 }
 
 #ifndef CONFIG_SYS_NAND_SELF_INIT
+#ifdef CONFIG_TARGET_RTD1295
+extern int rtk_nand_scan (struct mtd_info *mtd, int maxchips);
+#endif
 static void nand_init_chip(int i)
 {
 	struct mtd_info *mtd = &nand_info[i];
@@ -91,7 +94,11 @@ static void nand_init_chip(int i)
 	if (board_nand_init(nand))
 		return;
 
+#ifdef CONFIG_TARGET_RTD1295
+	if (rtk_nand_scan(mtd, maxchips))
+#else
 	if (nand_scan(mtd, maxchips))
+#endif
 		return;
 
 	nand_register(i);
diff --git a/drivers/mtd/nand/nand_util.c b/drivers/mtd/nand/nand_util.c
index ee2c24df3b..ed93d20487 100644
--- a/drivers/mtd/nand/nand_util.c
+++ b/drivers/mtd/nand/nand_util.c
@@ -37,6 +37,8 @@ typedef struct mtd_info		mtd_info_t;
 #define cpu_to_je16(x) (x)
 #define cpu_to_je32(x) (x)
 
+extern int nand_read_on_the_fly (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf, u16 cp_mode);
+
 /**
  * nand_erase_opts: - erase NAND flash with support for various options
  *		      (jffs2 formatting)
@@ -679,6 +681,18 @@ int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
 	return 0;
 }
 
+#ifdef CONFIG_RTD1295
+int rtknand_read(unsigned int source_address, unsigned int byte_length, unsigned int *target_address) {
+	struct mtd_info *mtd = &nand_info[nand_curr_device];
+	size_t rwsize = mtd->writesize;
+
+	if (!nand_read_skip_bad(mtd,source_address,&rwsize, NULL, mtd->size, (u_char*)(uintptr_t)target_address))
+		return (int)rwsize;
+
+	return 0;
+}
+#endif
+
 /**
  * nand_read_skip_bad:
  *
@@ -781,6 +795,78 @@ int nand_read_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
 	return 0;
 }
 
+/**
+ * nand_read_skip_bad_on_the_fly:
+ *
+*/
+
+ int nand_read_skip_bad_on_the_fly(nand_info_t *nand, loff_t offset, size_t *length,u_char *buffer, u16 cp_mode)
+{
+	int rval;
+	size_t left_to_read = *length;
+	size_t used_for_read = 0;
+	u_char *p_buffer = buffer;
+	int need_skip;
+
+	if ((offset & (nand->writesize - 1)) != 0) {
+		printf ("Attempt to read non page aligned data\n");
+		*length = 0;
+		return -EINVAL;
+	}
+
+	need_skip = check_skip_len(nand, offset, *length, &used_for_read);
+	if (need_skip < 0) {
+		printf ("Attempt to read outside the flash area\n");
+		*length = 0;
+		return -EINVAL;
+	}
+
+	if (!need_skip) {
+		rval = nand_read_on_the_fly (nand, offset, *length, (size_t*)length, buffer,cp_mode);
+
+
+		if (!rval || rval == -EUCLEAN)
+			return 0;
+
+		*length = 0;
+		printf ("NAND read from offset %llx failed %d\n",
+			offset, rval);
+		return rval;
+	}
+
+	while (left_to_read > 0) {
+		size_t block_offset = offset & (nand->erasesize - 1);
+		size_t read_length;
+
+		WATCHDOG_RESET ();
+
+		if (nand_block_isbad (nand, offset & ~(nand->erasesize - 1))) {
+			printf ("Skipping bad block 0x%08llx\n",
+				offset & ~(nand->erasesize - 1));
+			offset += nand->erasesize - block_offset;
+			continue;
+		}
+
+		if (left_to_read < (nand->erasesize - block_offset))
+			read_length = left_to_read;
+		else
+			read_length = nand->erasesize - block_offset;
+
+		rval = nand_read_on_the_fly(nand, offset, read_length, &read_length, p_buffer,cp_mode);
+		if (rval && rval != -EUCLEAN) {
+			printf ("NAND read from offset %llx failed %d\n",
+				offset, rval);
+			*length -= left_to_read;
+			return rval;
+		}
+
+		left_to_read -= read_length;
+		offset       += read_length;
+		p_buffer     += read_length;
+	}
+
+	return 0;
+}
 #ifdef CONFIG_CMD_NAND_TORTURE
 
 /**
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 150470c24b..b144bb4429 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -72,3 +72,5 @@ obj-$(CONFIG_FSL_MC_ENET) += fsl-mc/
 obj-$(CONFIG_FSL_MC_ENET) += ldpaa_eth/
 obj-$(CONFIG_FSL_MEMAC) += fm/memac_phy.o
 obj-$(CONFIG_VSC9953) += vsc9953.o
+
+obj-y += rtl8168.o
\ No newline at end of file
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index 23cdd714ae..92c042a475 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -80,4 +80,9 @@ config AXP221_ELDO3_VOLT
 	1.2V for the SSD2828 chip (converter of parallel LCD interface
 	into MIPI DSI).
 
+config RTK_POWER
+	bool "RTK boot power control"
+	default 0
+	help
+	  Default config for HW components power-on/off.
 endmenu
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index a2d3c047db..56dd5d51dd 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -20,3 +20,4 @@ obj-$(CONFIG_DIALOG_POWER) += power_dialog.o
 obj-$(CONFIG_POWER_FSL) += power_fsl.o
 obj-$(CONFIG_POWER_I2C) += power_i2c.o
 obj-$(CONFIG_POWER_SPI) += power_spi.o
+obj-$(CONFIG_RTK_POWER) += rtk_power.o
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index c0c4883317..6d9c934d10 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -11,3 +11,4 @@
 #ccflags-y += -DDEBUG
 
 obj-$(CONFIG_PWM_IMX) += pwm-imx.o pwm-imx-util.o
+obj-$(CONFIG_RTD129X_PWM) += pwm-rtd129x.o
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index bd63621e37..3ccc60617f 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -6,3 +6,15 @@ config DM_RTC
 	  then provides the rtc_get()/rtc_set() interface, delegating to
 	  drivers to perform the actual functions. See rtc.h for a
 	  description of the API.
+
+config RTC_RTD1295
+	bool "Enable Realtek RTD1295 RTC driver"
+	help
+	  This config turns on RTC driver in uboot.
+
+config RTK_RTC_BASE_YEAR
+	int "RTC timer base year"
+	default 2016
+	depends on RTC_RTD1295
+	help
+	  Start Year of RTK RTC Timer.
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 3092de1d9c..0e04dfcad2 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -54,3 +54,4 @@ obj-$(CONFIG_RTC_RX8025) += rx8025.o
 obj-$(CONFIG_RTC_S3C24X0) += s3c24x0_rtc.o
 obj-$(CONFIG_SANDBOX) += sandbox_rtc.o
 obj-$(CONFIG_RTC_X1205) += x1205.o
+obj-$(CONFIG_RTC_RTD1295) += rtd1295.o
diff --git a/drivers/serial/ns16550.c b/drivers/serial/ns16550.c
index 9b044a37da..86af185aa4 100644
--- a/drivers/serial/ns16550.c
+++ b/drivers/serial/ns16550.c
@@ -143,6 +143,12 @@ int ns16550_calc_divisor(NS16550_t port, int clock, int baudrate)
 	port->osc_12m_sel = 0;			/* clear if previsouly set */
 #endif
 
+	if((uintptr_t)port == (uintptr_t)UART0_BASE)
+		clock = CONFIG_SYS_NS16550_CLK;
+	else if((uintptr_t)port == (uintptr_t)UART1_BASE)
+		clock = CONFIG_SYS_NS16550_UART1_CLK;
+	/*The HZ of UART0 and UART1 are different.*/
+
 	return calc_divisor(port, clock, baudrate);
 }
 
@@ -151,6 +157,13 @@ static void NS16550_setbrg(NS16550_t com_port, int baud_divisor)
 	serial_out(UART_LCR_BKSE | UART_LCRVAL, &com_port->lcr);
 	serial_out(baud_divisor & 0xff, &com_port->dll);
 	serial_out((baud_divisor >> 8) & 0xff, &com_port->dlm);
+
+#ifdef CONFIG_SYS_NS16550_COM2
+    if((NS16550_t)CONFIG_SYS_NS16550_COM2 == com_port) {
+        serial_out(0x1b, &com_port->lcr);
+        return;
+    }
+#endif
 	serial_out(UART_LCRVAL, &com_port->lcr);
 }
 
diff --git a/drivers/serial/serial.c b/drivers/serial/serial.c
index 699c410d66..85a8d5e89a 100644
--- a/drivers/serial/serial.c
+++ b/drivers/serial/serial.c
@@ -407,6 +407,20 @@ static struct serial_device *get_current(void)
 	return dev;
 }
 
+struct serial_device *get_uart(char uart)
+{
+    struct serial_device *dev;
+
+    dev = get_serial_console(uart);
+
+    return dev;
+}
+
+int serial_init_uart(char uart)
+{
+	return get_uart(uart)->start();
+}
+
 /**
  * serial_init() - Initialize currently selected serial port
  *
diff --git a/drivers/serial/serial_ns16550.c b/drivers/serial/serial_ns16550.c
index 799ef6a667..7e3b48fefd 100644
--- a/drivers/serial/serial_ns16550.c
+++ b/drivers/serial/serial_ns16550.c
@@ -105,7 +105,12 @@ static NS16550_t serial_ports[6] = {
 	static void eserial##port##_puts(const char *s) \
 	{ \
 		serial_puts_dev(port, s); \
-	}
+	} \
+    static void eserial##port##_putc_raw(const char c) \
+    { \
+        serial_putc_raw_dev(port, c); \
+    }
+
 
 /* Serial device descriptor */
 #define INIT_ESERIAL_STRUCTURE(port, __name) {	\
@@ -117,6 +122,7 @@ static NS16550_t serial_ports[6] = {
 	.tstc	= eserial##port##_tstc,		\
 	.putc	= eserial##port##_putc,		\
 	.puts	= eserial##port##_puts,		\
+	.putc_raw = eserial##port##_putc_raw,		\
 }
 
 static void _serial_putc(const char c, const int port)
@@ -225,6 +231,27 @@ struct serial_device eserial6_device =
 	INIT_ESERIAL_STRUCTURE(6, "eserial5");
 #endif
 
+__weak struct serial_device *get_serial_console(char uart)
+{
+	switch(uart){
+#if defined(CONFIG_SYS_NS16550_COM1)
+		case UART0:
+			return &eserial1_device;
+#endif
+#if defined(CONFIG_SYS_NS16550_COM2)
+		case UART1:
+			return &eserial2_device;
+#endif
+#if defined(CONFIG_SYS_NS16550_COM3)
+		case UART2:
+			return &eserial3_device;
+#endif
+		default:
+			printf("ERROR: please assign the configs of CONFIG_SYS_NS16550_COMX\n");
+			return NULL;
+	}
+}
+
 __weak struct serial_device *default_serial_console(void)
 {
 #if CONFIG_CONS_INDEX == 1
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 637ef3d567..2428a21a9a 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -51,12 +51,23 @@ config DM_USB
 
 source "drivers/usb/host/Kconfig"
 
+source "drivers/usb/dwc3/Kconfig"
 source "drivers/usb/emul/Kconfig"
 
+comment "USB peripherals"
+
 config USB_STORAGE
 	bool "USB Mass Storage support"
 	---help---
 	  Say Y here if you want to connect USB mass storage devices to your
 	  board's USB port.
 
+config USB_RTK
+	bool "Realtek USB manager support"
+	---help---
+	  Say Y here if you use realtek SOC USB control EHCI/XHCI on your
+	  board.
+
+source "drivers/usb/gadget/Kconfig"
+
 endif
diff --git a/drivers/usb/dwc3/Makefile b/drivers/usb/dwc3/Makefile
index 02bb216db7..12ca8e5490 100644
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -7,3 +7,4 @@ dwc3-y					+= gadget.o ep0.o
 obj-$(CONFIG_USB_DWC3_OMAP)		+= dwc3-omap.o
 obj-$(CONFIG_USB_DWC3_PHY_OMAP)		+= ti_usb_phy.o
 obj-$(CONFIG_USB_DWC3_PHY_SAMSUNG)	+= samsung_usb_phy.o
+obj-$(CONFIG_USB_DWC3_RTK)		+= dwc3-rtk.o
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index ab3c94e512..7fd424a2ab 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -23,6 +23,10 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 
+#ifdef CONFIG_USB_DWC3_RTK
+#include <usb-phy.h>
+#endif
+
 #include "core.h"
 #include "gadget.h"
 #include "io.h"
@@ -67,6 +71,11 @@ static int dwc3_core_soft_reset(struct dwc3 *dwc)
 
 	mdelay(100);
 
+#ifdef CONFIG_USB_DWC3_RTK
+	usb3_phy_init(dwc->u3phy);
+	mdelay(100);
+#endif
+
 	/* Clear USB3 PHY reset */
 	reg = dwc3_readl(dwc->regs, DWC3_GUSB3PIPECTL(0));
 	reg &= ~DWC3_GUSB3PIPECTL_PHYSOFTRST;
@@ -84,6 +93,11 @@ static int dwc3_core_soft_reset(struct dwc3 *dwc)
 	reg &= ~DWC3_GCTL_CORESOFTRESET;
 	dwc3_writel(dwc->regs, DWC3_GCTL, reg);
 
+#ifdef CONFIG_USB_DWC3_RTK
+	mdelay(100);
+	usb2_phy_init(dwc->u2phy);
+	mdelay(100);
+#endif
 	return 0;
 }
 
@@ -281,7 +295,7 @@ static int dwc3_setup_scratch_buffers(struct dwc3 *dwc)
 	return 0;
 
 err1:
-	dma_unmap_single((void *)dwc->scratch_addr, dwc->nr_scratch *
+	dma_unmap_single((void *)(uintptr_t)dwc->scratch_addr, dwc->nr_scratch *
 			 DWC3_SCRATCHBUF_SIZE, DMA_BIDIRECTIONAL);
 
 err0:
@@ -296,7 +310,7 @@ static void dwc3_free_scratch_buffers(struct dwc3 *dwc)
 	if (!dwc->nr_scratch)
 		return;
 
-	dma_unmap_single((void *)dwc->scratch_addr, dwc->nr_scratch *
+	dma_unmap_single((void *)(uintptr_t)dwc->scratch_addr, dwc->nr_scratch *
 			 DWC3_SCRATCHBUF_SIZE, DMA_BIDIRECTIONAL);
 	kfree(dwc->scratchbuf);
 }
@@ -613,7 +627,7 @@ static void dwc3_core_exit_mode(struct dwc3 *dwc)
 int dwc3_uboot_init(struct dwc3_device *dwc3_dev)
 {
 	struct dwc3		*dwc;
-	struct device		*dev;
+	struct device		*dev = NULL;
 	u8			lpm_nyet_threshold;
 	u8			tx_de_emphasis;
 	u8			hird_threshold;
@@ -629,7 +643,13 @@ int dwc3_uboot_init(struct dwc3_device *dwc3_dev)
 	dwc = PTR_ALIGN(mem, DWC3_ALIGN_MASK + 1);
 	dwc->mem = mem;
 
+#ifdef CONFIG_USB_DWC3_RTK
+#define DWC3_RTK_GLOBALS_REGS_START		0x8100
+	dwc->regs	= (void *)((uintptr_t)(unsigned int)
+		    dwc3_dev->base + DWC3_RTK_GLOBALS_REGS_START);
+#else
 	dwc->regs	= (int *)(dwc3_dev->base + DWC3_GLOBALS_REGS_START);
+#endif
 
 	/* default to highest possible threshold */
 	lpm_nyet_threshold = 0xff;
@@ -697,6 +717,11 @@ int dwc3_uboot_init(struct dwc3_device *dwc3_dev)
 	if (dwc->dr_mode == USB_DR_MODE_UNKNOWN)
 		dwc->dr_mode = USB_DR_MODE_OTG;
 
+#ifdef CONFIG_USB_DWC3_RTK
+	dwc->u2phy = dwc3_dev->u2phy;
+	dwc->u3phy = dwc3_dev->u3phy;
+#endif
+
 	ret = dwc3_core_init(dwc);
 	if (ret) {
 		dev_err(dev, "failed to initialize core\n");
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 72d2fcdd3f..2b3e8da653 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -473,6 +473,11 @@ enum dwc3_phy {
 	DWC3_PHY_USB2,
 };
 
+#ifdef CONFIG_USB_DWC3_RTK
+struct usb2_phy;
+struct usb3_phy;
+#endif
+
 enum dwc3_ep0_next {
 	DWC3_EP0_UNKNOWN = 0,
 	DWC3_EP0_COMPLETE,
@@ -780,6 +785,11 @@ struct dwc3 {
 	struct dentry		*root;
 	struct debugfs_regset32	*regset;
 
+#ifdef CONFIG_USB_DWC3_RTK
+	struct usb2_phy *u2phy;
+	struct usb3_phy *u3phy;
+#endif
+
 	u8			test_mode;
 	u8			test_mode_nr;
 	u8			lpm_nyet_threshold;
diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c
index aba614fb4e..d388f777dc 100644
--- a/drivers/usb/dwc3/ep0.c
+++ b/drivers/usb/dwc3/ep0.c
@@ -82,7 +82,7 @@ static int dwc3_ep0_start_trans(struct dwc3 *dwc, u8 epnum, dma_addr_t buf_dma,
 				| DWC3_TRB_CTRL_LST);
 
 	dwc3_flush_cache((int)buf_dma, len);
-	dwc3_flush_cache((int)trb, sizeof(*trb));
+	dwc3_flush_cache((int)(uintptr_t)trb, sizeof(*trb));
 
 	if (chain)
 		return 0;
@@ -790,7 +790,7 @@ static void dwc3_ep0_complete_data(struct dwc3 *dwc,
 	if (!r)
 		return;
 
-	dwc3_flush_cache((int)trb, sizeof(*trb));
+	dwc3_flush_cache((int)(uintptr_t)trb, sizeof(*trb));
 
 	status = DWC3_TRB_SIZE_TRBSTS(trb->size);
 	if (status == DWC3_TRBSTS_SETUP_PENDING) {
@@ -821,7 +821,7 @@ static void dwc3_ep0_complete_data(struct dwc3 *dwc,
 			ur->actual += transferred;
 
 			trb++;
-			dwc3_flush_cache((int)trb, sizeof(*trb));
+			dwc3_flush_cache((int)(uintptr_t)trb, sizeof(*trb));
 			length = trb->size & DWC3_TRB_SIZE_MASK;
 
 			ep0->free_slot = 0;
@@ -831,7 +831,7 @@ static void dwc3_ep0_complete_data(struct dwc3 *dwc,
 					maxp);
 		transferred = min_t(u32, ur->length - transferred,
 				    transfer_size - length);
-		dwc3_flush_cache((int)dwc->ep0_bounce, DWC3_EP0_BOUNCE_SIZE);
+		dwc3_flush_cache((int)(uintptr_t)dwc->ep0_bounce, DWC3_EP0_BOUNCE_SIZE);
 		memcpy(buf, dwc->ep0_bounce, transferred);
 	} else {
 		transferred = ur->length - length;
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index f3d649a5ee..a44cfec6e1 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -772,7 +772,7 @@ static void dwc3_prepare_one_trb(struct dwc3_ep *dep,
 	trb->ctrl |= DWC3_TRB_CTRL_HWO;
 
 	dwc3_flush_cache((int)dma, length);
-	dwc3_flush_cache((int)trb, sizeof(*trb));
+	dwc3_flush_cache((int)(uintptr_t)trb, sizeof(*trb));
 }
 
 /*
@@ -1769,7 +1769,7 @@ static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,
 	slot %= DWC3_TRB_NUM;
 	trb = &dep->trb_pool[slot];
 
-	dwc3_flush_cache((int)trb, sizeof(*trb));
+	dwc3_flush_cache((int)(uintptr_t)trb, sizeof(*trb));
 	__dwc3_cleanup_done_trbs(dwc, dep, req, trb, event, status);
 	dwc3_gadget_giveback(dep, req, status);
 
@@ -2670,7 +2670,7 @@ void dwc3_gadget_uboot_handle_interrupt(struct dwc3 *dwc)
 
 		for (i = 0; i < dwc->num_event_buffers; i++) {
 			evt = dwc->ev_buffs[i];
-			dwc3_flush_cache((int)evt->buf, evt->length);
+			dwc3_flush_cache((int)(uintptr_t)evt->buf, evt->length);
 		}
 
 		dwc3_thread_interrupt(0, dwc);
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 70bb550fa4..bd89b43288 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -19,7 +19,7 @@ obj-$(CONFIG_THOR_FUNCTION) += f_thor.o
 obj-$(CONFIG_USBDOWNLOAD_GADGET) += g_dnl.o
 obj-$(CONFIG_DFU_FUNCTION) += f_dfu.o
 obj-$(CONFIG_USB_GADGET_MASS_STORAGE) += f_mass_storage.o
-obj-$(CONFIG_CMD_FASTBOOT) += f_fastboot.o
+obj-$(CONFIG_USB_FUNCTION_FASTBOOT) += f_fastboot.o
 endif
 ifdef CONFIG_USB_ETHER
 obj-y += ether.o
diff --git a/drivers/usb/gadget/f_fastboot.c b/drivers/usb/gadget/f_fastboot.c
index 206b6d17ae..8a0174df9b 100644
--- a/drivers/usb/gadget/f_fastboot.c
+++ b/drivers/usb/gadget/f_fastboot.c
@@ -322,6 +322,71 @@ static int fastboot_tx_write_str(const char *buffer)
 	return fastboot_tx_write(buffer, strlen(buffer));
 }
 
+#ifdef CONFIG_FASTBOOT_RTK
+static void fastboot_ack_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	int status = req->status;
+	if (!status) {
+		if (req->buf)
+			free(req->buf);
+		usb_ep_free_request(ep, req);
+		return;
+	}
+	printf("status: %d ep '%s' trans: %d\n", status, ep->name, req->actual);
+}
+
+void fastboot_ack(char *code, char *reason)
+{
+	char response[RESPONSE_LEN] = {'\0'};
+	struct usb_ep *ep = fastboot_func->in_ep;
+	struct usb_request *req;
+	int ret;
+
+	if (reason == 0)
+		reason = "";
+	printf("fastboot_ack(): code %s, reason %s\n", code, reason);
+
+	sprintf(response, "%s%s", code, reason);
+
+	req = usb_ep_alloc_request(ep, 0);
+	if (!req) {
+		printf("%s: usb_ep_alloc_request fail\n", __func__);
+		return;
+	}
+
+	req->length = EP_BUFFER_SIZE;
+	req->buf = memalign(CONFIG_SYS_CACHELINE_SIZE, EP_BUFFER_SIZE);
+	if (!req->buf) {
+		printf("%s: req alloc buf fail\n", __func__);
+		usb_ep_free_request(ep, req);
+		return;
+	}
+
+	memset(req->buf, 0, req->length);
+
+	req->complete = fastboot_ack_complete;
+
+	req->length = strlen(response);
+	memcpy(req->buf, response, req->length);
+
+	ret = usb_ep_queue(ep, req, 0);
+	if (ret)
+		printf("Error %d on queue\n", ret);
+}
+
+void fastboot_okay_and_complete(
+	    void (*complete)(struct usb_ep *ep, struct usb_request *req))
+{
+	fastboot_func->in_req->complete = complete;
+	fastboot_tx_write_str("OKAY");
+}
+
+extern int cmd_oem_rtk(char *cmd);
+extern int cmd_continue_rtk(void);
+extern int cmd_boot_rtk(const char *arg, void *data, unsigned sz);
+extern int cmd_flash_rtk(const char *arg, void *data, unsigned sz);
+#endif
+
 static void compl_do_reset(struct usb_ep *ep, struct usb_request *req)
 {
 	do_reset(NULL, 0, 0, NULL);
@@ -511,6 +576,13 @@ static void do_bootm_on_complete(struct usb_ep *ep, struct usb_request *req)
 
 static void cb_boot(struct usb_ep *ep, struct usb_request *req)
 {
+#ifdef CONFIG_FASTBOOT_RTK
+	char *cmd = req->buf;
+
+	if (cmd_boot_rtk(cmd,
+		    (void *)CONFIG_USB_FASTBOOT_BUF_ADDR, download_bytes))
+		return;
+#endif
 	fastboot_func->in_req->complete = do_bootm_on_complete;
 	fastboot_tx_write_str("OKAY");
 }
@@ -518,6 +590,9 @@ static void cb_boot(struct usb_ep *ep, struct usb_request *req)
 static void do_exit_on_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	g_dnl_trigger_detach();
+#ifdef CONFIG_FASTBOOT_RTK
+	cmd_continue_rtk();
+#endif
 }
 
 static void cb_continue(struct usb_ep *ep, struct usb_request *req)
@@ -532,6 +607,13 @@ static void cb_flash(struct usb_ep *ep, struct usb_request *req)
 	char *cmd = req->buf;
 	char response[RESPONSE_LEN];
 
+#ifdef CONFIG_FASTBOOT_RTK
+	if (cmd_flash_rtk(cmd + strlen("flash "),
+		    (void *)CONFIG_USB_FASTBOOT_BUF_ADDR, download_bytes)) {
+		return;
+	}
+#endif
+
 	strsep(&cmd, ":");
 	if (!cmd) {
 		error("missing partition name\n");
@@ -551,6 +633,12 @@ static void cb_flash(struct usb_ep *ep, struct usb_request *req)
 static void cb_oem(struct usb_ep *ep, struct usb_request *req)
 {
 	char *cmd = req->buf;
+
+#ifdef CONFIG_FASTBOOT_RTK
+	if (cmd_oem_rtk(cmd + 4)) {
+	} else
+#endif
+#ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
 #ifdef CONFIG_FASTBOOT_FLASH
 	if (strncmp("format", cmd + 4, 6) == 0) {
 		char cmdbuf[32];
@@ -561,6 +649,7 @@ static void cb_oem(struct usb_ep *ep, struct usb_request *req)
                 else
 			fastboot_tx_write_str("OKAY");
 	} else
+#endif
 #endif
 	if (strncmp("unlock", cmd + 4, 8) == 0) {
 		fastboot_tx_write_str("FAILnot implemented");
diff --git a/drivers/usb/gadget/udc/Makefile b/drivers/usb/gadget/udc/Makefile
index 12380f4e4e..650ddd508d 100644
--- a/drivers/usb/gadget/udc/Makefile
+++ b/drivers/usb/gadget/udc/Makefile
@@ -2,3 +2,4 @@
 # USB peripheral controller drivers
 #
 obj-$(CONFIG_USB_DWC3_GADGET)	+= udc-core.o
+obj-$(CONFIG_USB_GADGET_RTK)	+= udc-rtk.o
diff --git a/drivers/usb/gadget/udc/udc-core.c b/drivers/usb/gadget/udc/udc-core.c
index 875e998a82..326757b547 100644
--- a/drivers/usb/gadget/udc/udc-core.c
+++ b/drivers/usb/gadget/udc/udc-core.c
@@ -65,7 +65,7 @@ void usb_gadget_unmap_request(struct usb_gadget *gadget,
 	if (req->length == 0)
 		return;
 
-	dma_unmap_single((void *)req->dma, req->length,
+	dma_unmap_single((void *)(uintptr_t)req->dma, req->length,
 			 is_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 }
 EXPORT_SYMBOL_GPL(usb_gadget_unmap_request);
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 8705c7c44c..4a219ff909 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -24,6 +24,12 @@ config USB_XHCI_UNIPHIER
 	---help---
 	  Enables support for the on-chip xHCI controller on UniPhier SoCs.
 
+config USB_XHCI_RTK
+	bool "Support for Realtek on-chip xHCI USB controller"
+	default y
+	---help---
+	  Enables support for the on-chip xHCI controller on Realtek SoCs.
+
 endif
 
 config USB_EHCI_HCD
@@ -59,4 +65,10 @@ config USB_EHCI_UNIPHIER
 	---help---
 	  Enables support for the on-chip EHCI controller on UniPhier SoCs.
 
+config USB_EHCI_RTK
+	bool "Support for Realtek on-chip EHCI USB controller"
+	default y
+	---help---
+	  Enables support for the on-chip EHCI controller on Realtek SoCs.
+
 endif
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 4d35d3e5fe..d08da3c7d0 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -10,6 +10,8 @@ obj-$(CONFIG_CMD_USB) += usb-uclass.o
 obj-$(CONFIG_SANDBOX) += usb-sandbox.o
 endif
 
+obj-$(CONFIG_USB_RTK) += host-rtk.o
+
 # ohci
 obj-$(CONFIG_USB_OHCI_NEW) += ohci-hcd.o
 obj-$(CONFIG_USB_ATMEL) += ohci-at91.o
@@ -25,6 +27,7 @@ obj-$(CONFIG_USB_OHCI_SUNXI) += ohci-sunxi.o
 obj-$(CONFIG_USB_EHCI) += ehci-hcd.o
 obj-$(CONFIG_USB_EHCI_ARMADA100) += ehci-armada100.o utmi-armada100.o
 obj-$(CONFIG_USB_EHCI_ATMEL) += ehci-atmel.o
+obj-$(CONFIG_USB_EHCI_RTK) += ehci-rtk.o
 ifdef CONFIG_MPC512X
 obj-$(CONFIG_USB_EHCI_FSL) += ehci-mpc512x.o
 else
@@ -56,6 +59,7 @@ obj-$(CONFIG_USB_XHCI_EXYNOS) += xhci-exynos5.o
 obj-$(CONFIG_USB_XHCI_OMAP) += xhci-omap.o
 obj-$(CONFIG_USB_XHCI_PCI) += xhci-pci.o
 obj-$(CONFIG_USB_XHCI_UNIPHIER) += xhci-uniphier.o
+obj-$(CONFIG_USB_XHCI_RTK) += xhci-plat.o
 
 # designware
 obj-$(CONFIG_USB_DWC2) += dwc2.o
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index bf02221c9f..6b49bc72b1 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1135,13 +1135,15 @@ static int ehci_common_init(struct ehci_ctrl *ctrl, uint tweaks)
 }
 
 #ifndef CONFIG_DM_USB
-int usb_lowlevel_stop(int index)
+//int usb_lowlevel_stop(int index)
+int ehci_lowlevel_stop(int index)
 {
-	ehci_shutdown(&ehcic[index]);
+	//ehci_shutdown(&ehcic[index]);
 	return ehci_hcd_stop(index);
 }
 
-int usb_lowlevel_init(int index, enum usb_init_type init, void **controller)
+//int usb_lowlevel_init(int index, enum usb_init_type init, void **controller)
+int ehci_lowlevel_init(int index, enum usb_init_type init, void **controller)
 {
 	struct ehci_ctrl *ctrl = &ehcic[index];
 	uint tweaks = 0;
@@ -1176,6 +1178,7 @@ int usb_lowlevel_init(int index, enum usb_init_type init, void **controller)
 		return rc;
 
 	ctrl->rootdev = 0;
+	ctrl->ctrl_type = CTRL_TYPE_EHCI;
 done:
 	*controller = &ehcic[index];
 	return 0;
@@ -1554,19 +1557,22 @@ static int _ehci_submit_int_msg(struct usb_device *dev, unsigned long pipe,
 }
 
 #ifndef CONFIG_DM_USB
-int submit_bulk_msg(struct usb_device *dev, unsigned long pipe,
+//int submit_bulk_msg(struct usb_device *dev, unsigned long pipe,
+int ehci_submit_bulk_msg(struct usb_device *dev, unsigned long pipe,
 			    void *buffer, int length)
 {
 	return _ehci_submit_bulk_msg(dev, pipe, buffer, length);
 }
 
-int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+//int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+int ehci_submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 		   int length, struct devrequest *setup)
 {
 	return _ehci_submit_control_msg(dev, pipe, buffer, length, setup);
 }
 
-int submit_int_msg(struct usb_device *dev, unsigned long pipe,
+//int submit_int_msg(struct usb_device *dev, unsigned long pipe,
+int ehci_submit_int_msg(struct usb_device *dev, unsigned long pipe,
 		   void *buffer, int length, int interval)
 {
 	return _ehci_submit_int_msg(dev, pipe, buffer, length, interval);
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 774282d287..5dbabcef7e 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -255,6 +255,7 @@ struct ehci_ops {
 };
 
 struct ehci_ctrl {
+	int ctrl_type;
 	struct ehci_hccr *hccr;	/* R/O registers, not need for volatile */
 	struct ehci_hcor *hcor;
 	int rootdev;
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 37444526f7..f826bb5eb5 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -13,7 +13,6 @@
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
-
 #include <common.h>
 #include <dm.h>
 #include <asm/byteorder.h>
@@ -24,6 +23,8 @@
 
 #include "xhci.h"
 
+//#define XHCI_USE_MALLOC_NONCACHE
+
 #define CACHELINE_SIZE		CONFIG_SYS_CACHELINE_SIZE
 /**
  * flushes the address passed till the length
@@ -35,7 +36,7 @@
 void xhci_flush_cache(uintptr_t addr, u32 len)
 {
 	BUG_ON((void *)addr == NULL || len == 0);
-
+	wmb(); // add by cfyeh
 	flush_dcache_range(addr & ~(CACHELINE_SIZE - 1),
 				ALIGN(addr + len, CACHELINE_SIZE));
 }
@@ -51,8 +52,14 @@ void xhci_inval_cache(uintptr_t addr, u32 len)
 {
 	BUG_ON((void *)addr == NULL || len == 0);
 
+	wmb(); // add by cfyeh
+
+#if 0 // add by cfyeh
+	flush_dcache_all();
+#else
 	invalidate_dcache_range(addr & ~(CACHELINE_SIZE - 1),
 				ALIGN(addr + len, CACHELINE_SIZE));
+#endif
 }
 
 
@@ -64,9 +71,14 @@ void xhci_inval_cache(uintptr_t addr, u32 len)
  */
 static void xhci_segment_free(struct xhci_segment *seg)
 {
+#ifdef XHCI_USE_MALLOC_NONCACHE
+	if (!mem_malloc_noncache_check(seg->trbs))
+		free(seg->trbs);
+	seg->trbs = NULL;
+#else
 	free(seg->trbs);
 	seg->trbs = NULL;
-
+#endif // XHCI_USE_MALLOC_NONCACHE
 	free(seg);
 }
 
@@ -103,7 +115,12 @@ static void xhci_ring_free(struct xhci_ring *ring)
  */
 static void xhci_free_container_ctx(struct xhci_container_ctx *ctx)
 {
+#ifdef XHCI_USE_MALLOC_NONCACHE
+	if (!mem_malloc_noncache_check(ctx->bytes))
+		free(ctx->bytes);
+#else
 	free(ctx->bytes);
+#endif // XHCI_USE_MALLOC_NONCACHE
 	free(ctx);
 }
 
@@ -145,6 +162,32 @@ static void xhci_free_virt_devices(struct xhci_ctrl *ctrl)
 	}
 }
 
+void xhci_free_virt_device(struct xhci_ctrl *ctrl, int slot_id)
+{
+	struct xhci_virt_device *virt_dev;
+	int i;
+
+	if (slot_id == 0 || !ctrl->devs[slot_id])
+		return;
+
+	virt_dev = ctrl->devs[slot_id];
+
+	ctrl->dcbaa->dev_context_ptrs[slot_id] = 0;
+
+	for (i = 0; i < 31; ++i)
+		if (virt_dev->eps[i].ring)
+			xhci_ring_free(virt_dev->eps[i].ring);
+
+	if (virt_dev->in_ctx)
+		xhci_free_container_ctx(virt_dev->in_ctx);
+	if (virt_dev->out_ctx)
+		xhci_free_container_ctx(virt_dev->out_ctx);
+
+	free(virt_dev);
+	/* make sure we are pointing to NULL */
+	ctrl->devs[slot_id] = NULL;
+}
+
 /**
  * frees all the memory allocated
  *
@@ -153,12 +196,19 @@ static void xhci_free_virt_devices(struct xhci_ctrl *ctrl)
  */
 void xhci_cleanup(struct xhci_ctrl *ctrl)
 {
+	debug("// 1 %s ctrl %p\n", __func__, ctrl);
 	xhci_ring_free(ctrl->event_ring);
 	xhci_ring_free(ctrl->cmd_ring);
 	xhci_free_virt_devices(ctrl);
 	free(ctrl->erst.entries);
+#ifdef XHCI_USE_MALLOC_NONCACHE
+	if (!mem_malloc_noncache_check(ctrl->dcbaa))
+		free(ctrl->dcbaa);
+#else
 	free(ctrl->dcbaa);
+#endif // XHCI_USE_MALLOC_NONCACHE
 	memset(ctrl, '\0', sizeof(struct xhci_ctrl));
+	debug("// 2 %s ctrl %p\n", __func__, ctrl);
 }
 
 /**
@@ -170,17 +220,41 @@ void xhci_cleanup(struct xhci_ctrl *ctrl)
 static void *xhci_malloc(unsigned int size)
 {
 	void *ptr;
+#if 0 // add by cfyeh
 	size_t cacheline_size = max(XHCI_ALIGNMENT, CACHELINE_SIZE);
 
 	ptr = memalign(cacheline_size, ALIGN(size, cacheline_size));
+#else
+	ptr = memalign(0x400, ALIGN(size, 0x400));
+#endif // add by cfyeh
 	BUG_ON(!ptr);
 	memset(ptr, '\0', size);
 
-	xhci_flush_cache((uintptr_t)ptr, size);
+	xhci_flush_cache((uint32_t)(uintptr_t)ptr, size);
 
 	return ptr;
 }
 
+#ifdef XHCI_USE_MALLOC_NONCACHE
+/**
+ * Malloc the aligned noncache memory
+ *
+ * @param size	size of memory to be allocated
+ * @return allocates the memory and returns the aligned pointer
+ */
+static void *xhci_malloc_noncache(unsigned int size)
+{
+	void *ptr;
+	size_t cacheline_size = max(XHCI_ALIGNMENT, CACHELINE_SIZE);
+
+	ptr = malloc_noncache_align(ALIGN(size, cacheline_size), cacheline_size);
+	BUG_ON(!ptr);
+	memset(ptr, '\0', size);
+
+	return ptr;
+}
+#endif // XHCI_USE_MALLOC_NONCACHE
+
 /**
  * Make the prev segment point to the next segment.
  * Change the last TRB in the prev segment to be a Link TRB which points to the
@@ -255,10 +329,14 @@ static struct xhci_segment *xhci_segment_alloc(void)
 {
 	struct xhci_segment *seg;
 
-	seg = (struct xhci_segment *)malloc(sizeof(struct xhci_segment));
+	seg = (struct xhci_segment *)xhci_malloc(sizeof(struct xhci_segment));
 	BUG_ON(!seg);
 
+#ifdef XHCI_USE_MALLOC_NONCACHE
+	seg->trbs = (union xhci_trb *)xhci_malloc_noncache(SEGMENT_SIZE);
+#else
 	seg->trbs = (union xhci_trb *)xhci_malloc(SEGMENT_SIZE);
+#endif // XHCI_USE_MALLOC_NONCACHE
 
 	seg->next = NULL;
 
@@ -285,7 +363,7 @@ struct xhci_ring *xhci_ring_alloc(unsigned int num_segs, bool link_trbs)
 	struct xhci_ring *ring;
 	struct xhci_segment *prev;
 
-	ring = (struct xhci_ring *)malloc(sizeof(struct xhci_ring));
+	ring = (struct xhci_ring *)xhci_malloc(sizeof(struct xhci_ring));
 	BUG_ON(!ring);
 
 	if (num_segs == 0)
@@ -332,17 +410,22 @@ static struct xhci_container_ctx
 	struct xhci_container_ctx *ctx;
 
 	ctx = (struct xhci_container_ctx *)
-		malloc(sizeof(struct xhci_container_ctx));
+		xhci_malloc(sizeof(struct xhci_container_ctx));
 	BUG_ON(!ctx);
 
 	BUG_ON((type != XHCI_CTX_TYPE_DEVICE) && (type != XHCI_CTX_TYPE_INPUT));
 	ctx->type = type;
 	ctx->size = (MAX_EP_CTX_NUM + 1) *
-			CTX_SIZE(readl(&ctrl->hccr->cr_hccparams));
+			CTX_SIZE(xhci_readl(&ctrl->hccr->cr_hccparams));
 	if (type == XHCI_CTX_TYPE_INPUT)
-		ctx->size += CTX_SIZE(readl(&ctrl->hccr->cr_hccparams));
+		ctx->size += CTX_SIZE(xhci_readl(&ctrl->hccr->cr_hccparams));
 
+#ifdef XHCI_USE_MALLOC_NONCACHE
+	ctx->bytes = (u8 *)xhci_malloc_noncache(ctx->size);
+#else
 	ctx->bytes = (u8 *)xhci_malloc(ctx->size);
+#endif // XHCI_USE_MALLOC_NONCACHE
+
 
 	return ctx;
 }
@@ -353,11 +436,12 @@ static struct xhci_container_ctx
  * @param udev	pointer to USB deivce structure
  * @return 0 on success else -1 on failure
  */
-int xhci_alloc_virt_device(struct xhci_ctrl *ctrl, unsigned int slot_id)
+int xhci_alloc_virt_device(struct usb_device *udev)
 {
 	u64 byte_64 = 0;
+	unsigned int slot_id = udev->slot_id;
 	struct xhci_virt_device *virt_dev;
-
+	struct xhci_ctrl *ctrl = udev->controller;
 	/* Slot ID 0 is reserved */
 	if (ctrl->devs[slot_id]) {
 		printf("Virt dev for slot[%d] already allocated\n", slot_id);
@@ -365,7 +449,7 @@ int xhci_alloc_virt_device(struct xhci_ctrl *ctrl, unsigned int slot_id)
 	}
 
 	ctrl->devs[slot_id] = (struct xhci_virt_device *)
-					malloc(sizeof(struct xhci_virt_device));
+					xhci_malloc(sizeof(struct xhci_virt_device));
 
 	if (!ctrl->devs[slot_id]) {
 		puts("Failed to allocate virtual device\n");
@@ -399,8 +483,8 @@ int xhci_alloc_virt_device(struct xhci_ctrl *ctrl, unsigned int slot_id)
 	/* Point to output device context in dcbaa. */
 	ctrl->dcbaa->dev_context_ptrs[slot_id] = byte_64;
 
-	xhci_flush_cache((uintptr_t)&ctrl->dcbaa->dev_context_ptrs[slot_id],
-			 sizeof(__le64));
+	xhci_flush_cache((uint32_t)(uintptr_t)&ctrl->dcbaa->dev_context_ptrs[slot_id],
+							sizeof(__le64));
 	return 0;
 }
 
@@ -424,14 +508,21 @@ int xhci_mem_init(struct xhci_ctrl *ctrl, struct xhci_hccr *hccr,
 	struct xhci_segment *seg;
 
 	/* DCBAA initialization */
+#ifdef XHCI_USE_MALLOC_NONCACHE
+	ctrl->dcbaa = (struct xhci_device_context_array *)
+			xhci_malloc_noncache(sizeof(struct xhci_device_context_array));
+#else
 	ctrl->dcbaa = (struct xhci_device_context_array *)
 			xhci_malloc(sizeof(struct xhci_device_context_array));
+#endif // XHCI_USE_MALLOC_NONCACHE
 	if (ctrl->dcbaa == NULL) {
 		puts("unable to allocate DCBA\n");
 		return -ENOMEM;
 	}
 
 	val_64 = (uintptr_t)ctrl->dcbaa;
+
+	
 	/* Set the pointer in DCBAA register */
 	xhci_writeq(&hcor->or_dcbaap, val_64);
 
@@ -444,6 +535,7 @@ int xhci_mem_init(struct xhci_ctrl *ctrl, struct xhci_hccr *hccr,
 	val_64 = (val_64 & (u64) CMD_RING_RSVD_BITS) |
 		(trb_64 & (u64) ~CMD_RING_RSVD_BITS) |
 		ctrl->cmd_ring->cycle_state;
+	debug("&hcor->or_crcr = 0x%08x val_64 = %lx\n", (unsigned int)(uintptr_t)&hcor->or_crcr, (unsigned long)val_64);
 	xhci_writeq(&hcor->or_crcr, val_64);
 
 	/* write the address of db register */
@@ -458,6 +550,9 @@ int xhci_mem_init(struct xhci_ctrl *ctrl, struct xhci_hccr *hccr,
 
 	/* writting the address of ir_set structure */
 	ctrl->ir_set = &ctrl->run_regs->ir_set[0];
+	
+	debug("The address of ctrl->ir_set is %p\n", ctrl->ir_set);
+	debug("The address of ctrl->ir_set is %p\n", &ctrl->ir_set);
 
 	/* Event ring does not maintain link TRB */
 	ctrl->event_ring = xhci_ring_alloc(ERST_NUM_SEGS, false);
@@ -472,15 +567,17 @@ int xhci_mem_init(struct xhci_ctrl *ctrl, struct xhci_hccr *hccr,
 		trb_64 = 0;
 		trb_64 = (uintptr_t)seg->trbs;
 		struct xhci_erst_entry *entry = &ctrl->erst.entries[val];
+		debug("&entry->seg_addr = 0x%08x trb_64 = %lx\n", (unsigned int)(uintptr_t)&entry->seg_addr, (unsigned long)trb_64);
 		xhci_writeq(&entry->seg_addr, trb_64);
 		entry->seg_size = cpu_to_le32(TRBS_PER_SEGMENT);
 		entry->rsvd = 0;
 		seg = seg->next;
 	}
-	xhci_flush_cache((uintptr_t)ctrl->erst.entries,
+	xhci_flush_cache((uint32_t)(uintptr_t)ctrl->erst.entries,
 			 ERST_NUM_SEGS * sizeof(struct xhci_erst_entry));
 
 	deq = (unsigned long)ctrl->event_ring->dequeue;
+	debug("@@@@@@@@@ deq %lx\n", deq);
 
 	/* Update HC event ring dequeue pointer */
 	xhci_writeq(&ctrl->ir_set->erst_dequeue,
@@ -538,9 +635,12 @@ struct xhci_slot_ctx *xhci_get_slot_ctx(struct xhci_ctrl *ctrl,
 {
 	if (ctx->type == XHCI_CTX_TYPE_DEVICE)
 		return (struct xhci_slot_ctx *)ctx->bytes;
-
+	
+	debug("%s CTX_SIZE %x\n", __func__, 
+		CTX_SIZE(xhci_readl(&ctrl->hccr->cr_hccparams)));
+		
 	return (struct xhci_slot_ctx *)
-		(ctx->bytes + CTX_SIZE(readl(&ctrl->hccr->cr_hccparams)));
+		(ctx->bytes + CTX_SIZE(xhci_readl(&ctrl->hccr->cr_hccparams)));
 }
 
 /**
@@ -562,7 +662,7 @@ struct xhci_ep_ctx *xhci_get_ep_ctx(struct xhci_ctrl *ctrl,
 
 	return (struct xhci_ep_ctx *)
 		(ctx->bytes +
-		(ep_index * CTX_SIZE(readl(&ctrl->hccr->cr_hccparams))));
+		(ep_index * CTX_SIZE(xhci_readl(&ctrl->hccr->cr_hccparams))));
 }
 
 /**
@@ -626,16 +726,17 @@ void xhci_slot_copy(struct xhci_ctrl *ctrl, struct xhci_container_ctx *in_ctx,
  * @param udev pointer to the Device Data Structure
  * @return returns negative value on failure else 0 on success
  */
-void xhci_setup_addressable_virt_dev(struct xhci_ctrl *ctrl, int slot_id,
-				     int speed, int hop_portnr)
+void xhci_setup_addressable_virt_dev(struct usb_device *udev)
 {
+	struct usb_device *hop = udev;
 	struct xhci_virt_device *virt_dev;
 	struct xhci_ep_ctx *ep0_ctx;
 	struct xhci_slot_ctx *slot_ctx;
 	u32 port_num = 0;
 	u64 trb_64 = 0;
+	struct xhci_ctrl *ctrl = udev->controller;
 
-	virt_dev = ctrl->devs[slot_id];
+	virt_dev = ctrl->devs[udev->slot_id];
 
 	BUG_ON(!virt_dev);
 
@@ -643,10 +744,11 @@ void xhci_setup_addressable_virt_dev(struct xhci_ctrl *ctrl, int slot_id,
 	ep0_ctx = xhci_get_ep_ctx(ctrl, virt_dev->in_ctx, 0);
 	slot_ctx = xhci_get_slot_ctx(ctrl, virt_dev->in_ctx);
 
+
 	/* Only the control endpoint is valid - one endpoint context */
-	slot_ctx->dev_info |= cpu_to_le32(LAST_CTX(1) | 0);
+	slot_ctx->dev_info |= cpu_to_le32(LAST_CTX(1) | udev->route/*0*/); //hcy modified for udev->route 
 
-	switch (speed) {
+	switch (udev->speed) {
 	case USB_SPEED_SUPER:
 		slot_ctx->dev_info |= cpu_to_le32(SLOT_SPEED_SS);
 		break;
@@ -664,8 +766,11 @@ void xhci_setup_addressable_virt_dev(struct xhci_ctrl *ctrl, int slot_id,
 		BUG();
 	}
 
-	port_num = hop_portnr;
-	debug("port_num = %d\n", port_num);
+	/* Extract the root hub port number */
+	if (hop->parent)
+		while (hop->parent->parent)
+			hop = hop->parent;
+	port_num = hop->portnr;
 
 	slot_ctx->dev_info2 |=
 			cpu_to_le32(((port_num & ROOT_HUB_PORT_MASK) <<
@@ -674,9 +779,8 @@ void xhci_setup_addressable_virt_dev(struct xhci_ctrl *ctrl, int slot_id,
 	/* Step 4 - ring already allocated */
 	/* Step 5 */
 	ep0_ctx->ep_info2 = cpu_to_le32(CTRL_EP << EP_TYPE_SHIFT);
-	debug("SPEED = %d\n", speed);
 
-	switch (speed) {
+	switch (udev->speed) {
 	case USB_SPEED_SUPER:
 		ep0_ctx->ep_info2 |= cpu_to_le32(((512 & MAX_PACKET_MASK) <<
 					MAX_PACKET_SHIFT));
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 5a1391fbe3..aa9add9d46 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -13,7 +13,6 @@
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
-
 #include <common.h>
 #include <asm/byteorder.h>
 #include <usb.h>
@@ -191,10 +190,24 @@ static struct xhci_generic_trb *queue_trb(struct xhci_ctrl *ctrl,
 	for (i = 0; i < 4; i++)
 		trb->field[i] = cpu_to_le32(trb_fields[i]);
 
+			debug("XHCI queue TRB 111 %p - "
+			"(%08x %08x %08x %08x)\n", trb,
+			le32_to_cpu(trb->field[0]),
+			le32_to_cpu(trb->field[1]),
+			le32_to_cpu(trb->field[2]),
+			le32_to_cpu(trb->field[3]));
+			
 	xhci_flush_cache((uintptr_t)trb, sizeof(struct xhci_generic_trb));
 
 	inc_enq(ctrl, ring, more_trbs_coming);
 
+			debug("XHCI queue TRB 222 - "
+			"(%08x %08x %08x %08x)\n",
+			le32_to_cpu(trb->field[0]),
+			le32_to_cpu(trb->field[1]),
+			le32_to_cpu(trb->field[2]),
+			le32_to_cpu(trb->field[3]));
+			
 	return trb;
 }
 
@@ -225,7 +238,12 @@ static int prepare_ring(struct xhci_ctrl *ctrl, struct xhci_ring *ep_ring,
 		puts("WARN waiting for error on ep to be cleared\n");
 		return -EINVAL;
 	case EP_STATE_HALTED:
+#if 0 // add by cfyeh
 		puts("WARN halted endpoint, queueing URB anyway.\n");
+#else
+		puts("WARN halted endpoint, just return anyway.\n");
+		return -EINVAL;
+#endif
 	case EP_STATE_STOPPED:
 	case EP_STATE_RUNNING:
 		debug("EP STATE RUNNING.\n");
@@ -280,14 +298,97 @@ void xhci_queue_command(struct xhci_ctrl *ctrl, u8 *ptr, u32 slot_id,
 	fields[0] = lower_32_bits(val_64);
 	fields[1] = upper_32_bits(val_64);
 	fields[2] = 0;
-	fields[3] = TRB_TYPE(cmd) | EP_ID_FOR_TRB(ep_index) |
+	if (cmd == TRB_ENABLE_SLOT || cmd == TRB_ADDR_DEV || cmd == TRB_CONFIG_EP)
+		fields[3] = TRB_TYPE(cmd) |
+			    SLOT_ID_FOR_TRB(slot_id) | ctrl->cmd_ring->cycle_state;
+	else
+		fields[3] = TRB_TYPE(cmd) | EP_ID_FOR_TRB(ep_index) |
+			    SLOT_ID_FOR_TRB(slot_id) | ctrl->cmd_ring->cycle_state;
+
+				
+		debug("XHCI queue TRB 000 - (CYCLE_STATE= %x) "
+			"(%08x %08x %08x %08x)\n", ctrl->cmd_ring->cycle_state,
+			le32_to_cpu(fields[0]),
+			le32_to_cpu(fields[1]),
+			le32_to_cpu(fields[2]),
+			le32_to_cpu(fields[3]));
+	
+//	printf("The slot_id is %x\n", slot_id);
+//#define cr_readl(addr) (*(volatile unsigned int *)(addr)) 			
+//	printf("\n");
+//	unsigned int hcor_base = le32_to_cpu(fields[0]);
+//	int index;
+//	for(index = 0; index < 10; index++){
+//		unsigned int base_idnex = 0x00000010;
+//		printf("0x%08x = %08x  %08x  %08x  %08x\n",hcor_base+index*base_idnex, cr_readl((uintptr_t)(hcor_base+index*base_idnex)), cr_readl((uintptr_t)(hcor_base+index*base_idnex+4)), cr_readl((uintptr_t)(hcor_base+index*base_idnex+8)), cr_readl((uintptr_t)(hcor_base+index*base_idnex+12)));
+//	}
+//	printf("\n");
+			
+
+	queue_trb(ctrl, ctrl->cmd_ring, false, fields);
+
+	/* Ring the command ring doorbell */
+	wmb(); // add by cfyeh
+	xhci_writel(&ctrl->dba->doorbell[0], DB_VALUE_HOST);
+}
+
+// add by cfyeh +++
+/**
+ * Queueing a reset endpoint command TRB on the command ring.
+ * Check to make sure there's room on the command ring for one command TRB.
+ *
+ * @param ctrl		Host controller data structure
+ * @param ep_index	endpint index to reset
+ * @param slot_id 	device Slot ID
+ * @param cmd		Command type to enqueue
+ * @return none
+ */
+void xhci_queue_reset_endpoint_command(struct xhci_ctrl *ctrl, unsigned int ep_index, u32 slot_id,
+			trb_type cmd)
+{
+	u32 fields[4];
+
+	BUG_ON(prepare_ring(ctrl, ctrl->cmd_ring, EP_STATE_RUNNING));
+
+	fields[0] = 0;
+	fields[1] = 0;
+	fields[2] = 0;
+	fields[3] = TRB_TYPE(TRB_RESET_EP) | SLOT_ID_FOR_TRB(slot_id) |
+		    EP_ID_FOR_TRB(ep_index) |
+		    ctrl->cmd_ring->cycle_state;
+
+	queue_trb(ctrl, ctrl->cmd_ring, false, fields);
+
+	/* Ring the command ring doorbell */
+	wmb(); // add by cfyeh
+	xhci_writel(&ctrl->dba->doorbell[0], DB_VALUE_HOST);
+}
+
+/* Set Transfer Ring Dequeue Pointer command.
+ * This should not be used for endpoints that have streams enabled.
+ */
+void queue_set_tr_deq(struct xhci_ctrl *ctrl, int slot_id,
+		unsigned int ep_index,
+		union xhci_trb *deq_ptr, u32 cycle_state)
+{
+	u32 fields[4];
+	u64 val_64 = (uintptr_t)deq_ptr;
+
+	BUG_ON(prepare_ring(ctrl, ctrl->cmd_ring, EP_STATE_RUNNING));
+
+	fields[0] = lower_32_bits(val_64) | cycle_state;
+	fields[1] = upper_32_bits(val_64);
+	fields[2] = 0;
+	fields[3] = TRB_TYPE(TRB_SET_DEQ) | EP_ID_FOR_TRB(ep_index) |
 		    SLOT_ID_FOR_TRB(slot_id) | ctrl->cmd_ring->cycle_state;
 
 	queue_trb(ctrl, ctrl->cmd_ring, false, fields);
 
 	/* Ring the command ring doorbell */
+	wmb(); // add by cfyeh
 	xhci_writel(&ctrl->dba->doorbell[0], DB_VALUE_HOST);
 }
+// add by cfyeh ---
 
 /**
  * The TD size is the number of bytes remaining in the TD (including this TRB),
@@ -367,6 +468,10 @@ static void giveback_first_trb(struct usb_device *udev, int ep_index,
 	xhci_flush_cache((uintptr_t)start_trb, sizeof(struct xhci_generic_trb));
 
 	/* Ringing EP doorbell here */
+	wmb(); // add by cfyeh
+	
+	mdelay(1);  /*Some specific USB need more waiting time for response*/
+	
 	xhci_writel(&ctrl->dba->doorbell[udev->slot_id],
 				DB_VALUE(ep_index, 0));
 
@@ -387,9 +492,10 @@ void xhci_acknowledge_event(struct xhci_ctrl *ctrl)
 {
 	/* Advance our dequeue pointer to the next event */
 	inc_deq(ctrl, ctrl->event_ring);
-
 	/* Inform the hardware */
-	xhci_writeq(&ctrl->ir_set->erst_dequeue,
+	wmb(); // add by cfyeh
+	
+	xhci_writeq(&(ctrl->ir_set)->erst_dequeue,
 		(uintptr_t)ctrl->event_ring->dequeue | ERST_EHB);
 }
 
@@ -402,6 +508,7 @@ void xhci_acknowledge_event(struct xhci_ctrl *ctrl)
 static int event_ready(struct xhci_ctrl *ctrl)
 {
 	union xhci_trb *event;
+	debug("%s#####################\n", __func__); 
 
 	xhci_inval_cache((uintptr_t)ctrl->event_ring->dequeue,
 			 sizeof(union xhci_trb));
@@ -430,11 +537,31 @@ union xhci_trb *xhci_wait_for_event(struct xhci_ctrl *ctrl, trb_type expected)
 	trb_type type;
 	unsigned long ts = get_timer(0);
 
+	debug("%s #####\n", __func__); 
 	do {
+		xhci_inval_cache((uintptr_t)ctrl->event_ring->dequeue,
+			 sizeof(union xhci_trb));
+
+
 		union xhci_trb *event = ctrl->event_ring->dequeue;
+		debug("XHCI event TRB - %p "
+			"(%08x %08x %08x %08x)\n", event,
+			le32_to_cpu(event->generic.field[0]),
+			le32_to_cpu(event->generic.field[1]),
+			le32_to_cpu(event->generic.field[2]),
+			le32_to_cpu(event->generic.field[3]));
 
 		if (!event_ready(ctrl))
 			continue;
+		
+#ifdef XHCI_DEBUG_TRB // add by cfyeh
+		printf("XHCI event TRB - %p "
+			"(%08x %08x %08x %08x)\n", event,
+			le32_to_cpu(event->generic.field[0]),
+			le32_to_cpu(event->generic.field[1]),
+			le32_to_cpu(event->generic.field[2]),
+			le32_to_cpu(event->generic.field[3]));
+#endif // add by cfyeh
 
 		type = TRB_FIELD_TO_TYPE(le32_to_cpu(event->event_cmd.flags));
 		if (type == expected)
@@ -484,6 +611,7 @@ static void abort_td(struct usb_device *udev, int ep_index)
 
 	xhci_queue_command(ctrl, NULL, udev->slot_id, ep_index, TRB_STOP_RING);
 
+	debug("%s##\n", __func__); 
 	event = xhci_wait_for_event(ctrl, TRB_TRANSFER);
 	field = le32_to_cpu(event->trans_event.flags);
 	BUG_ON(TRB_TO_SLOT_ID(field) != udev->slot_id);
@@ -545,7 +673,7 @@ static void record_transfer_result(struct usb_device *udev,
  * @param buffer	buffer to be read/written based on the request
  * @return returns 0 if successful else -1 on failure
  */
-int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
+int xhci_bulk_tx(struct usb_device *udev, unsigned int pipe,
 			int length, void *buffer)
 {
 	int num_trbs = 0;
@@ -570,8 +698,8 @@ int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
 	u32 trb_fields[4];
 	u64 val_64 = (uintptr_t)buffer;
 
-	debug("dev=%p, pipe=%lx, buffer=%p, length=%d\n",
-		udev, pipe, buffer, length);
+	debug("%s ctrl %p, dev=%p, pipe=%x, buffer=%p, length=%d, ir_set %p\n", __func__, ctrl,
+		udev, pipe, buffer, length, ctrl->ir_set);
 
 	ep_index = usb_pipe_ep_index(pipe);
 	virt_dev = ctrl->devs[slot_id];
@@ -705,6 +833,7 @@ int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
 
 	giveback_first_trb(udev, ep_index, start_cycle, start_trb);
 
+	debug("%s, line %d\n", __func__, __LINE__); 
 	event = xhci_wait_for_event(ctrl, TRB_TRANSFER);
 	if (!event) {
 		debug("XHCI bulk transfer timed out, aborting...\n");
@@ -720,6 +849,7 @@ int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
 	BUG_ON(*(void **)(uintptr_t)le64_to_cpu(event->trans_event.buffer) -
 		buffer > (size_t)length);
 
+
 	record_transfer_result(udev, event, length);
 	xhci_acknowledge_event(ctrl);
 	xhci_inval_cache((uintptr_t)buffer, length);
@@ -737,7 +867,7 @@ int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
  * @param buffer	buffer to be read/written based on the request
  * @return returns 0 if successful else error code on failure
  */
-int xhci_ctrl_tx(struct usb_device *udev, unsigned long pipe,
+int xhci_ctrl_tx(struct usb_device *udev, unsigned int pipe,
 			struct devrequest *req,	int length,
 			void *buffer)
 {
@@ -756,7 +886,7 @@ int xhci_ctrl_tx(struct usb_device *udev, unsigned long pipe,
 	struct xhci_ring *ep_ring;
 	union xhci_trb *event;
 
-	debug("req=%u (%#x), type=%u (%#x), value=%u (%#x), index=%u\n",
+	debug("%s req=%u (%#x), type=%u (%#x), value=%u (%#x), index=%u\n", __func__,
 		req->request, req->request,
 		req->requesttype, req->requesttype,
 		le16_to_cpu(req->value), le16_to_cpu(req->value),
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 0b09643e09..fb8e88c438 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -299,6 +299,44 @@ static int xhci_configure_endpoints(struct usb_device *udev, bool ctx_change)
 	return 0;
 }
 
+// add by cfyeh +++
+/**
+ * Issue a reset endpoint command and wait for it to finish.
+ *
+ * @param udev	pointer to the Device Data Structure
+ * @param ctx_change	flag to indicate the Context has changed or NOT
+ * @return 0 on success, -1 on failure
+ */
+static int xhci_reset_endpoint(struct usb_device *udev, unsigned int ep_index)
+{
+	struct xhci_ctrl *ctrl = udev->controller;
+	union xhci_trb *event;
+
+	xhci_queue_reset_endpoint_command(ctrl, ep_index, udev->slot_id,
+		TRB_RESET_EP);
+
+	event = xhci_wait_for_event(ctrl, TRB_COMPLETION);
+	BUG_ON(TRB_TO_SLOT_ID(le32_to_cpu(event->event_cmd.flags))
+		!= udev->slot_id);
+
+	switch (GET_COMP_CODE(le32_to_cpu(event->event_cmd.status))) {
+	case COMP_SUCCESS:
+		debug("Successful %s command\n",
+			"Reset Endpoint");
+		break;
+	default:
+		debug("ERROR: %s command returned completion code %d.\n",
+			"Reset Endpoint",
+			GET_COMP_CODE(le32_to_cpu(event->event_cmd.status)));
+		return -1;
+	}
+
+	xhci_acknowledge_event(ctrl);
+
+	return 0;
+}
+// add by cfyeh ---
+
 /**
  * Configure the endpoint, programming the device contexts.
  *
@@ -370,8 +408,8 @@ static int xhci_set_configuration(struct usb_device *udev)
 			return -ENOMEM;
 
 		/*NOTE: ep_desc[0] actually represents EP1 and so on */
-		dir = (((endpt_desc->bEndpointAddress) & (0x80)) >> 7);
-		ep_type = (((endpt_desc->bmAttributes) & (0x3)) | (dir << 2));
+		dir = (((endpt_desc->bEndpointAddress) & (USB_ENDPOINT_DIR_MASK)) >> 7);
+		ep_type = (((endpt_desc->bmAttributes) & (USB_ENDPOINT_XFERTYPE_MASK)) | (dir << 2));
 		ep_ctx[ep_index]->ep_info2 =
 			cpu_to_le32(ep_type << EP_TYPE_SHIFT);
 		ep_ctx[ep_index]->ep_info2 |=
@@ -386,6 +424,35 @@ static int xhci_set_configuration(struct usb_device *udev)
 				virt_dev->eps[ep_index].ring->enqueue;
 		ep_ctx[ep_index]->deq = cpu_to_le64(trb_64 |
 				virt_dev->eps[ep_index].ring->cycle_state);
+				
+#if 1 // add by cfyeh
+		// hack for rtk bt devices, which will fail at set config
+		if (((udev->descriptor.idVendor == 0x0bda &&
+				udev->descriptor.idProduct == 0x8760) ||
+		     (udev->descriptor.idVendor == 0x0bda &&
+				udev->descriptor.idProduct == 0x2850) ||
+		     (udev->descriptor.idVendor == 0x0bda &&
+				udev->descriptor.idProduct == 0xa761))) {
+			// just for interrupt ep
+			if (usb_endpoint_xfer_int(endpt_desc)) {
+				u32 max_esit_payload;
+				int max_burst;
+				int max_packet;
+
+				// FIXME: add by cfyeh
+				// hard code value for rtk bt interrupt endpoint
+				ep_ctx[ep_index]->ep_info = 0x30000;
+
+				max_packet = GET_MAX_PACKET(usb_endpoint_maxp(endpt_desc));
+				max_burst = (usb_endpoint_maxp(endpt_desc) & 0x1800) >> 11;
+				/* A 0 in max burst means 1 transfer per ESIT */
+				max_esit_payload = max_packet * (max_burst + 1);
+
+				ep_ctx[ep_index]->tx_info = cpu_to_le32(MAX_ESIT_PAYLOAD_FOR_EP(max_esit_payload)) |
+						cpu_to_le32(AVG_TRB_LENGTH_FOR_EP(max_esit_payload));
+			}
+		}
+#endif // add by cfyeh
 	}
 
 	return xhci_configure_endpoints(udev, false);
@@ -415,14 +482,28 @@ static int xhci_address_device(struct usb_device *udev, int root_portnr)
 	 * so setting up the slot context.
 	 */
 	debug("Setting up addressable devices %p\n", ctrl->dcbaa);
-	xhci_setup_addressable_virt_dev(ctrl, udev->slot_id, udev->speed,
-					root_portnr);
+	xhci_setup_addressable_virt_dev(udev);
 
 	ctrl_ctx = xhci_get_input_control_ctx(virt_dev->in_ctx);
 	ctrl_ctx->add_flags = cpu_to_le32(SLOT_FLAG | EP0_FLAG);
 	ctrl_ctx->drop_flags = 0;
 
+	xhci_flush_cache((uintptr_t)virt_dev->in_ctx->bytes, virt_dev->in_ctx->size);
+	
+//#define cr_readl(addr) (*(volatile unsigned int *)(addr))
+//	printf("virt_dev->in_ctx->bytes is %x, virt_dev->in_ctx->size %d", (unsigned int)(uintptr_t)virt_dev->in_ctx->bytes, virt_dev->in_ctx->size);
+//	printf("\nThe before in_ctx is:\n");
+//	unsigned int in_ctx_base = (unsigned int)(uintptr_t)virt_dev->in_ctx->bytes;
+//	int index;
+//	for(index = 0; index < 10; index++){
+//		unsigned int base_idnex = 0x00000010;
+//		printf("0x%08x = %08x  %08x  %08x  %08x\n",in_ctx_base+index*base_idnex, cr_readl((uintptr_t)(in_ctx_base+index*base_idnex)), cr_readl((uintptr_t)(in_ctx_base+index*base_idnex+4)), cr_readl((uintptr_t)(in_ctx_base+index*base_idnex+8)), cr_readl((uintptr_t)(in_ctx_base+index*base_idnex+12)));
+//	}
+//	printf("\n");	
+	
 	xhci_queue_command(ctrl, (void *)ctrl_ctx, slot_id, 0, TRB_ADDR_DEV);
+	
+	
 	event = xhci_wait_for_event(ctrl, TRB_COMPLETION);
 	BUG_ON(TRB_TO_SLOT_ID(le32_to_cpu(event->event_cmd.flags)) != slot_id);
 
@@ -455,6 +536,14 @@ static int xhci_address_device(struct usb_device *udev, int root_portnr)
 
 	xhci_acknowledge_event(ctrl);
 
+//test
+	xhci_inval_cache((uintptr_t)virt_dev->out_ctx->bytes,
+			 virt_dev->out_ctx->size);
+	slot_ctx = xhci_get_slot_ctx(ctrl, virt_dev->out_ctx);
+
+// ....
+
+
 	if (ret < 0)
 		/*
 		 * TODO: Unsuccessful Address Device command shall leave the
@@ -481,6 +570,7 @@ static int xhci_address_device(struct usb_device *udev, int root_portnr)
  * @param udev	pointer to the Device Data Structure
  * @return Returns 0 on succes else return error code on failure
  */
+#define cr_readl(addr) (*(volatile unsigned int *)(addr)) 
 int _xhci_alloc_device(struct usb_device *udev)
 {
 	struct xhci_ctrl *ctrl = xhci_get_ctrl(udev);
@@ -492,6 +582,24 @@ int _xhci_alloc_device(struct usb_device *udev)
 	 * If this device is root-hub, don't do any xHC related
 	 * stuff.
 	 */
+	 
+//	int index = 0;	
+//	printf("\n");
+//	unsigned int hcor_base = 0x98029020;
+//	for(index = 0; index < 5; index++){
+//		unsigned int base_idnex = 0x00000010;
+//		printf("0x%08x = %08x  %08x  %08x  %08x\n",hcor_base+index*base_idnex, cr_readl((uintptr_t)(hcor_base+index*base_idnex)), cr_readl((uintptr_t)(hcor_base+index*base_idnex+4)), cr_readl((uintptr_t)(hcor_base+index*base_idnex+8)), cr_readl((uintptr_t)(hcor_base+index*base_idnex+12)));
+//	}
+//	printf("\n");
+
+//	hcor_base = 0x98029400;
+//	for(index = 0; index < 1; index++){
+//		unsigned int base_idnex = 0x00000010;
+//		printf("0x%08x = %08x  %08x  %08x  %08x\n",hcor_base+index*base_idnex, cr_readl((uintptr_t)(hcor_base+index*base_idnex)), cr_readl((uintptr_t)(hcor_base+index*base_idnex+4)), cr_readl((uintptr_t)(hcor_base+index*base_idnex+8)), cr_readl((uintptr_t)(hcor_base+index*base_idnex+12)));
+//	}
+//	printf("\n");
+	 
+	 
 	if (ctrl->rootdev == 0) {
 		udev->speed = USB_SPEED_SUPER;
 		return 0;
@@ -506,7 +614,7 @@ int _xhci_alloc_device(struct usb_device *udev)
 
 	xhci_acknowledge_event(ctrl);
 
-	ret = xhci_alloc_virt_device(ctrl, udev->slot_id);
+	ret = xhci_alloc_virt_device(udev);
 	if (ret < 0) {
 		/*
 		 * TODO: Unsuccessful Address Device command shall leave
@@ -520,10 +628,15 @@ int _xhci_alloc_device(struct usb_device *udev)
 }
 
 #ifndef CONFIG_DM_USB
-int usb_alloc_device(struct usb_device *udev)
+//int usb_alloc_device(struct usb_device *udev)
+int xhci_alloc_device(struct usb_device *udev)
 {
 	return _xhci_alloc_device(udev);
 }
+
+void xhci_free_device(struct usb_device *udev) {
+
+}
 #endif
 
 /*
@@ -658,7 +771,7 @@ static u32 xhci_port_state_to_neutral(u32 state)
  * @param buffer buffer to be read/written based on the request
  * @return returns 0 if successful else -1 on failure
  */
-static int xhci_submit_root(struct usb_device *udev, unsigned long pipe,
+static int xhci_submit_root(struct usb_device *udev, unsigned int pipe,
 			void *buffer, struct devrequest *req)
 {
 	uint8_t tmpbuf[4];
@@ -683,6 +796,8 @@ static int xhci_submit_root(struct usb_device *udev, unsigned long pipe,
 
 	typeReq = req->request | req->requesttype << 8;
 
+	//printf("The value of typeReq is %d\n", typeReq);
+	
 	switch (typeReq) {
 	case DeviceRequest | USB_REQ_GET_DESCRIPTOR:
 		switch (le16_to_cpu(req->value) >> 8) {
@@ -738,6 +853,7 @@ static int xhci_submit_root(struct usb_device *udev, unsigned long pipe,
 		break;
 	case USB_REQ_SET_ADDRESS | (USB_RECIP_DEVICE << 8):
 		debug("USB_REQ_SET_ADDRESS\n");
+		//printf("%s %d rootdev =%d\n", __func__, __LINE__, ctrl->rootdev);
 		ctrl->rootdev = le16_to_cpu(req->value);
 		break;
 	case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:
@@ -849,15 +965,18 @@ static int xhci_submit_root(struct usb_device *udev, unsigned long pipe,
 		xhci_writel(status_reg, reg);
 		break;
 	default:
-		puts("Unknown request\n");
+		printf("Unknown request , typeReq = 0x%x \n", typeReq);
 		goto unknown;
 	}
 
-	debug("scrlen = %d\n req->length = %d\n",
-		srclen, le16_to_cpu(req->length));
+	//printf("scrlen = %d\n req->length = %d\n",
+	//	srclen, le16_to_cpu(req->length));
 
 	len = min(srclen, (int)le16_to_cpu(req->length));
 
+	//printf("@@@@@@@@@@@@ len = %d\n \n", len);
+
+
 	if (srcptr != NULL && len > 0)
 		memcpy(buffer, srcptr, len);
 	else
@@ -885,14 +1004,15 @@ unknown:
  * @param interval	interval of the interrupt
  * @return 0
  */
-static int _xhci_submit_int_msg(struct usb_device *udev, unsigned long pipe,
+static int _xhci_submit_int_msg(struct usb_device *udev, unsigned int pipe,
 				void *buffer, int length, int interval)
 {
 	/*
 	 * TODO: Not addressing any interrupt type transfer requests
 	 * Add support for it later.
 	 */
-	return -EINVAL;
+	//return -EINVAL;
+	return xhci_bulk_tx(udev, pipe, length, buffer);
 }
 
 /**
@@ -904,17 +1024,196 @@ static int _xhci_submit_int_msg(struct usb_device *udev, unsigned long pipe,
  * @param length	length of the buffer
  * @return returns 0 if successful else -1 on failure
  */
-static int _xhci_submit_bulk_msg(struct usb_device *udev, unsigned long pipe,
+static int _xhci_submit_bulk_msg(struct usb_device *udev, unsigned int pipe,
 				 void *buffer, int length)
 {
+	
 	if (usb_pipetype(pipe) != PIPE_BULK) {
-		printf("non-bulk pipe (type=%lu)", usb_pipetype(pipe));
+		printf("non-bulk pipe (type=%x)", usb_pipetype(pipe));
 		return -EINVAL;
 	}
 
 	return xhci_bulk_tx(udev, pipe, length, buffer);
 }
 
+// add by cfyeh +++
+struct xhci_dequeue_state {                                                                                        
+	struct xhci_segment *new_deq_seg;                                                                          
+	union xhci_trb *new_deq_ptr;                                                                               
+	int new_cycle_state;                                                                                       
+};                                                                                                                 
+
+/* Is this TRB a link TRB or was the last TRB the last TRB in this event ring
+ * segment?  I.e. would the updated event TRB pointer step off the end of the
+ * event seg?
+ */
+static int last_trb(struct xhci_ctrl *ctrl, struct xhci_ring *ring,
+		struct xhci_segment *seg, union xhci_trb *trb)
+{
+	if (ring == ctrl->event_ring)
+		return trb == &seg->trbs[TRBS_PER_SEGMENT];
+	else
+		return TRB_TYPE_LINK_LE32(trb->link.control);
+}
+
+/* Updates trb to point to the next TRB in the ring, and updates seg if the next
+ * TRB is in a new segment.  This does not skip over link TRBs, and it does not
+ * effect the ring dequeue or enqueue pointers.
+ */
+static void next_trb(struct xhci_ctrl *ctrl,
+		struct xhci_ring *ring,
+		struct xhci_segment **seg,
+		union xhci_trb **trb)
+{
+	if (last_trb(ctrl, ring, *seg, *trb)) {
+		*seg = (*seg)->next;
+		*trb = ((*seg)->trbs);
+	} else {
+		(*trb)++;
+	}
+}
+
+/*
+ * Find the segment that trb is in.  Start searching in start_seg.
+ * If we must move past a segment that has a link TRB with a toggle cycle state
+ * bit set, then we will toggle the value pointed at by cycle_state.
+ */
+static struct xhci_segment *find_trb_seg(
+		struct xhci_segment *start_seg,
+		union xhci_trb	*trb, int *cycle_state)
+{
+	struct xhci_segment *cur_seg = start_seg;
+	struct xhci_generic_trb *generic_trb;
+
+	while (cur_seg->trbs > trb ||
+			&cur_seg->trbs[TRBS_PER_SEGMENT - 1] < trb) {
+		generic_trb = &cur_seg->trbs[TRBS_PER_SEGMENT - 1].generic;
+		if (generic_trb->field[3] & cpu_to_le32(LINK_TOGGLE))
+			*cycle_state ^= 0x1;
+		cur_seg = cur_seg->next;
+		if (cur_seg == start_seg)
+			/* Looped over the entire list.  Oops! */
+			return NULL;
+	}
+	return cur_seg;
+}
+
+/*
+ * Move the xHC's endpoint ring dequeue pointer past cur_td.
+ * Record the new state of the xHC's endpoint ring dequeue segment,
+ * dequeue pointer, and new consumer cycle state in state.
+ * Update our internal representation of the ring's dequeue pointer.
+ *
+ * We do this in three jumps:
+ *  - First we update our new ring state to be the same as when the xHC stopped.
+ *  - Then we traverse the ring to find the segment that contains
+ *    the last TRB in the TD.  We toggle the xHC's new cycle state when we pass
+ *    any link TRBs with the toggle cycle bit set.
+ *  - Finally we move the dequeue state one TRB further, toggling the cycle bit
+ *    if we've moved it past a link TRB with the toggle cycle bit set.
+ *
+ * Some of the uses of xhci_generic_trb are grotty, but if they're done
+ * with correct __le32 accesses they should work fine.  Only users of this are
+ * in here.
+ */
+void xhci_find_new_dequeue_state(struct xhci_ctrl *ctrl,
+		unsigned int slot_id, unsigned int ep_index,
+		struct xhci_dequeue_state *state)
+{
+	struct xhci_virt_device *virt_dev = ctrl->devs[slot_id];
+	struct xhci_ring *ep_ring;
+	struct xhci_generic_trb *trb;
+	struct xhci_ep_ctx *ep_ctx;
+
+	ep_ring = virt_dev->eps[ep_index].ring;
+
+	state->new_cycle_state = 0;
+	//puts("Finding segment containing stopped TRB.\n");
+	state->new_deq_seg = find_trb_seg(ep_ring->first_seg,
+			ep_ring->enqueue,
+			&state->new_cycle_state);
+	if (!state->new_deq_seg) {
+		return;
+	}
+
+	/* Dig out the cycle state saved by the xHC during the stop ep cmd */
+	//puts("Finding endpoint context\n");
+	ep_ctx = xhci_get_ep_ctx(ctrl, virt_dev->out_ctx, ep_index);
+	state->new_cycle_state = 0x1 & le64_to_cpu(ep_ctx->deq);
+
+	state->new_deq_ptr = ep_ring->enqueue;
+	--(state->new_deq_ptr);
+	//puts("Finding segment containing last TRB in TD.\n");
+	state->new_deq_seg = find_trb_seg(state->new_deq_seg,
+			state->new_deq_ptr,
+			&state->new_cycle_state);
+	if (!state->new_deq_seg) {
+		return;
+	}
+
+	trb = &state->new_deq_ptr->generic;
+	if (TRB_TYPE_LINK_LE32(trb->field[3]) &&
+	    (trb->field[3] & cpu_to_le32(LINK_TOGGLE)))
+		state->new_cycle_state ^= 0x1;
+	next_trb(ctrl, ep_ring, &state->new_deq_seg, &state->new_deq_ptr);
+
+	/*
+	 * If there is only one segment in a ring, find_trb_seg()'s while loop
+	 * will not run, and it will return before it has a chance to see if it
+	 * needs to toggle the cycle bit.  It can't tell if the stalled transfer
+	 * ended just before the link TRB on a one-segment ring, or if the TD
+	 * wrapped around the top of the ring, because it doesn't have the TD in
+	 * question.  Look for the one-segment case where stalled TRB's address
+	 * is greater than the new dequeue pointer address.
+	 */
+	/* if (ep_ring->first_seg == ep_ring->first_seg->next &&
+			state->new_deq_ptr < virt_dev->eps[ep_index].stopped_trb)
+		state->new_cycle_state ^= 0x1; */
+	//printf("Cycle state = 0x%x\n", state->new_cycle_state);
+
+	/* Don't update the ring cycle state for the producer (us). */
+	//printf("New dequeue segment = %p (virtual)\n",
+	//		state->new_deq_seg);
+}
+
+void xhci_queue_new_dequeue_state(struct usb_device *udev,
+		unsigned int slot_id, unsigned int ep_index,
+		struct xhci_dequeue_state *deq_state)
+{
+	struct xhci_ctrl *ctrl = udev->controller;
+	union xhci_trb *event;
+
+	//printf("Set TR Deq Ptr cmd, new deq seg = %p, "
+	//		"new deq ptr = %p, new cycle = %u\n",
+	//		deq_state->new_deq_seg,
+	//		deq_state->new_deq_ptr,
+	//		deq_state->new_cycle_state);
+	queue_set_tr_deq(ctrl, slot_id, ep_index,
+			deq_state->new_deq_ptr,
+			(u32) deq_state->new_cycle_state);
+
+	event = xhci_wait_for_event(ctrl, TRB_COMPLETION);
+	BUG_ON(TRB_TO_SLOT_ID(le32_to_cpu(event->event_cmd.flags))
+		!= udev->slot_id);
+
+	switch (GET_COMP_CODE(le32_to_cpu(event->event_cmd.status))) {
+	case COMP_SUCCESS:
+		debug("Successful %s command\n",
+			"Reset Endpoint");
+		break;
+	default:
+		debug("ERROR: %s command returned completion code %d.\n",
+			"Reset Endpoint",
+			GET_COMP_CODE(le32_to_cpu(event->event_cmd.status)));
+		//return -1;
+	}
+
+	xhci_acknowledge_event(ctrl);
+
+	//return 0;
+}
+// add by cfyeh +++
+
 /**
  * submit the control type of request to the Root hub/Device based on the devnum
  *
@@ -926,7 +1225,7 @@ static int _xhci_submit_bulk_msg(struct usb_device *udev, unsigned long pipe,
  * @param root_portnr	Root port number that this device is on
  * @return returns 0 if successful else -1 on failure
  */
-static int _xhci_submit_control_msg(struct usb_device *udev, unsigned long pipe,
+static int _xhci_submit_control_msg(struct usb_device *udev, unsigned int pipe,
 				    void *buffer, int length,
 				    struct devrequest *setup, int root_portnr)
 {
@@ -934,12 +1233,18 @@ static int _xhci_submit_control_msg(struct usb_device *udev, unsigned long pipe,
 	int ret = 0;
 
 	if (usb_pipetype(pipe) != PIPE_CONTROL) {
-		printf("non-control pipe (type=%lu)", usb_pipetype(pipe));
+		printf("non-control pipe (type=%x)", usb_pipetype(pipe));
 		return -EINVAL;
 	}
+	
+	debug("%s %d udev address is 0x%x\n", __func__,__LINE__, (unsigned int)(uintptr_t)udev);	
+	debug("%s %d usb_pipedevice(pipe)= %x , ctrl->rootdev=%d \n", __func__,__LINE__, (unsigned int)usb_pipedevice(pipe), ctrl->rootdev);//hcy added 
+	debug("%s %d setup->request= %x , USB_REQ_SET_ADDRESS = %x \n", __func__,__LINE__,setup->request, USB_REQ_SET_ADDRESS);
 
 	if (usb_pipedevice(pipe) == ctrl->rootdev)
 		return xhci_submit_root(udev, pipe, buffer, setup);
+	
+	debug("%s %d setup->request= %x , USB_REQ_SET_ADDRESS = %x \n", __func__,__LINE__,setup->request, USB_REQ_SET_ADDRESS);
 
 	if (setup->request == USB_REQ_SET_ADDRESS)
 		return xhci_address_device(udev, root_portnr);
@@ -952,7 +1257,35 @@ static int _xhci_submit_control_msg(struct usb_device *udev, unsigned long pipe,
 		}
 	}
 
-	return xhci_ctrl_tx(udev, pipe, setup, length, buffer);
+	ret = xhci_ctrl_tx(udev, pipe, setup, length, buffer);
+
+// add by cfyeh +++
+	// send reset endpoint command to command ring
+	if (setup->requesttype == USB_RECIP_ENDPOINT &&
+			setup->request == USB_REQ_CLEAR_FEATURE) {
+		// ref: xhci_get_ep_index() for ep_index value
+		unsigned int ep_index = (setup->index & USB_ENDPOINT_NUMBER_MASK) * 2;
+		if(!xhci_reset_endpoint(udev, ep_index)) {
+			struct xhci_dequeue_state deq_state;
+
+			//puts("Cleaning up stalled endpoint ring\n");
+			/* We need to move the HW's dequeue pointer past this TD,
+			 * or it will attempt to resend it on the next doorbell ring.
+			 */
+			xhci_find_new_dequeue_state(ctrl, udev->slot_id,
+					ep_index, &deq_state);
+
+			/* HW with the reset endpoint quirk will use the saved dequeue state to
+			 * issue a configure endpoint command later.
+			 */
+			puts("Queueing new dequeue state\n");
+			xhci_queue_new_dequeue_state(udev, udev->slot_id,
+					ep_index, &deq_state);
+		}
+	}
+// add by cfyeh ---
+
+	return ret;
 }
 
 static int xhci_lowlevel_init(struct xhci_ctrl *ctrl)
@@ -1005,6 +1338,8 @@ static int xhci_lowlevel_init(struct xhci_ctrl *ctrl)
 
 	reg = HC_VERSION(xhci_readl(&hccr->cr_capbase));
 	printf("USB XHCI %x.%02x\n", reg >> 8, reg & 0xff);
+	
+	ctrl->ctrl_type = CTRL_TYPE_XHCI;
 
 	return 0;
 }
@@ -1020,12 +1355,14 @@ static int xhci_lowlevel_stop(struct xhci_ctrl *ctrl)
 	xhci_writel(&ctrl->hcor->or_usbsts, temp & ~STS_EINT);
 	temp = xhci_readl(&ctrl->ir_set->irq_pending);
 	xhci_writel(&ctrl->ir_set->irq_pending, ER_IRQ_DISABLE(temp));
+	debug("// %s ctrl %p\n", __func__, ctrl);
 
 	return 0;
 }
 
 #ifndef CONFIG_DM_USB
-int submit_control_msg(struct usb_device *udev, unsigned long pipe,
+//int submit_control_msg(struct usb_device *udev, unsigned long pipe,
+int xhci_submit_control_msg(struct usb_device *udev, unsigned int pipe,
 		       void *buffer, int length, struct devrequest *setup)
 {
 	struct usb_device *hop = udev;
@@ -1038,13 +1375,15 @@ int submit_control_msg(struct usb_device *udev, unsigned long pipe,
 					hop->portnr);
 }
 
-int submit_bulk_msg(struct usb_device *udev, unsigned long pipe, void *buffer,
+//int submit_bulk_msg(struct usb_device *udev, unsigned long pipe, void *buffer,
+int xhci_submit_bulk_msg(struct usb_device *udev, unsigned int pipe, void *buffer,
 		    int length)
 {
 	return _xhci_submit_bulk_msg(udev, pipe, buffer, length);
 }
 
-int submit_int_msg(struct usb_device *udev, unsigned long pipe, void *buffer,
+//int submit_int_msg(struct usb_device *udev, unsigned long pipe, void *buffer,
+int xhci_submit_int_msg(struct usb_device *udev, unsigned int pipe, void *buffer,
 		   int length, int interval)
 {
 	return _xhci_submit_int_msg(udev, pipe, buffer, length, interval);
@@ -1057,7 +1396,8 @@ int submit_int_msg(struct usb_device *udev, unsigned long pipe, void *buffer,
  * @param index	index to the host controller data structure
  * @return pointer to the intialised controller
  */
-int usb_lowlevel_init(int index, enum usb_init_type init, void **controller)
+//int usb_lowlevel_init(int index, enum usb_init_type init, void **controller)
+int xhci_to_lowlevel_init(int index, enum usb_init_type init, void **controller)
 {
 	struct xhci_hccr *hccr;
 	struct xhci_hcor *hcor;
@@ -1072,10 +1412,12 @@ int usb_lowlevel_init(int index, enum usb_init_type init, void **controller)
 
 	ctrl = &xhcic[index];
 
+	memset(ctrl, 0, sizeof(struct xhci_ctrl));
+
 	ctrl->hccr = hccr;
 	ctrl->hcor = hcor;
 
-	ret = xhci_lowlevel_init(ctrl);
+	ret = xhci_lowlevel_init(ctrl);	
 
 	*controller = &xhcic[index];
 
@@ -1089,13 +1431,16 @@ int usb_lowlevel_init(int index, enum usb_init_type init, void **controller)
  * @param index	index to the host controller data structure
  * @return none
  */
-int usb_lowlevel_stop(int index)
+//int usb_lowlevel_stop(int index)
+int xhci_to_lowlevel_stop(int index)
 {
 	struct xhci_ctrl *ctrl = (xhcic + index);
 
 	xhci_lowlevel_stop(ctrl);
 	xhci_hcd_stop(index);
+	debug("// 11 %s index %d\n", __func__, index);
 	xhci_cleanup(ctrl);
+	debug("// 22 %s index %d\n", __func__, index);
 
 	return 0;
 }
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 2afa38694b..2e7df926e1 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -20,6 +20,7 @@
 #include <asm/types.h>
 #include <asm/cache.h>
 #include <asm/io.h>
+#include <asm/arch/io.h>
 #include <linux/list.h>
 #include <linux/compat.h>
 
@@ -514,7 +515,7 @@ struct xhci_slot_ctx {
 	__le32	dev_state;
 	/* offset 0x10 to 0x1f reserved for HC internal use */
 	__le32	reserved[4];
-};
+} __attribute__((packed));
 
 /* dev_info bitmasks */
 /* Route String - 0:19 */
@@ -597,7 +598,7 @@ struct xhci_ep_ctx {
 	__le32	tx_info;
 	/* offset 0x14 - 0x1f reserved for HC internal use */
 	__le32	reserved[3];
-};
+} __attribute__((packed));
 
 /* ep_info bitmasks */
 /*
@@ -684,7 +685,7 @@ struct xhci_input_control_ctx {
 	volatile __le32	drop_flags;
 	volatile __le32	add_flags;
 	__le32	rsvd2[6];
-};
+} __attribute__((packed));
 
 
 /**
@@ -1091,14 +1092,29 @@ struct xhci_virt_device {
 /* xHCI spec says all registers are little endian */
 static inline unsigned int xhci_readl(uint32_t volatile *regs)
 {
+#if 0 // add by cfyeh
 	return readl(regs);
+#else
+	wmb(); // add by cfyeh
+	return rtd_inl((volatile unsigned int *)(uintptr_t)regs);
+#endif
 }
 
-static inline void xhci_writel(uint32_t volatile *regs, const unsigned int val)
+static inline void xhci_writel_(uint32_t volatile *regs, const unsigned int val, const char * NAME)
 {
+#if 0 // add by cfyeh
 	writel(val, regs);
+#else
+	//printf("%s, regs %x, value %x\n", NAME, (unsigned int)(uintptr_t)regs, val);
+	wmb(); // add by cfyeh
+	rtd_outl((volatile unsigned int *)(uintptr_t)regs, val);
+	wmb(); // add by cfyeh
+#endif
 }
 
+#define xhci_writel(regs, val) \
+	xhci_writel_(regs, val, __func__);
+
 /*
  * Registers should always be accessed with double word or quad word accesses.
  * Some xHCI implementations may support 64-bit address pointers.  Registers
@@ -1109,27 +1125,39 @@ static inline void xhci_writel(uint32_t volatile *regs, const unsigned int val)
  */
 static inline u64 xhci_readq(__le64 volatile *regs)
 {
-#if BITS_PER_LONG == 64
+#if 0//BITS_PER_LONG == 64
 	return readq(regs);
 #else
 	__u32 *ptr = (__u32 *)regs;
+#if 0 // add by cfyeh
 	u64 val_lo = readl(ptr);
 	u64 val_hi = readl(ptr + 1);
+#else
+	rmb();
+	u64 val_lo = rtd_inl((volatile unsigned int *)(uintptr_t)ptr);
+	u64 val_hi = rtd_inl((volatile unsigned int *)(uintptr_t)(ptr + 1));
+#endif
 	return val_lo + (val_hi << 32);
 #endif
 }
 
 static inline void xhci_writeq(__le64 volatile *regs, const u64 val)
 {
-#if BITS_PER_LONG == 64
+#if 0//BITS_PER_LONG == 64
 	writeq(val, regs);
 #else
 	__u32 *ptr = (__u32 *)regs;
 	u32 val_lo = lower_32_bits(val);
 	/* FIXME */
 	u32 val_hi = upper_32_bits(val);
+#if 0 // add by cfyeh
 	writel(val_lo, ptr);
 	writel(val_hi, ptr + 1);
+#else
+	rtd_outl((volatile unsigned int *)(uintptr_t)ptr, val_lo);	
+	rtd_outl((volatile unsigned int *)(uintptr_t)(ptr + 1), val_hi);	
+	wmb();
+#endif
 #endif
 }
 
@@ -1209,6 +1237,7 @@ void xhci_hcd_stop(int index);
 #define XHCI_STS_CNR		(1 << 11)
 
 struct xhci_ctrl {
+	int ctrl_type;
 #ifdef CONFIG_DM_USB
 	struct udevice *dev;
 #endif
@@ -1244,24 +1273,28 @@ void xhci_endpoint_copy(struct xhci_ctrl *ctrl,
 void xhci_slot_copy(struct xhci_ctrl *ctrl,
 		    struct xhci_container_ctx *in_ctx,
 		    struct xhci_container_ctx *out_ctx);
-void xhci_setup_addressable_virt_dev(struct xhci_ctrl *ctrl, int slot_id,
-				     int speed, int hop_portnr);
+void xhci_setup_addressable_virt_dev(struct usb_device *udev);
 void xhci_queue_command(struct xhci_ctrl *ctrl, u8 *ptr,
 			u32 slot_id, u32 ep_index, trb_type cmd);
 void xhci_acknowledge_event(struct xhci_ctrl *ctrl);
 union xhci_trb *xhci_wait_for_event(struct xhci_ctrl *ctrl, trb_type expected);
-int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
+int xhci_bulk_tx(struct usb_device *udev, unsigned int pipe,
 		 int length, void *buffer);
-int xhci_ctrl_tx(struct usb_device *udev, unsigned long pipe,
+int xhci_ctrl_tx(struct usb_device *udev, unsigned int pipe,
 		 struct devrequest *req, int length, void *buffer);
 int xhci_check_maxpacket(struct usb_device *udev);
 void xhci_flush_cache(uintptr_t addr, u32 type_len);
 void xhci_inval_cache(uintptr_t addr, u32 type_len);
 void xhci_cleanup(struct xhci_ctrl *ctrl);
 struct xhci_ring *xhci_ring_alloc(unsigned int num_segs, bool link_trbs);
-int xhci_alloc_virt_device(struct xhci_ctrl *ctrl, unsigned int slot_id);
+int xhci_alloc_virt_device(struct usb_device *udev);
 int xhci_mem_init(struct xhci_ctrl *ctrl, struct xhci_hccr *hccr,
 		  struct xhci_hcor *hcor);
+		  
+void xhci_queue_reset_endpoint_command(struct xhci_ctrl *ctrl, unsigned int ep_index, u32 slot_id, trb_type cmd);
+void queue_set_tr_deq(struct xhci_ctrl *ctrl, int slot_id,
+		unsigned int ep_index,
+		union xhci_trb *deq_ptr, u32 cycle_state);
 
 /**
  * xhci_deregister() - Unregister an XHCI controller
diff --git a/drivers/usb/phy/Makefile b/drivers/usb/phy/Makefile
index 93d147e26f..14bbad4359 100644
--- a/drivers/usb/phy/Makefile
+++ b/drivers/usb/phy/Makefile
@@ -5,5 +5,7 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+obj-$(CONFIG_USB_RTK) += phy-rtk-usb2.o
+obj-$(CONFIG_USB_RTK) += phy-rtk-usb3.o
 obj-$(CONFIG_TWL4030_USB) += twl4030.o
 obj-$(CONFIG_OMAP_USB_PHY) += omap_usb_phy.o
diff --git a/fs/fat/fat.c b/fs/fat/fat.c
index bccc3e3ed8..d49ec27045 100644
--- a/fs/fat/fat.c
+++ b/fs/fat/fat.c
@@ -747,7 +747,11 @@ read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
 		return -1;
 	}
 
+#if 0 // add by cfyeh
 	block = memalign(ARCH_DMA_MINALIGN, cur_dev->blksz);
+#else
+	block = memalign(0x400, cur_dev->blksz);
+#endif // add by cfyeh
 	if (block == NULL) {
 		debug("Error: allocating block\n");
 		return -1;
@@ -868,7 +872,11 @@ int do_fat_read_at(const char *filename, loff_t pos, void *buffer,
 	}
 
 	mydata->fatbufnum = -1;
+#if 0 // add by cfyeh
 	mydata->fatbuf = memalign(ARCH_DMA_MINALIGN, FATBUFSIZE);
+#else
+	mydata->fatbuf = memalign(0x400, FATBUFSIZE);
+#endif // add by cfyeh
 	if (mydata->fatbuf == NULL) {
 		debug("Error: allocating memory\n");
 		return -1;
@@ -1219,7 +1227,8 @@ int file_fat_detectfs(void)
     defined(CONFIG_CMD_SATA) || \
     defined(CONFIG_CMD_SCSI) || \
     defined(CONFIG_CMD_USB) || \
-    defined(CONFIG_MMC)
+    defined(CONFIG_CMD_MMC) || \
+    defined(CONFIG_CMD_SD)
 	printf("Interface:  ");
 	switch (cur_dev->if_type) {
 	case IF_TYPE_IDE:
@@ -1243,6 +1252,9 @@ int file_fat_detectfs(void)
 	case IF_TYPE_MMC:
 		printf("MMC");
 		break;
+	case IF_TYPE_SD:
+		printf("SD");
+		break;
 	default:
 		printf("Unknown");
 	}
diff --git a/fs/fs.c b/fs/fs.c
index ac0897d94a..c6fd714812 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -207,6 +207,11 @@ int fs_set_blk_dev(const char *ifname, const char *dev_part_str, int fstype)
 	}
 #endif
 
+	//block_dev_desc_t *fs_dev_desc;
+	//disk_partition_t fs_partition;
+	fs_dev_desc = NULL;
+	
+			
 	part = get_device_and_partition(ifname, dev_part_str, &fs_dev_desc,
 					&fs_partition, 1);
 	if (part < 0)
diff --git a/include/bootm.h b/include/bootm.h
index 49813772ce..ab42892f84 100644
--- a/include/bootm.h
+++ b/include/bootm.h
@@ -35,7 +35,7 @@
 typedef int boot_os_fn(int flag, int argc, char * const argv[],
 			bootm_headers_t *images);
 
-extern boot_os_fn do_bootm_linux;
+extern int do_bootm_linux(int flag, int argc, char * const argv[], bootm_headers_t *images);
 int do_bootelf(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
 void lynxkdi_boot(image_header_t *hdr);
 
diff --git a/include/command.h b/include/command.h
index bd3fc049ec..6c04cd9007 100644
--- a/include/command.h
+++ b/include/command.h
@@ -104,6 +104,8 @@ static inline int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
 
 extern int do_bootz(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
 
+extern int do_booti(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+
 extern int common_diskboot(cmd_tbl_t *cmdtp, const char *intf, int argc,
 			   char *const argv[]);
 
diff --git a/include/common.h b/include/common.h
index 8f4b2ec212..5060ae071e 100644
--- a/include/common.h
+++ b/include/common.h
@@ -98,6 +98,21 @@ typedef volatile unsigned char	vu_char;
 #define pr_fmt(fmt) fmt
 #endif
 
+#ifdef CONFIG_CUSTOMIZE_FUNC_REGISTER
+#define REGISTER_CUSTOMIZE_FUNC(type, callback, info)	\
+	do {												\
+		register_customize_func(type, callback, info);	\
+	} while(0);
+
+#define EXECUTE_CUSTOMIZE_FUNC(type)	\
+	do {								\
+		execute_customize_func(type);	\
+	} while(0);
+#else
+#define REGISTER_CUSTOMIZE_FUNC(type, callback, info)
+#define EXECUTE_CUSTOMIZE_FUNC(type)
+#endif	/* CONFIG_CUSTOMIZE_FUNC_REGISTER */
+
 /*
  * Output a debug text when condition "cond" is met. The "cond" should be
  * computed by a preprocessor in the best case, allowing for the best
@@ -190,6 +205,15 @@ void	hang		(void) __attribute__ ((noreturn));
 int	timer_init(void);
 int	cpu_init(void);
 
+
+#ifdef CONFIG_NONCACHE_ALLOCATION
+/* mem.c */
+void *malloc_noncache(unsigned int size);
+void *malloc_noncache_align(unsigned int size, unsigned align);
+int mem_malloc_noncache_check(void *ptr);
+void mem_malloc_noncache_init(unsigned int start, unsigned int size);
+#endif
+
 /* */
 phys_size_t initdram (int);
 
@@ -238,6 +262,25 @@ static inline int print_cpuinfo(void)
 int update_flash_size(int flash_size);
 int arch_early_init_r(void);
 
+
+//*********************************************************
+static unsigned int alloc_ptr = 0x200000;
+
+static inline uchar* alloc_outside_buffer(unsigned int length){
+	unsigned int ptr = alloc_ptr;
+	alloc_ptr += length;
+	return (uchar*)(uintptr_t)ptr;
+}
+
+#define MY_ALLOC_CACHE_ALIGN_BUFFER(type, name, size)	type* name = (type*)alloc_outside_buffer(ROUND(size * sizeof(type), ARCH_DMA_MINALIGN));
+
+static inline void MY_CLR_ALIGN_BUFFER(void){
+	alloc_ptr = 0x200000;
+}
+//*********************************************************
+
+
+
 /**
  * arch_cpu_init_dm() - init CPU after driver model is available
  *
@@ -438,7 +481,7 @@ int  eeprom_write (unsigned dev_addr, unsigned offset, uchar *buffer, unsigned c
  * type, to prevent errors.
  */
 #if defined(CONFIG_SPI) || !defined(CONFIG_SYS_I2C_EEPROM_ADDR)
-# define CONFIG_SYS_DEF_EEPROM_ADDR 0
+# define CONFIG_SYS_DEF_EEPROM_ADDR 0x50
 #else
 #if !defined(CONFIG_ENV_EEPROM_IS_ON_I2C)
 # define CONFIG_SYS_DEF_EEPROM_ADDR CONFIG_SYS_I2C_EEPROM_ADDR
@@ -485,6 +528,12 @@ void	icache_disable(void);
 int	dcache_status (void);
 void	dcache_enable (void);
 void	dcache_disable(void);
+#if defined(CONFIG_CMD_CACHETEST)
+void	dcache_disable_no_flush(void);
+void	dcache_enable_wt(void);
+void	reset_cache_write_through(void);
+void	reset_cache_write_back(void);
+#endif
 void	mmu_disable(void);
 #if defined(CONFIG_ARM)
 void	relocate_code(ulong);
@@ -988,6 +1037,7 @@ int cpu_release(int nr, int argc, char * const argv[]);
 #define ALLOC_ALIGN_BUFFER_PAD(type, name, size, align, pad)		\
 	char __##name[ROUND(PAD_SIZE((size) * sizeof(type), pad), align)  \
 		      + (align - 1)];					\
+			  memset(__##name, 0, size*sizeof(type));				\
 									\
 	type *name = (type *) ALIGN((uintptr_t)__##name, align)
 #define ALLOC_ALIGN_BUFFER(type, name, size, align)		\
@@ -1015,4 +1065,58 @@ int cpu_release(int nr, int argc, char * const argv[]);
 # include <environment.h>
 #endif
 
+/* cmd_bdinfo */
+#define UNIT_BYTE 1
+#define UNIT_MEGABYTE 2 
+unsigned long get_accessible_ddr_size(int unit);
+int user_choice(void);/*1=yes 0=no*/
+
+#ifdef CONFIG_SYS_NONCACHED_MEMORY
+void noncached_init(void);
+phys_addr_t noncached_alloc(size_t size, size_t align);
+#endif
+
+/* block device select */
+typedef enum {
+	DEVICE_SEL_NONE = 0,
+	DEVICE_SEL_SATA,
+	DEVICE_SEL_SD,
+	DEVICE_SEL_EMMC,
+	DEVICE_SEL_NAND,
+	DEVICE_SEL_USB,
+} DEVICE_SEL_T;
+
+
+/* quickly print debug line */
+
+#define VT100_NONE          "\033[m"
+#define VT100_NONE_NL       "\033[m\n"
+#define VT100_RED           "\033[0;32;31m"
+#define VT100_LIGHT_RED     "\033[1;31m"
+#define VT100_GREEN         "\033[0;32;32m"
+#define VT100_LIGHT_GREEN   "\033[1;32m"
+#define VT100_BLUE          "\033[0;32;34m"
+#define VT100_LIGHT_BLUE    "\033[1;34m"
+#define VT100_DARY_GRAY     "\033[1;30m"
+#define VT100_CYAN          "\033[0;36m"
+#define VT100_LIGHT_CYAN    "\033[1;36m"
+#define VT100_PURPLE        "\033[0;35m"
+#define VT100_LIGHT_PURPLE  "\033[1;35m"
+#define VT100_BROWN         "\033[0;33m"
+#define VT100_YELLOW        "\033[1;33m"
+#define VT100_LIGHT_GRAY    "\033[0;37m"
+#define VT100_WHITE         "\033[1;37m"
+
+#define DDDD(fmt, args...) \
+		printf(VT100_YELLOW "%s %d: " fmt VT100_NONE_NL, __FUNCTION__, __LINE__, ##args);
+
+#define DDDDYELLOW(fmt, args...) \
+		printf(VT100_YELLOW fmt VT100_NONE, ##args);
+
+#define DDDDRED(fmt, args...) \
+		printf(VT100_LIGHT_RED fmt VT100_NONE, ##args);
+
+#define DDDDGREEN(fmt, args...) \
+		printf(VT100_LIGHT_GREEN fmt VT100_NONE, ##args);
+
 #endif	/* __COMMON_H_ */
diff --git a/include/config_cmd_all.h b/include/config_cmd_all.h
index 4c46ddad2b..819b1de846 100644
--- a/include/config_cmd_all.h
+++ b/include/config_cmd_all.h
@@ -74,5 +74,6 @@
 #define CONFIG_CMD_UNZIP	/* unzip from memory to memory	*/
 #define CONFIG_CMD_USB		/* USB Support			*/
 #define CONFIG_CMD_ZFS		/* ZFS Support			*/
+#define CONFIG_CMD_NET              /* bootp, tftpboot, rarpboot    */
 
 #endif	/* _CONFIG_CMD_ALL_H */
diff --git a/include/config_defaults.h b/include/config_defaults.h
index ad08c1d335..8184dd852f 100644
--- a/include/config_defaults.h
+++ b/include/config_defaults.h
@@ -18,6 +18,6 @@
 
 #define CONFIG_GZIP 1
 #define CONFIG_ZLIB 1
-#define CONFIG_PARTITIONS 1
+/* #define CONFIG_PARTITIONS 1 */
 
 #endif
diff --git a/include/dwc3-uboot.h b/include/dwc3-uboot.h
index 09ff8a74d6..f99bd0ba03 100644
--- a/include/dwc3-uboot.h
+++ b/include/dwc3-uboot.h
@@ -12,6 +12,11 @@
 
 #include <linux/usb/otg.h>
 
+#ifdef CONFIG_USB_DWC3_RTK
+struct usb2_phy;
+struct usb3_phy;
+#endif
+
 struct dwc3_device {
 	int base;
 	enum usb_dr_mode dr_mode;
@@ -34,6 +39,11 @@ struct dwc3_device {
 	unsigned tx_de_emphasis_quirk;
 	unsigned tx_de_emphasis;
 	int index;
+
+#ifdef CONFIG_USB_DWC3_RTK
+	struct usb2_phy *u2phy;
+	struct usb3_phy *u3phy;
+#endif
 };
 
 int dwc3_uboot_init(struct dwc3_device *dev);
diff --git a/include/env_default.h b/include/env_default.h
index 3096576836..b97a692ad2 100644
--- a/include/env_default.h
+++ b/include/env_default.h
@@ -22,12 +22,7 @@ static char default_environment[] = {
 #else
 const uchar default_environment[] = {
 #endif
-#ifdef	CONFIG_ENV_CALLBACK_LIST_DEFAULT
-	ENV_CALLBACK_VAR "=" CONFIG_ENV_CALLBACK_LIST_DEFAULT "\0"
-#endif
-#ifdef	CONFIG_ENV_FLAGS_LIST_DEFAULT
-	ENV_FLAGS_VAR "=" CONFIG_ENV_FLAGS_LIST_DEFAULT "\0"
-#endif
+#if (1)	// Chuck for DS-5
 #ifdef	CONFIG_BOOTARGS
 	"bootargs="	CONFIG_BOOTARGS			"\0"
 #endif
@@ -44,19 +39,37 @@ const uchar default_environment[] = {
 	"bootdelay="	__stringify(CONFIG_BOOTDELAY)	"\0"
 #endif
 #if defined(CONFIG_BAUDRATE) && (CONFIG_BAUDRATE >= 0)
-	"baudrate="	__stringify(CONFIG_BAUDRATE)	"\0"
+	"baudrate="	__stringify(CONFIG_BAUDRATE)		"\0"
 #endif
 #ifdef	CONFIG_LOADS_ECHO
 	"loads_echo="	__stringify(CONFIG_LOADS_ECHO)	"\0"
 #endif
-#ifdef	CONFIG_ETHPRIME
-	"ethprime="	CONFIG_ETHPRIME			"\0"
+#ifdef	CONFIG_ETH_PRIME
+	"ethprime="	__stringify(CONFIG_ETH_PRIME)		"\0"
+#endif
+#ifdef	CONFIG_ETHADDR
+	"ethaddr="	__stringify(CONFIG_ETHADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETH1ADDR
+	"eth1addr="	__stringify(CONFIG_ETH1ADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETH2ADDR
+	"eth2addr="	__stringify(CONFIG_ETH2ADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETH3ADDR
+	"eth3addr="	__stringify(CONFIG_ETH3ADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETH4ADDR
+	"eth4addr="	__stringify(CONFIG_ETH4ADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETH5ADDR
+	"eth5addr="	__stringify(CONFIG_ETH5ADDR)		"\0"
 #endif
 #ifdef	CONFIG_IPADDR
-	"ipaddr="	__stringify(CONFIG_IPADDR)	"\0"
+	"ipaddr="	__stringify(CONFIG_IPADDR)		"\0"
 #endif
 #ifdef	CONFIG_SERVERIP
-	"serverip="	__stringify(CONFIG_SERVERIP)	"\0"
+	"serverip="	__stringify(CONFIG_SERVERIP)		"\0"
 #endif
 #ifdef	CONFIG_SYS_AUTOLOAD
 	"autoload="	CONFIG_SYS_AUTOLOAD		"\0"
@@ -71,28 +84,27 @@ const uchar default_environment[] = {
 	"gatewayip="	__stringify(CONFIG_GATEWAYIP)	"\0"
 #endif
 #ifdef	CONFIG_NETMASK
-	"netmask="	__stringify(CONFIG_NETMASK)	"\0"
+	"netmask="	__stringify(CONFIG_NETMASK)		"\0"
 #endif
 #ifdef	CONFIG_HOSTNAME
-	"hostname="	__stringify(CONFIG_HOSTNAME)	"\0"
+	"hostname="	__stringify(CONFIG_HOSTNAME)		"\0"
 #endif
 #ifdef	CONFIG_BOOTFILE
 	"bootfile="	CONFIG_BOOTFILE			"\0"
 #endif
 #ifdef	CONFIG_LOADADDR
-	"loadaddr="	__stringify(CONFIG_LOADADDR)	"\0"
+	"loadaddr="	__stringify(CONFIG_LOADADDR)		"\0"
 #endif
 #ifdef	CONFIG_CLOCKS_IN_MHZ
 	"clocks_in_mhz=1\0"
 #endif
 #if defined(CONFIG_PCI_BOOTDELAY) && (CONFIG_PCI_BOOTDELAY > 0)
-	"pcidelay="	__stringify(CONFIG_PCI_BOOTDELAY)"\0"
+	"pcidelay="	__stringify(CONFIG_PCI_BOOTDELAY)	"\0"
 #endif
 #ifdef	CONFIG_ENV_VARS_UBOOT_CONFIG
 	"arch="		CONFIG_SYS_ARCH			"\0"
 	"cpu="		CONFIG_SYS_CPU			"\0"
 	"board="	CONFIG_SYS_BOARD		"\0"
-	"board_name="	CONFIG_SYS_BOARD		"\0"
 #ifdef CONFIG_SYS_VENDOR
 	"vendor="	CONFIG_SYS_VENDOR		"\0"
 #endif
@@ -100,9 +112,16 @@ const uchar default_environment[] = {
 	"soc="		CONFIG_SYS_SOC			"\0"
 #endif
 #endif
+#ifdef CONFIG_RESCUE_FROM_USB
+	"rescue_vmlinux="	CONFIG_RESCUE_FROM_USB_VMLINUX		"\0"
+	"rescue_dtb="		CONFIG_RESCUE_FROM_USB_DTB			"\0"
+	"rescue_rootfs="	CONFIG_RESCUE_FROM_USB_ROOTFS		"\0"
+	"rescue_audio="		CONFIG_RESCUE_FROM_USB_AUDIO_CORE	"\0"
+#endif /* CONFIG_RESCUE_FROM_USB */
 #ifdef	CONFIG_EXTRA_ENV_SETTINGS
 	CONFIG_EXTRA_ENV_SETTINGS
 #endif
+#endif	//Chuck for DS-5
 	"\0"
 #ifdef DEFAULT_ENV_INSTANCE_EMBEDDED
 	}
diff --git a/include/environment.h b/include/environment.h
index 1fdbdad882..b530d3c6e5 100644
--- a/include/environment.h
+++ b/include/environment.h
@@ -109,6 +109,7 @@ extern unsigned long nand_env_oob_offset;
 # if	!defined(CONFIG_ENV_IS_IN_FLASH)	&& \
 	!defined(CONFIG_ENV_IS_IN_NAND)		&& \
 	!defined(CONFIG_ENV_IS_IN_ONENAND)	&& \
+	!defined(CONFIG_ENV_IS_IN_SPI)		&& \
 	!defined(CONFIG_ENV_IS_IN_SPI_FLASH)
 #  error "CONFIG_ENV_IS_EMBEDDED not supported for your flash type"
 # endif
@@ -214,6 +215,9 @@ char *getenv_default(const char *name);
 /* [re]set to the default environment */
 void set_default_env(const char *s);
 
+/* Check the default environment */
+int check_default_env(const char *s);
+
 /* [re]set individual variables to their value in the default environment */
 int set_default_vars(int nvars, char * const vars[]);
 
diff --git a/include/fdt.h b/include/fdt.h
index 526aedb515..4956d65237 100644
--- a/include/fdt.h
+++ b/include/fdt.h
@@ -55,45 +55,45 @@
 #ifndef __ASSEMBLY__
 
 struct fdt_header {
-	fdt32_t magic;			 /* magic word FDT_MAGIC */
-	fdt32_t totalsize;		 /* total size of DT block */
-	fdt32_t off_dt_struct;		 /* offset to structure */
-	fdt32_t off_dt_strings;		 /* offset to strings */
-	fdt32_t off_mem_rsvmap;		 /* offset to memory reserve map */
-	fdt32_t version;		 /* format version */
-	fdt32_t last_comp_version;	 /* last compatible version */
+	uint32_t magic;			 /* magic word FDT_MAGIC */
+	uint32_t totalsize;		 /* total size of DT block */
+	uint32_t off_dt_struct;		 /* offset to structure */
+	uint32_t off_dt_strings;		 /* offset to strings */
+	uint32_t off_mem_rsvmap;		 /* offset to memory reserve map */
+	uint32_t version;		 /* format version */
+	uint32_t last_comp_version;	 /* last compatible version */
 
 	/* version 2 fields below */
-	fdt32_t boot_cpuid_phys;	 /* Which physical CPU id we're
+	uint32_t boot_cpuid_phys;	 /* Which physical CPU id we're
 					    booting on */
 	/* version 3 fields below */
-	fdt32_t size_dt_strings;	 /* size of the strings block */
+	uint32_t size_dt_strings;	 /* size of the strings block */
 
 	/* version 17 fields below */
-	fdt32_t size_dt_struct;		 /* size of the structure block */
+	uint32_t size_dt_struct;		 /* size of the structure block */
 };
 
 struct fdt_reserve_entry {
-	fdt64_t address;
-	fdt64_t size;
+	uint64_t address;
+	uint64_t size;
 };
 
 struct fdt_node_header {
-	fdt32_t tag;
+	uint32_t tag;
 	char name[0];
 };
 
 struct fdt_property {
-	fdt32_t tag;
-	fdt32_t len;
-	fdt32_t nameoff;
+	uint32_t tag;
+	uint32_t len;
+	uint32_t nameoff;
 	char data[0];
 };
 
 #endif /* !__ASSEMBLY */
 
 #define FDT_MAGIC	0xd00dfeed	/* 4: version, 4: total size */
-#define FDT_TAGSIZE	sizeof(fdt32_t)
+#define FDT_TAGSIZE	sizeof(uint32_t)
 
 #define FDT_BEGIN_NODE	0x1		/* Start node: full name */
 #define FDT_END_NODE	0x2		/* End node */
@@ -102,10 +102,10 @@ struct fdt_property {
 #define FDT_NOP		0x4		/* nop */
 #define FDT_END		0x9
 
-#define FDT_V1_SIZE	(7*sizeof(fdt32_t))
-#define FDT_V2_SIZE	(FDT_V1_SIZE + sizeof(fdt32_t))
-#define FDT_V3_SIZE	(FDT_V2_SIZE + sizeof(fdt32_t))
+#define FDT_V1_SIZE	(7*sizeof(uint32_t))
+#define FDT_V2_SIZE	(FDT_V1_SIZE + sizeof(uint32_t))
+#define FDT_V3_SIZE	(FDT_V2_SIZE + sizeof(uint32_t))
 #define FDT_V16_SIZE	FDT_V3_SIZE
-#define FDT_V17_SIZE	(FDT_V16_SIZE + sizeof(fdt32_t))
+#define FDT_V17_SIZE	(FDT_V16_SIZE + sizeof(uint32_t))
 
 #endif /* _FDT_H */
diff --git a/include/fdt_support.h b/include/fdt_support.h
index 0edc4fa5b1..7289ab3620 100644
--- a/include/fdt_support.h
+++ b/include/fdt_support.h
@@ -35,7 +35,7 @@ int fdt_root(void *fdt);
  * @param fdt		FDT address in memory
  * @return 0 if ok, or -FDT_ERR_... on error
  */
-int fdt_chosen(void *fdt);
+int fdt_chosen(void *fdt, int force);
 
 /**
  * Add initrd information to the FDT before booting the OS.
diff --git a/include/linux/compat.h b/include/linux/compat.h
index 6ff3915216..9a62e8102f 100644
--- a/include/linux/compat.h
+++ b/include/linux/compat.h
@@ -315,7 +315,7 @@ struct notifier_block {};
 
 typedef unsigned long dmaaddr_t;
 
-#define cpu_relax() do {} while (0)
+//#define cpu_relax() do {} while (0)
 
 #define pm_runtime_get_sync(dev) do {} while (0)
 #define pm_runtime_put(dev) do {} while (0)
diff --git a/include/mmc.h b/include/mmc.h
index dd98b3b8ac..37d075c4ab 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -56,6 +56,19 @@
 #define MMC_MODE_8BIT		(1 << 3)
 #define MMC_MODE_SPI		(1 << 4)
 #define MMC_MODE_DDR_52MHz	(1 << 5)
+#define MMC_MODE_HC             0x800
+
+#define MMC_MODE_WIDTH_BITS_SHIFT 8
+#define MMC_MODE_LEGACY			0x000
+#define MMC_MODE_HSDDR_52MHz 	0x004
+#define MMC_MODE_HS200			0x008
+
+//=====================For Realtek rtkemmc driver======================
+#define EXT_CSD_TIMING_BC       0       /* Backwards compatility */
+#define EXT_CSD_TIMING_HS       1       /* High speed */
+#define EXT_CSD_TIMING_HS200    2       /* HS200 */
+#define EXT_CSD_TIMING_HS400    3       /* HS400 */
+//=====================================================================
 
 #define SD_DATA_4BIT	0x00040000
 
@@ -95,11 +108,18 @@
 #define MMC_CMD_APP_CMD			55
 #define MMC_CMD_SPI_READ_OCR		58
 #define MMC_CMD_SPI_CRC_ON_OFF		59
+
+#define MMC_CMD_MICRON_60		60
+#define MMC_CMD_MICRON_61		61
+
 #define MMC_CMD_RES_MAN			62
 
 #define MMC_CMD62_ARG1			0xefac62ec
 #define MMC_CMD62_ARG2			0xcbaea7
 
+#define MANU_ID_MICRON1			0xfe
+#define MANU_ID_MICRON2			0x13
+
 
 #define SD_CMD_SEND_RELATIVE_ADDR	3
 #define SD_CMD_SWITCH_FUNC		6
@@ -112,6 +132,14 @@
 #define SD_CMD_APP_SEND_OP_COND		41
 #define SD_CMD_APP_SEND_SCR		51
 
+//ext csd[196] : DEVICE_TYPE
+#define MMC_HS_26MHZ		(0x1<<0)
+#define MMC_HS_52MHZ		(0x1<<1)
+#define MMC_HS_DDR_1_8V_52MHZ	(0x1<<2)    //1.8v
+#define MMC_HS_DDR_1_2V_52MHZ	(0x1<<3)    //1.2v
+#define MMC_HS_200_1_8V_52MHZ	(0x1<<4)    //1.8v
+#define MMC_HS_200_1_2V_52MHZ	(0x1<<5)    //1.2v
+
 /* SCR definitions in different words */
 #define SD_HIGHSPEED_BUSY	0x00020000
 #define SD_HIGHSPEED_SUPPORTED	0x00020000
@@ -190,6 +218,8 @@
 /*
  * EXT_CSD field definitions
  */
+ 
+#define MMC_CMD_AC	(0 << 5)
 
 #define EXT_CSD_CMD_SET_NORMAL		(1 << 0)
 #define EXT_CSD_CMD_SET_SECURE		(1 << 1)
@@ -251,6 +281,8 @@
 #define MMC_RSP_R6	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
 #define MMC_RSP_R7	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
 
+#define MMC_RSP_R1B	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE|MMC_RSP_BUSY)
+
 #define MMCPART_NOAVAILABLE	(0xff)
 #define PART_ACCESS_MASK	(0x7)
 #define PART_SUPPORT		(0x1)
@@ -262,7 +294,8 @@
 
 /* The number of MMC physical partitions.  These consist of:
  * boot partitions (2), general purpose partitions (4) in MMC v4.4.
- */
+ */ 
+#define MMC_PART_UDA  0x00
 #define MMC_NUM_BOOT_PARTITION	2
 #define MMC_PART_RPMB           3       /* RPMB partition number */
 
@@ -280,6 +313,10 @@ struct mmc_cmd {
 	uint resp_type;
 	uint cmdarg;
 	uint response[4];
+	u32 opcode;
+	u32 arg;
+	u32	resp[4];
+	u32 flags;
 };
 
 struct mmc_data {
@@ -290,6 +327,12 @@ struct mmc_data {
 	uint flags;
 	uint blocks;
 	uint blocksize;
+#ifdef CONFIG_RTK_SD_DRIVER
+	unsigned int bytes_xfered;
+	unsigned int sg_len; /* size of scatter list */
+	unsigned int buf_len;
+	unsigned long dma_addr;
+#endif /* CONFIG_RTK_SD_DRIVER */
 };
 
 /* forward decl. */
@@ -304,7 +347,7 @@ struct mmc_ops {
 	int (*getwp)(struct mmc *mmc);
 };
 
-struct mmc_config {
+/*struct mmc_config {
 	const char *name;
 	const struct mmc_ops *ops;
 	uint host_caps;
@@ -313,12 +356,16 @@ struct mmc_config {
 	uint f_max;
 	uint b_max;
 	unsigned char part_type;
-};
+};*/
 
 /* TODO struct mmc should be in mmc_private but it's hard to fix right now */
 struct mmc {
 	struct list_head link;
-	const struct mmc_config *cfg;	/* provided configuration */
+	char name[32];
+	uint voltages;
+	uint f_min;
+	uint f_max;
+//	const struct mmc_config *cfg;	/* provided configuration */
 	uint version;
 	void *priv;
 	uint has_init;
@@ -326,6 +373,7 @@ struct mmc {
 	uint bus_width;
 	uint clock;
 	uint card_caps;
+	uint host_caps;
 	uint ocr;
 	uint dsr;
 	uint dsr_imp;
@@ -338,7 +386,7 @@ struct mmc {
 	u8 wr_rel_set;
 	char part_config;
 	char part_num;
-	uint tran_speed;
+	u64 tran_speed;
 	uint read_bl_len;
 	uint write_bl_len;
 	uint erase_grp_size;	/* in 512-byte sectors */
@@ -355,6 +403,20 @@ struct mmc {
 	char init_in_progress;	/* 1 if we have done mmc_start_init() */
 	char preinit;		/* start init as early as possible */
 	int ddr_mode;
+	uint mode_sel;
+	uint boot_caps;
+	int (*request)(struct mmc *mmc,
+			struct mmc_cmd *cmd, struct mmc_data *data);
+	void (*set_ios)(struct mmc *mmc,unsigned int caps);
+	void (*init)(void);
+	int (*getcd)(struct mmc *mmc);
+#ifdef CONFIG_SD30
+	int (*switch_voltage)(struct mmc *mmc,u32 voltage);
+	int (*execute_tuning)(struct mmc *mmc, u32 opcode);
+	u32 sd_bus_mode;
+	u32 sd_bus_speed;
+#endif /* CONFIG_SD30 */
+	uint b_max;
 };
 
 struct mmc_hwpart_conf {
@@ -379,7 +441,7 @@ enum mmc_hwpart_conf_mode {
 };
 
 int mmc_register(struct mmc *mmc);
-struct mmc *mmc_create(const struct mmc_config *cfg, void *priv);
+//struct mmc *mmc_create(const struct mmc_config *cfg, void *priv);
 void mmc_destroy(struct mmc *mmc);
 int mmc_initialize(bd_t *bis);
 int mmc_init(struct mmc *mmc);
@@ -413,6 +475,7 @@ int mmc_rpmb_read(struct mmc *mmc, void *addr, unsigned short blk,
 		  unsigned short cnt, unsigned char *key);
 int mmc_rpmb_write(struct mmc *mmc, void *addr, unsigned short blk,
 		   unsigned short cnt, unsigned char *key);
+int mmc_select_sdr50(struct mmc *mmc,char* ext_csd);
 /**
  * Start device initialization and return immediately; it does not block on
  * polling OCR (operation condition register) status.  Then you should call
@@ -438,11 +501,13 @@ int mmc_start_init(struct mmc *mmc);
  */
 void mmc_set_preinit(struct mmc *mmc, int preinit);
 
+#define mmc_host_is_spi(mmc)	((mmc)->host_caps & MMC_MODE_SPI)
 #ifdef CONFIG_GENERIC_MMC
 #ifdef CONFIG_MMC_SPI
-#define mmc_host_is_spi(mmc)	((mmc)->cfg->host_caps & MMC_MODE_SPI)
+#define mmc_host_is_spi(mmc)	((mmc)->host_caps & MMC_MODE_SPI)
+//#define mmc_host_is_spi(mmc)	((mmc)->cfg->host_caps & MMC_MODE_SPI)
 #else
-#define mmc_host_is_spi(mmc)	0
+//#define mmc_host_is_spi(mmc)	0
 #endif
 struct mmc *mmc_spi_init(uint bus, uint cs, uint speed, uint mode);
 #else
@@ -473,4 +538,41 @@ int pci_mmc_init(const char *name, struct pci_device_id *mmc_supported,
 #define CONFIG_SYS_MMC_MAX_BLK_COUNT 65535
 #endif
 
+/**
+ * rtk sdmmc driver
+ */
+
+void board_sd_power_init(void);
+int board_sd_init(bd_t *bis);
+int cpu_sd_init(bd_t *bis);
+int sd_get_env_addr(struct mmc *mmc, int copy, u32 *env_addr);
+
+#ifdef CONFIG_RTK_SD_DRIVER
+  int sd_initialize(bd_t *bis);
+  int sd_register(struct mmc *mmc);
+  int sd_init(struct mmc *mmc);
+  struct mmc *find_sd_device(void);
+#endif /* CONFIG_RTK_SD_DRIVER */
+
+#ifdef CONFIG_SD30
+
+  #define MMC_SIGNAL_VOLTAGE_330 0
+  #define MMC_SIGNAL_VOLTAGE_180 1
+
+  #define SD_SWITCH_VOLTAGE 11
+  #define MMC_SEND_TUNING_BLOCK 19
+
+  #define SD_ROCR_S18A (1<<24)
+
+  #define UHS_SDR50_BUS_SPEED 2
+  #define UHS_SDR104_BUS_SPEED 3
+
+  #define MMC_CAP_UHS_SDR50 (1 << 17) /* Host supports UHS SDR50 mode */
+  #define MMC_CAP_UHS_SDR104 (1 << 18) /* Host supports UHS SDR104 mode */
+
+  #define SD_MODE_UHS_SDR104 (1 << 3)
+  #define SD_MODE_UHS_SDR50 (1 << 2)
+
+#endif /* CONFIG_SD30 */
+
 #endif /* _MMC_H_ */
diff --git a/include/nand.h b/include/nand.h
index d2a53ab856..c634267571 100644
--- a/include/nand.h
+++ b/include/nand.h
@@ -101,9 +101,13 @@ struct nand_erase_options {
 
 typedef struct nand_erase_options nand_erase_options_t;
 
+int rtknand_read(unsigned int source_address, unsigned int byte_length, unsigned int *target_address);
 int nand_read_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
 		       size_t *actual, loff_t lim, u_char *buffer);
 
+int nand_read_skip_bad_on_the_fly(nand_info_t *nand, loff_t offset, size_t *length,
+				       u_char *buffer, u16 cp_mode);
+
 #define WITH_DROP_FFS	(1 << 0) /* drop trailing all-0xff pages */
 #define WITH_WR_VERIFY	(1 << 1) /* verify data was written correctly */
 
diff --git a/include/part.h b/include/part.h
index 8ea9b3049a..936298f414 100644
--- a/include/part.h
+++ b/include/part.h
@@ -76,6 +76,8 @@ typedef struct block_dev_desc {
 #define BOOT_PART_TYPE	"U-Boot"	/* primary boot partition type	*/
 #define BOOT_PART_COMP	"PPCBoot"	/* PPCBoot compatibility type	*/
 
+#define RT_NAS_MAGIC	"0bda"		/* Realtek NAS disk magic key	*/
+
 /* device types */
 #define DEV_TYPE_UNKNOWN	0xff	/* not connected */
 #define DEV_TYPE_HARDDISK	0x00	/* harddisk */
@@ -103,6 +105,7 @@ block_dev_desc_t* sata_get_dev(int dev);
 block_dev_desc_t* scsi_get_dev(int dev);
 block_dev_desc_t* usb_stor_get_dev(int dev);
 block_dev_desc_t* mmc_get_dev(int dev);
+block_dev_desc_t* sd_get_dev(int dev); /* porting issue: FIX ME ASAP */
 int mmc_select_hwpart(int dev_num, int hwpart);
 block_dev_desc_t* systemace_get_dev(int dev);
 block_dev_desc_t* mg_disk_get_dev(int dev);
@@ -128,6 +131,7 @@ static inline block_dev_desc_t* scsi_get_dev(int dev) { return NULL; }
 static inline block_dev_desc_t* usb_stor_get_dev(int dev) { return NULL; }
 static inline block_dev_desc_t* mmc_get_dev(int dev) { return NULL; }
 static inline int mmc_select_hwpart(int dev_num, int hwpart) { return -1; }
+static inline block_dev_desc_t* sd_get_dev(int dev) { return NULL; } /* porting issue: FIX ME ASAP */
 static inline block_dev_desc_t* systemace_get_dev(int dev) { return NULL; }
 static inline block_dev_desc_t* mg_disk_get_dev(int dev) { return NULL; }
 static inline block_dev_desc_t *host_get_dev(int dev) { return NULL; }
diff --git a/include/rtc.h b/include/rtc.h
index bd8621d60b..b97f06babb 100644
--- a/include/rtc.h
+++ b/include/rtc.h
@@ -228,4 +228,7 @@ int rtc_to_tm(int time_t, struct rtc_time *time);
  */
 unsigned long rtc_mktime(const struct rtc_time *time);
 
+int rtc_alarm_state(struct rtc_time *);
+int rtc_alarm_set(struct rtc_time *);
+
 #endif	/* _RTC_H_ */
diff --git a/include/sata.h b/include/sata.h
index fa61da8ddd..64d888cdef 100644
--- a/include/sata.h
+++ b/include/sata.h
@@ -7,6 +7,8 @@ int reset_sata(int dev);
 int scan_sata(int dev);
 ulong sata_read(int dev, ulong blknr, lbaint_t blkcnt, void *buffer);
 ulong sata_write(int dev, ulong blknr, lbaint_t blkcnt, const void *buffer);
+ulong rtk_sata_read(lbaint_t blknr, lbaint_t blkcnt, void *buffer);
+ulong rtk_sata_write(lbaint_t blknr, lbaint_t blkcnt, const void *buffer);
 
 int sata_initialize(void);
 int __sata_initialize(void);
diff --git a/include/search.h b/include/search.h
index 343dbc3d48..24f0cf5d16 100644
--- a/include/search.h
+++ b/include/search.h
@@ -104,6 +104,16 @@ extern int himport_r(struct hsearch_data *__htab,
 		     const char *__env, size_t __size, const char __sep,
 		     int __flag, int __crlf_is_lf, int nvars,
 		     char * const vars[]);
+			 
+/*
+ * Check weather default environment variables saved in emmc.
+ * If not, add default environment variables in emmc.
+ */
+
+extern int h_detect_r(struct hsearch_data *htab,
+		const char *env, size_t size, const char sep, int flag,
+		int crlf_is_lf, int nvars, char * const vars[]);
+		
 
 /* Walk the whole table calling the callback on each element */
 extern int hwalk_r(struct hsearch_data *__htab, int (*callback)(ENTRY *));
diff --git a/include/serial.h b/include/serial.h
index de40e9406f..4dff0f5db5 100644
--- a/include/serial.h
+++ b/include/serial.h
@@ -17,6 +17,7 @@ struct serial_device {
 #if CONFIG_POST & CONFIG_SYS_POST_UART
 	void	(*loop)(int);
 #endif
+	void	(*putc_raw)(const char c);
 	struct serial_device	*next;
 };
 
@@ -25,6 +26,7 @@ void default_serial_puts(const char *s);
 extern struct serial_device serial_smc_device;
 extern struct serial_device serial_scc_device;
 extern struct serial_device *default_serial_console(void);
+extern struct serial_device *get_serial_console(char uart);
 
 #if	defined(CONFIG_405GP) || \
 	defined(CONFIG_405EP) || defined(CONFIG_405EZ) || \
diff --git a/include/usb.h b/include/usb.h
index dca512d394..58cc839f31 100644
--- a/include/usb.h
+++ b/include/usb.h
@@ -89,6 +89,17 @@ enum {
 	PACKET_SIZE_64  = 3,
 };
 
+struct controller {
+	int ctrl_type;
+	void *unsed; //Note we only use ctrl_type
+};
+
+enum {
+	CTRL_TYPE_UNKNOW = 0,
+	CTRL_TYPE_EHCI   = 1,
+	CTRL_TYPE_XHCI   = 2,
+};
+
 /**
  * struct usb_device - information about a USB device
  *
@@ -153,6 +164,9 @@ struct usb_device {
 	struct udevice *dev;		/* Pointer to associated device */
 	struct udevice *controller_dev;	/* Pointer to associated controller */
 #endif
+
+	char level; //hcy added
+	int route; //hcy added
 };
 
 struct int_queue;
@@ -172,7 +186,12 @@ enum usb_init_type {
  */
 
 int usb_lowlevel_init(int index, enum usb_init_type init, void **controller);
+#ifdef CONFIG_USB_RTK
+int usb_lowlevel_stop_all(void);
+int usb_host_controller_init(void);
+#else
 int usb_lowlevel_stop(int index);
+#endif
 
 #if defined(CONFIG_MUSB_HOST) || defined(CONFIG_DM_USB)
 int usb_reset_root_port(void);
@@ -180,9 +199,9 @@ int usb_reset_root_port(void);
 #define usb_reset_root_port()
 #endif
 
-int submit_bulk_msg(struct usb_device *dev, unsigned long pipe,
+int submit_bulk_msg(struct usb_device *dev, unsigned int pipe,
 			void *buffer, int transfer_len);
-int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
+int submit_control_msg(struct usb_device *dev, unsigned int pipe, void *buffer,
 			int transfer_len, struct devrequest *setup);
 int submit_int_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 			int transfer_len, int interval);
@@ -914,7 +933,7 @@ int usb_emul_setup_device(struct udevice *dev, int maxpacketsize,
  * @return 0 if OK, -ve on error
  */
 int usb_emul_control(struct udevice *emul, struct usb_device *udev,
-		     unsigned long pipe, void *buffer, int length,
+		     unsigned int pipe, void *buffer, int length,
 		     struct devrequest *setup);
 
 /**
@@ -926,7 +945,7 @@ int usb_emul_control(struct udevice *emul, struct usb_device *udev,
  * @return 0 if OK, -ve on error
  */
 int usb_emul_bulk(struct udevice *emul, struct usb_device *udev,
-		  unsigned long pipe, void *buffer, int length);
+		  unsigned int pipe, void *buffer, int length);
 
 /**
  * usb_emul_find() - Find an emulator for a particular device
diff --git a/include/usb_defs.h b/include/usb_defs.h
index 8214ba9bf5..aeb68529e7 100644
--- a/include/usb_defs.h
+++ b/include/usb_defs.h
@@ -93,6 +93,7 @@
 #define USB_DT_REPORT       (USB_TYPE_CLASS | 0x02)
 #define USB_DT_PHYSICAL     (USB_TYPE_CLASS | 0x03)
 #define USB_DT_HUB          (USB_TYPE_CLASS | 0x09)
+#define USB_DT_SS_HUB       (USB_TYPE_CLASS | 0x0A)
 
 /* Descriptor sizes per descriptor type */
 #define USB_DT_DEVICE_SIZE      18
@@ -217,6 +218,12 @@
 #define C_HUB_LOCAL_POWER   0
 #define C_HUB_OVER_CURRENT  1
 
+/*
+ * Hub class additional requests defined by USB 3.0 spec
+ */
+#define HUB_SET_DEPTH           12
+#define HUB_GET_PORT_ERR_COUNT  13
+
 /*
  * Port feature numbers
  */
diff --git a/include/watchdog.h b/include/watchdog.h
index 9273fa1e80..c8baff8c5e 100644
--- a/include/watchdog.h
+++ b/include/watchdog.h
@@ -11,6 +11,8 @@
 #ifndef _WATCHDOG_H_
 #define _WATCHDOG_H_
 
+#include <watchdog_api.h>
+
 #if !defined(__ASSEMBLY__)
 /*
  * Reset the watchdog timer, always returns 0
diff --git a/lib/Kconfig b/lib/Kconfig
index c98d3997b7..e8d2bc4388 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -96,4 +96,9 @@ config ERRNO_STR
 	  - if errno is null or positive number - a pointer to "Success" message
 	  - if errno is negative - a pointer to errno related message
 
+config FASTBOOT_RTK
+	bool "Enable rtk fastboot support"
+	help
+	 Enable realtek fastboot support
+
 endmenu
diff --git a/lib/Makefile b/lib/Makefile
index 97ed398ade..3525b969da 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_TIZEN) += tizen/
 obj-$(CONFIG_OF_LIBFDT) += libfdt/
 obj-$(CONFIG_FIT) += libfdt/
 
+obj-y += tar.o
 obj-$(CONFIG_AES) += aes.o
 obj-$(CONFIG_USB_TTY) += circbuf.o
 obj-y += crc7.o
@@ -73,5 +74,8 @@ obj-$(CONFIG_TRACE) += trace.o
 obj-$(CONFIG_LIB_UUID) += uuid.o
 obj-y += vsprintf.o
 obj-$(CONFIG_LIB_RAND) += rand.o
+obj-y += parse_h.o
+obj-y += rand.o
+obj-$(CONFIG_FASTBOOT_RTK) += fastboot/
 
 subdir-ccflags-$(CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED) += -O2
diff --git a/lib/fdtdec.c b/lib/fdtdec.c
index 9877849f99..9acb09d25d 100644
--- a/lib/fdtdec.c
+++ b/lib/fdtdec.c
@@ -103,7 +103,7 @@ fdt_addr_t fdtdec_get_addr_size(const void *blob, int node,
 					sizeof(fdt_addr_t));
 			*sizep = fdt_size_to_cpu(*size);
 			debug("addr=%08lx, size=%08x\n",
-			      (ulong)addr, *sizep);
+			      (ulong)addr, (unsigned int)(uintptr_t)*sizep);
 		} else {
 			debug("%08lx\n", (ulong)addr);
 		}
diff --git a/lib/hashtable.c b/lib/hashtable.c
index 18ed5901ec..018dcf4c89 100644
--- a/lib/hashtable.c
+++ b/lib/hashtable.c
@@ -952,6 +952,161 @@ int himport_r(struct hsearch_data *htab,
 	return 1;		/* everything OK */
 }
 
+/*
+ * h_detect_r()
+ */
+
+/*
+ * Check weather default environment variables saved in emmc.
+ * If not, add default environment variables in emmc.
+ */
+
+int h_detect_r(struct hsearch_data *htab,
+		const char *env, size_t size, const char sep, int flag,
+		int crlf_is_lf, int nvars, char * const vars[])
+{
+	char *data, *sp, *dp, *name, *value;
+	char *localvars[nvars];
+	int i, update_var = 1;
+
+	/* Test for correct arguments.  */
+	if (htab == NULL) {
+		__set_errno(EINVAL);
+		return 0;
+	}
+
+	/* we allocate new space to make sure we can write to the array */
+	if ((data = malloc(size)) == NULL) {
+		debug("himport_r: can't malloc %zu bytes\n", size);
+		__set_errno(ENOMEM);
+		return 0;
+	}
+	memcpy(data, env, size);
+	dp = data;
+
+	/* make a local copy of the list of variables */
+	if (nvars)
+		memcpy(localvars, vars, sizeof(vars[0]) * nvars);
+	
+
+	if(!size)
+		return 1;		/* everything OK */
+	if(crlf_is_lf) {
+		/* Remove Carriage Returns in front of Line Feeds */
+		unsigned ignored_crs = 0;
+		for(;dp < data + size && *dp; ++dp) {
+			if(*dp == '\r' &&
+			   dp < data + size - 1 && *(dp+1) == '\n')
+				++ignored_crs;
+			else
+				*(dp-ignored_crs) = *dp;
+		}
+		size -= ignored_crs;
+		dp = data;
+	}
+	/* Parse environment; allow for '\0' and 'sep' as separators */
+	do {
+		ENTRY e, *rv;
+
+		/* skip leading white space */
+		while (isblank(*dp))
+			++dp;
+
+		/* skip comment lines */
+		if (*dp == '#') {
+			while (*dp && (*dp != sep))
+				++dp;
+			++dp;
+			continue;
+		}
+
+		/* parse name */
+		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
+			;
+
+		/* deal with "name" and "name=" entries (delete var) */
+		if (*dp == '\0' || *(dp + 1) == '\0' ||
+		    *dp == sep || *(dp + 1) == sep) {
+			if (*dp == '=')
+				*dp++ = '\0';
+			*dp++ = '\0';	/* terminate name */
+
+			debug("DELETE CANDIDATE: \"%s\"\n", name);
+			if (!drop_var_from_set(name, nvars, localvars))
+				continue;
+
+			if (hdelete_r(name, htab, flag) == 0)
+				debug("DELETE ERROR ##############################\n");
+
+			continue;
+		}
+		*dp++ = '\0';	/* terminate name */
+
+		/* parse value; deal with escapes */
+		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
+			if ((*dp == '\\') && *(dp + 1))
+				++dp;
+			*sp++ = *dp;
+		}
+		*sp++ = '\0';	/* terminate value */
+		++dp;
+
+		if (*name == 0) {
+			debug("INSERT: unable to use an empty key\n");
+			__set_errno(EINVAL);
+			return 0;
+		}
+
+		/* Skip variables which are not supposed to be processed */
+		if (!drop_var_from_set(name, nvars, localvars))
+			continue;
+
+		/* enter into hash table */
+		e.key = name;
+		e.data = value;
+		
+		hsearch_r(e, FIND, &rv, htab, flag);
+		if (rv != NULL)
+			continue;
+		
+		update_var = 0; /*If add new default variable.*/
+		
+		hsearch_r(e, ENTER, &rv, htab, flag);
+		if (rv == NULL)
+			printf("himport_r: can't insert \"%s=%s\" into hash table\n",
+				name, value);
+
+		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
+			htab, htab->filled, htab->size,
+			rv, name, value);
+	} while ((dp < data + size) && *dp);	/* size check needed for text */
+						/* without '\0' termination */
+	debug("INSERT: free(data = %p)\n", data);
+	free(data);
+
+	/* process variables which were not considered */
+	for (i = 0; i < nvars; i++) {
+		if (localvars[i] == NULL)
+			continue;
+		/*
+		 * All variables which were not deleted from the variable list
+		 * were not present in the imported env
+		 * This could mean two things:
+		 * a) if the variable was present in current env, we delete it
+		 * b) if the variable was not present in current env, we notify
+		 *    it might be a typo
+		 */
+		if (hdelete_r(localvars[i], htab, flag) == 0)
+			printf("WARNING: '%s' neither in running nor in imported env!\n", localvars[i]);
+		else
+			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
+	}
+
+	debug("INSERT: done\n");
+	return update_var;		/* everything OK */
+}
+
+
 /*
  * hwalk_r()
  */
diff --git a/lib/lzma/LzmaTools.c b/lib/lzma/LzmaTools.c
index f88629b74f..caba173583 100644
--- a/lib/lzma/LzmaTools.c
+++ b/lib/lzma/LzmaTools.c
@@ -98,11 +98,14 @@ int lzmaBuffToBuffDecompress (unsigned char *outStream, SizeT *uncompressedSize,
     g_Alloc.Free = SzFree;
 
     /* Short-circuit early if we know the buffer can't hold the results. */
-    if (outSizeFull != (SizeT)-1 && *uncompressedSize < outSizeFull)
+    if (outSizeFull != (SizeT)-1 && *uncompressedSize && *uncompressedSize < outSizeFull)
         return SZ_ERROR_OUTPUT_EOF;
 
     /* Decompress */
+    if (*uncompressedSize)
     outProcessed = min(outSizeFull, *uncompressedSize);
+    else
+    outProcessed = outSizeFull;
 
     WATCHDOG_RESET();
 
diff --git a/tools/Makefile b/tools/Makefile
index 8ff9c2e108..5e0d24044c 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -27,6 +27,7 @@ ENVCRC-$(CONFIG_ENV_IS_IN_ONENAND) = y
 ENVCRC-$(CONFIG_ENV_IS_IN_NAND) = y
 ENVCRC-$(CONFIG_ENV_IS_IN_NVRAM) = y
 ENVCRC-$(CONFIG_ENV_IS_IN_SPI_FLASH) = y
+ENVCRC-$(CONFIG_ENV_IS_IN_SPI) = y
 CONFIG_BUILD_ENVCRC ?= $(ENVCRC-y)
 
 hostprogs-$(CONFIG_SPL_GENERATE_ATMEL_PMECC_HEADER) += atmel_pmecc_params
diff --git a/tools/env/fw_env.c b/tools/env/fw_env.c
index daa02a760e..5231dba48f 100644
--- a/tools/env/fw_env.c
+++ b/tools/env/fw_env.c
@@ -10,6 +10,7 @@
 
 #define _GNU_SOURCE
 
+#include <compiler.h>
 #include <errno.h>
 #include <env_flags.h>
 #include <fcntl.h>
@@ -920,7 +921,9 @@ static int flash_write_buf (int dev, int fd, void *buf, size_t count,
 			erase.start = blockstart;
 			ioctl(fd, MEMUNLOCK, &erase);
 			/* These do not need an explicit erase cycle */
+#ifndef CONFIG_RTD1295
 			if (mtd_type != MTD_DATAFLASH)
+#endif
 				if (ioctl(fd, MEMERASE, &erase) != 0) {
 					fprintf(stderr,
 						"MTD erase error on %s: %s\n",
-- 
2.23.0

